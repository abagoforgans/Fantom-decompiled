contract main {




// =====================  Runtime code  =====================


#
#  - add(uint256 arg1, address arg2, bool arg3)
#  - withdraw(uint256 arg1, uint256 arg2)
#  - deposit(uint256 arg1, uint256 arg2)
#
const mmPoolId = 0

const BONUS_MULTIPLIER = 10


address owner;
address mmAddress;
uint256 devFundDivRate;
address devaddr;
uint256 devMultiplier;
uint256 treasuryDivRate;
address treasuryAddr;
uint256 treasuryMultiplier;
uint256 bonusEndBlock;
uint256 mmPerBlock;
array of struct poolInfo;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 startBlock;
mapping of uint8 stor14;

function treasuryMultiplier() payable {
    return treasuryMultiplier
}

function poolLength() payable {
    return poolInfo.length
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, 
           poolInfo[arg1].field_256,
           poolInfo[arg1].field_512,
           poolInfo[arg1].field_768,
           poolInfo[arg1].field_1024
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function bonusEndBlock() payable {
    return bonusEndBlock
}

function treasuryDivRate() payable {
    return treasuryDivRate
}

function treasuryAddr() payable {
    return treasuryAddr
}

function startBlock() payable {
    return startBlock
}

function devFundDivRate() payable {
    return devFundDivRate
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256
}

function mmPerBlock() payable {
    return mmPerBlock
}

function devMultiplier() payable {
    return devMultiplier
}

function devaddr() payable {
    return devaddr
}

function mm() payable {
    return mmAddress
}

function buybackNotifiers(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor14[arg1])
}

function _fallback() payable {
    revert
}

function dev(address arg1) payable {
    require calldata.size - 4 >= 32
    if devaddr != msg.sender:
        revert with 0, 'dev: wut?'
    devaddr = arg1
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setTreasury(address arg1) payable {
    require calldata.size - 4 >= 32
    if treasuryAddr != msg.sender:
        revert with 0, 'treasury: wut?'
    treasuryAddr = arg1
}

function setBonusEndBlock(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    bonusEndBlock = arg1
}

function setMMPerBlock(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg1 <= 0:
        revert with 0, '!mmPerBlock-0'
    mmPerBlock = arg1
}

function setDevMultiplier(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg1 <= 0:
        revert with 0, '!devMultiplier-0'
    devMultiplier = arg1
}

function setDevFundDivRate(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg1 <= 0:
        revert with 0, '!devFundDivRate-0'
    devFundDivRate = arg1
}

function setTreasuryDivRate(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg1 <= 0:
        revert with 0, '!treasuryDivRate-0'
    treasuryDivRate = arg1
}

function setTreasuryMultiplier(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg1 <= 0:
        revert with 0, '!treasuryMultiplier-0'
    treasuryMultiplier = arg1
}

function setBuybackNotifier(address arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0, '!invalid-notifier'
    stor14[address(arg1)] = uint8(arg2)
}

function getLpSupply(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if not arg1:
        return poolInfo[arg1].field_1024
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function transferMMOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    require ext_code.size(mmAddress)
    staticcall mmAddress.0x8da5cb5b with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != this.address:
        revert with 0, '!notMMOwner'
    require ext_code.size(mmAddress)
    call mmAddress.0xf2fde38b with:
         gas gas_remaining wei
        args owner
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function getMultiplier(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 <= bonusEndBlock:
        if arg1 > arg2:
            revert with 0, 'SafeMath: subtraction overflow'
        if not arg2 - arg1:
            return 0
        if (10 * arg2) - (10 * arg1) / arg2 - arg1 != 10:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        return ((10 * arg2) - (10 * arg1))
    if arg1 >= bonusEndBlock:
        if arg1 > arg2:
            revert with 0, 'SafeMath: subtraction overflow'
        return (arg2 - arg1)
    if bonusEndBlock > arg2:
        revert with 0, 'SafeMath: subtraction overflow'
    if arg1 > bonusEndBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if not bonusEndBlock - arg1:
        if arg2 - bonusEndBlock < 0:
            revert with 0, 'SafeMath: addition overflow'
        return (arg2 - bonusEndBlock)
    if (10 * bonusEndBlock) - (10 * arg1) / bonusEndBlock - arg1 != 10:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if arg2 + (9 * bonusEndBlock) < 10 * bonusEndBlock:
        revert with 0, 'SafeMath: addition overflow'
    return (arg2 + (9 * bonusEndBlock) - (10 * arg1))
}

function notifyBuybackReward(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if bool(stor14[msg.sender]) != 1:
        revert with 0, '!buybackNotifier'
    if arg1 <= 0:
        revert with 0, '!_amount'
    require ext_code.size(mmAddress)
    staticcall mmAddress.0x18160ddd with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg1 >= ext_call.return_data[0]:
        revert with 0, '!_amount'
    require 0 < poolInfo.length
    if uint256(poolInfo.field_1024) <= 0:
        revert with 0, '!mmPoolActivated'
    require 0 < poolInfo.length
    if not arg1:
        if not uint256(poolInfo.field_1024):
            revert with 0, 'SafeMath: division by zero'
        if (0 / uint256(poolInfo.field_1024)) + uint256(poolInfo.field_768) < uint256(poolInfo.field_768):
            revert with 0, 'SafeMath: addition overflow'
        uint256(poolInfo.field_768) += 0 / uint256(poolInfo.field_1024)
    else:
        if 10^12 * arg1 / arg1 != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if not uint256(poolInfo.field_1024):
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * arg1 / uint256(poolInfo.field_1024)) + uint256(poolInfo.field_768) < uint256(poolInfo.field_768):
            revert with 0, 'SafeMath: addition overflow'
        uint256(poolInfo.field_768) += 10^12 * arg1 / uint256(poolInfo.field_1024)
    emit BuybackMM(arg1, uint256(poolInfo.field_1024));
}

function emergencyWithdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    if not ext_code.hash(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][msg.sender].field_32
    call poolInfo[arg1].field_0 with:
       funct uint32(msg.sender)
         gas gas_remaining wei
        args userInfo[arg1][msg.sender].field_0, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][msg.sender].field_0
        if not unknown_0xa9059cbb(?????), Mask(224, 32, msg.sender) >> 32:
            revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    emit EmergencyWithdraw(userInfo[arg1][msg.sender].field_0, msg.sender, arg1);
    if userInfo[arg1][msg.sender].field_0 > poolInfo[arg1].field_1024:
        revert with 0, 'SafeMath: subtraction overflow'
    poolInfo[arg1].field_1024 -= userInfo[arg1][msg.sender].field_0
    userInfo[arg1][msg.sender].field_0 = 0
    userInfo[arg1][msg.sender].field_256 = 0
}

function pendingMM(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 < poolInfo.length
    if not arg1:
        if block.number <= poolInfo[arg1].field_512:
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if not poolInfo[arg1].field_1024:
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if block.number <= bonusEndBlock:
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not poolInfo[arg1].field_1024:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * block.number) - (10 * poolInfo[arg1].field_512) / block.number - poolInfo[arg1].field_512 != 10:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not (10 * block.number) - (10 * poolInfo[arg1].field_512):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not poolInfo[arg1].field_1024:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) / (10 * block.number) - (10 * poolInfo[arg1].field_512) != mmPerBlock:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not poolInfo[arg1].field_1024:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not poolInfo[arg1].field_1024:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if poolInfo[arg1].field_512 >= bonusEndBlock:
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not poolInfo[arg1].field_1024:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock) / block.number - poolInfo[arg1].field_512 != mmPerBlock:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not poolInfo[arg1].field_1024:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not poolInfo[arg1].field_1024:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if bonusEndBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if poolInfo[arg1].field_512 > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not bonusEndBlock - poolInfo[arg1].field_512:
            if block.number - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not block.number - bonusEndBlock:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not poolInfo[arg1].field_1024:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) / block.number - bonusEndBlock != mmPerBlock:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint:
                    if not poolInfo[arg1].field_1024:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not poolInfo[arg1].field_1024:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if block.number + (9 * bonusEndBlock) < 10 * bonusEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        if not block.number + (9 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not poolInfo[arg1].field_1024:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) / block.number + (9 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != mmPerBlock:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not poolInfo[arg1].field_1024:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not poolInfo[arg1].field_1024:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
            if not poolInfo[arg1].field_1024:
                revert with 0, 'SafeMath: division by zero'
            if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not poolInfo[arg1].field_1024:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if block.number <= poolInfo[arg1].field_512:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if not ext_call.return_data[0]:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if block.number <= bonusEndBlock:
        if poolInfo[arg1].field_512 > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - poolInfo[arg1].field_512:
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * block.number) - (10 * poolInfo[arg1].field_512) / block.number - poolInfo[arg1].field_512 != 10:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not (10 * block.number) - (10 * poolInfo[arg1].field_512):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) / (10 * block.number) - (10 * poolInfo[arg1].field_512) != mmPerBlock:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if poolInfo[arg1].field_512 >= bonusEndBlock:
        if poolInfo[arg1].field_512 > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - poolInfo[arg1].field_512:
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock) / block.number - poolInfo[arg1].field_512 != mmPerBlock:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if bonusEndBlock > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if poolInfo[arg1].field_512 > bonusEndBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if not bonusEndBlock - poolInfo[arg1].field_512:
        if block.number - bonusEndBlock < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not block.number - bonusEndBlock:
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) / block.number - bonusEndBlock != mmPerBlock:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint:
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if block.number + (9 * bonusEndBlock) < 10 * bonusEndBlock:
        revert with 0, 'SafeMath: addition overflow'
    if not block.number + (9 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) / block.number + (9 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != mmPerBlock:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if not (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock):
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if not totalAllocPoint:
        revert with 0, 'SafeMath: division by zero'
    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero'
    if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        return -userInfo[arg1][address(arg2)].field_256
    if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow'
    return (((10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if block.number > poolInfo[arg1].field_512:
        require arg1 < poolInfo.length
        if not arg1:
            if poolInfo[arg1].field_1024:
                if block.number <= bonusEndBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        require arg1 < poolInfo.length
                        if not 0 / totalAllocPoint:
                            if not poolInfo[arg1].field_1024:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                        else:
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if not poolInfo[arg1].field_1024:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024
                        if not devFundDivRate:
                            revert with 0, 'SafeMath: division by zero'
                        if not 0 / totalAllocPoint / devFundDivRate:
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args devaddr, 0
                        else:
                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not treasuryDivRate:
                            revert with 0, 'SafeMath: division by zero'
                        if not 0 / totalAllocPoint / treasuryDivRate:
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0
                        else:
                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(mmAddress)
                        call mmAddress.mint(address rg1, uint256 rg2) with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                    else:
                        if (10 * block.number) - (10 * poolInfo[arg1].field_512) / block.number - poolInfo[arg1].field_512 != 10:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        if not (10 * block.number) - (10 * poolInfo[arg1].field_512):
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            require arg1 < poolInfo.length
                            if not 0 / totalAllocPoint:
                                if not poolInfo[arg1].field_1024:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                            else:
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if not poolInfo[arg1].field_1024:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024
                            if not devFundDivRate:
                                revert with 0, 'SafeMath: division by zero'
                            if not 0 / totalAllocPoint / devFundDivRate:
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args devaddr, 0
                            else:
                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not treasuryDivRate:
                                revert with 0, 'SafeMath: division by zero'
                            if not 0 / totalAllocPoint / treasuryDivRate:
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                        else:
                            if (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) / (10 * block.number) - (10 * poolInfo[arg1].field_512) != mmPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock):
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not 0 / totalAllocPoint:
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                                else:
                                    if 10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate / (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate / (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                else:
                    if poolInfo[arg1].field_512 >= bonusEndBlock:
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            require arg1 < poolInfo.length
                            if not 0 / totalAllocPoint:
                                if not poolInfo[arg1].field_1024:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                            else:
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if not poolInfo[arg1].field_1024:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024
                            if not devFundDivRate:
                                revert with 0, 'SafeMath: division by zero'
                            if not 0 / totalAllocPoint / devFundDivRate:
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args devaddr, 0
                            else:
                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not treasuryDivRate:
                                revert with 0, 'SafeMath: division by zero'
                            if not 0 / totalAllocPoint / treasuryDivRate:
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                        else:
                            if (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock) / block.number - poolInfo[arg1].field_512 != mmPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock):
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not 0 / totalAllocPoint:
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                                else:
                                    if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                    else:
                        if bonusEndBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if poolInfo[arg1].field_512 > bonusEndBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not bonusEndBlock - poolInfo[arg1].field_512:
                            if block.number - bonusEndBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not block.number - bonusEndBlock:
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not 0 / totalAllocPoint:
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) / block.number - bonusEndBlock != mmPerBlock:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if not (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock):
                                    if not totalAllocPoint:
                                        revert with 0, 'SafeMath: division by zero'
                                    require arg1 < poolInfo.length
                                    if not 0 / totalAllocPoint:
                                        if not poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024
                                    if not devFundDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not treasuryDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not totalAllocPoint:
                                        revert with 0, 'SafeMath: division by zero'
                                    require arg1 < poolInfo.length
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if not poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                                    else:
                                        if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024
                                    if not devFundDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                    else:
                                        if devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not treasuryDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                        else:
                            if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if block.number + (9 * bonusEndBlock) < 10 * bonusEndBlock:
                                revert with 0, 'SafeMath: addition overflow'
                            if not block.number + (9 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not 0 / totalAllocPoint:
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if not poolInfo[arg1].field_1024:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) / block.number + (9 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != mmPerBlock:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if not (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock):
                                    if not totalAllocPoint:
                                        revert with 0, 'SafeMath: division by zero'
                                    require arg1 < poolInfo.length
                                    if not 0 / totalAllocPoint:
                                        if not poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1024
                                    if not devFundDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not treasuryDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not totalAllocPoint:
                                        revert with 0, 'SafeMath: division by zero'
                                    require arg1 < poolInfo.length
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if not poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1024
                                    else:
                                        if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not poolInfo[arg1].field_1024:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1024
                                    if not devFundDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                    else:
                                        if devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not treasuryDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
        else:
            require ext_code.size(poolInfo[arg1].field_0)
            staticcall poolInfo[arg1].field_0.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0]:
                if block.number <= bonusEndBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        require arg1 < poolInfo.length
                        if not 0 / totalAllocPoint:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        if not devFundDivRate:
                            revert with 0, 'SafeMath: division by zero'
                        if not 0 / totalAllocPoint / devFundDivRate:
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args devaddr, 0
                        else:
                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not treasuryDivRate:
                            revert with 0, 'SafeMath: division by zero'
                        if not 0 / totalAllocPoint / treasuryDivRate:
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0
                        else:
                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(mmAddress)
                        call mmAddress.mint(address rg1, uint256 rg2) with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                    else:
                        if (10 * block.number) - (10 * poolInfo[arg1].field_512) / block.number - poolInfo[arg1].field_512 != 10:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        if not (10 * block.number) - (10 * poolInfo[arg1].field_512):
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            require arg1 < poolInfo.length
                            if not 0 / totalAllocPoint:
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            if not devFundDivRate:
                                revert with 0, 'SafeMath: division by zero'
                            if not 0 / totalAllocPoint / devFundDivRate:
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args devaddr, 0
                            else:
                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not treasuryDivRate:
                                revert with 0, 'SafeMath: division by zero'
                            if not 0 / totalAllocPoint / treasuryDivRate:
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                        else:
                            if (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) / (10 * block.number) - (10 * poolInfo[arg1].field_512) != mmPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock):
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not 0 / totalAllocPoint:
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (10 * block.number * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate / (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate / (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, (10 * block.number * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                else:
                    if poolInfo[arg1].field_512 >= bonusEndBlock:
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            require arg1 < poolInfo.length
                            if not 0 / totalAllocPoint:
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            if not devFundDivRate:
                                revert with 0, 'SafeMath: division by zero'
                            if not 0 / totalAllocPoint / devFundDivRate:
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args devaddr, 0
                            else:
                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not treasuryDivRate:
                                revert with 0, 'SafeMath: division by zero'
                            if not 0 / totalAllocPoint / treasuryDivRate:
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                        else:
                            if (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock) / block.number - poolInfo[arg1].field_512 != mmPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock):
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not 0 / totalAllocPoint:
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) - (poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * mmPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                    else:
                        if bonusEndBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if poolInfo[arg1].field_512 > bonusEndBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not bonusEndBlock - poolInfo[arg1].field_512:
                            if block.number - bonusEndBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not block.number - bonusEndBlock:
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not 0 / totalAllocPoint:
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) / block.number - bonusEndBlock != mmPerBlock:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if not (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock):
                                    if not totalAllocPoint:
                                        revert with 0, 'SafeMath: division by zero'
                                    require arg1 < poolInfo.length
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    if not devFundDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not treasuryDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not totalAllocPoint:
                                        revert with 0, 'SafeMath: division by zero'
                                    require arg1 < poolInfo.length
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    if not devFundDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                    else:
                                        if devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not treasuryDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * mmPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                        else:
                            if (10 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) / bonusEndBlock - poolInfo[arg1].field_512 != 10:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if block.number + (9 * bonusEndBlock) < 10 * bonusEndBlock:
                                revert with 0, 'SafeMath: addition overflow'
                            if not block.number + (9 * bonusEndBlock) - (10 * poolInfo[arg1].field_512):
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                require arg1 < poolInfo.length
                                if not 0 / totalAllocPoint:
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                if not devFundDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not treasuryDivRate:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) / block.number + (9 * bonusEndBlock) - (10 * poolInfo[arg1].field_512) != mmPerBlock:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if not (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock):
                                    if not totalAllocPoint:
                                        revert with 0, 'SafeMath: division by zero'
                                    require arg1 < poolInfo.length
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    if not devFundDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not treasuryDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[arg1].field_512 * mmPerBlock) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not totalAllocPoint:
                                        revert with 0, 'SafeMath: division by zero'
                                    require arg1 < poolInfo.length
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    if not devFundDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                    else:
                                        if devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not treasuryDivRate:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * mmPerBlock * poolInfo[arg1].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[arg1].field_256) - (10 * poolInfo[arg1].field_512 * mmPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
        poolInfo[arg1].field_512 = block.number
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 10
        if block.number > poolInfo[idx].field_512:
            require idx < poolInfo.length
            mem[0] = 10
            if not idx:
                if poolInfo[idx].field_1024:
                    if block.number <= bonusEndBlock:
                        _1784 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1784] = 30
                        mem[_1784 + 32] = 'SafeMath: subtraction overflow'
                        if poolInfo[idx].field_512 > block.number:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _1784 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[idx].field_512:
                            _1916 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1916] = 26
                            mem[_1916 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _1935 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1935 + 68] = mem[idx + _1916 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1935 + 68] = mem[_1935 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _1935 + -mem[64] + 100
                            require idx < poolInfo.length
                            mem[0] = 10
                            if not 0 / totalAllocPoint:
                                _2097 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2097] = 26
                                mem[_2097 + 32] = 'SafeMath: division by zero'
                                if not poolInfo[idx].field_1024:
                                    _2155 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2155 + 68] = mem[idx + _2097 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2155 + 68] = mem[_2155 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _2155 + -mem[64] + 100
                                if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                _2472 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2472] = 26
                                mem[_2472 + 32] = 'SafeMath: division by zero'
                                if not devFundDivRate:
                                    _2547 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2547 + 68] = mem[idx + _2472 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2547 + 68] = mem[_2547 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _2547 + -mem[64] + 100
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3115 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3115] = 26
                                    mem[_3115 + 32] = 'SafeMath: division by zero'
                                    if not treasuryDivRate:
                                        _3236 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3236 + 68] = mem[idx + _3115 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3236 + 68] = mem[_3236 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _3236 + -mem[64] + 100
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3175 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3175] = 26
                                    mem[_3175 + 32] = 'SafeMath: division by zero'
                                    if not treasuryDivRate:
                                        _3314 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3314 + 68] = mem[idx + _3175 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3314 + 68] = mem[_3314 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _3314 + -mem[64] + 100
                            else:
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _2124 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2124] = 26
                                mem[_2124 + 32] = 'SafeMath: division by zero'
                                if not poolInfo[idx].field_1024:
                                    _2194 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2194 + 68] = mem[idx + _2124 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2194 + 68] = mem[_2194 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _2194 + -mem[64] + 100
                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                _2507 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2507] = 26
                                mem[_2507 + 32] = 'SafeMath: division by zero'
                                if not devFundDivRate:
                                    _2596 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2596 + 68] = mem[idx + _2507 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2596 + 68] = mem[_2596 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _2596 + -mem[64] + 100
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3174 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3174] = 26
                                    mem[_3174 + 32] = 'SafeMath: division by zero'
                                    if not treasuryDivRate:
                                        _3311 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3311 + 68] = mem[idx + _3174 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3311 + 68] = mem[_3311 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _3311 + -mem[64] + 100
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3235 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3235] = 26
                                    mem[_3235 + 32] = 'SafeMath: division by zero'
                                    if not treasuryDivRate:
                                        _3396 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3396 + 68] = mem[idx + _3235 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3396 + 68] = mem[_3396 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _3396 + -mem[64] + 100
                            ('stor', ('name', 'treasuryDivRate', 5))
                            if not 0 / totalAllocPoint / treasuryDivRate:
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                        else:
                            if (10 * block.number) - (10 * poolInfo[idx].field_512) / block.number - poolInfo[idx].field_512 != 10:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (10 * block.number) - (10 * poolInfo[idx].field_512):
                                _1926 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1926] = 26
                                mem[_1926 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _1947 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1947 + 68] = mem[idx + _1926 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1947 + 68] = mem[_1947 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _1947 + -mem[64] + 100
                                require idx < poolInfo.length
                                mem[0] = 10
                                if not 0 / totalAllocPoint:
                                    _2123 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2123] = 26
                                    mem[_2123 + 32] = 'SafeMath: division by zero'
                                    if not poolInfo[idx].field_1024:
                                        _2191 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2191 + 68] = mem[idx + _2123 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2191 + 68] = mem[_2191 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2191 + -mem[64] + 100
                                    if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                    _2506 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2506] = 26
                                    mem[_2506 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2593 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2593 + 68] = mem[idx + _2506 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2593 + 68] = mem[_2593 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2593 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3173 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3173] = 26
                                        mem[_3173 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3308 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3308 + 68] = mem[idx + _3173 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3308 + 68] = mem[_3308 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3308 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3234 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3234] = 26
                                        mem[_3234 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3393 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3393 + 68] = mem[idx + _3234 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3393 + 68] = mem[_3393 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3393 + -mem[64] + 100
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _2154 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2154] = 26
                                    mem[_2154 + 32] = 'SafeMath: division by zero'
                                    if not poolInfo[idx].field_1024:
                                        _2236 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2236 + 68] = mem[idx + _2154 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2236 + 68] = mem[_2236 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2236 + -mem[64] + 100
                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                    _2546 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2546] = 26
                                    mem[_2546 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2644 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2644 + 68] = mem[idx + _2546 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2644 + 68] = mem[_2644 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2644 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3233 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3233] = 26
                                        mem[_3233 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3390 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3390 + 68] = mem[idx + _3233 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3390 + 68] = mem[_3390 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3390 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3307 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3307] = 26
                                        mem[_3307 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3469 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3469 + 68] = mem[idx + _3307 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3469 + 68] = mem[_3469 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3469 + -mem[64] + 100
                                ('stor', ('name', 'treasuryDivRate', 5))
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) / (10 * block.number) - (10 * poolInfo[idx].field_512) != mmPerBlock:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock):
                                    _1934 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1934] = 26
                                    mem[_1934 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _1963 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _1963 + 68] = mem[idx + _1934 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1963 + 68] = mem[_1963 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _1963 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2153 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2153] = 26
                                        mem[_2153 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2233 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2233 + 68] = mem[idx + _2153 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2233 + 68] = mem[_2233 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2233 + -mem[64] + 100
                                        if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                        _2545 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2545] = 26
                                        mem[_2545 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2641 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2641 + 68] = mem[idx + _2545 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2641 + 68] = mem[_2641 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2641 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3232 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3232] = 26
                                            mem[_3232 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3387 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3387 + 68] = mem[idx + _3232 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3387 + 68] = mem[_3387 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3387 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3306 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3306] = 26
                                            mem[_3306 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3466 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3466 + 68] = mem[idx + _3306 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3466 + 68] = mem[_3466 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3466 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2190 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2190] = 26
                                        mem[_2190 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2278 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2278 + 68] = mem[idx + _2190 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2278 + 68] = mem[_2278 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2278 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                        _2592 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2592] = 26
                                        mem[_2592 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2693 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2693 + 68] = mem[idx + _2592 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2693 + 68] = mem[_2693 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2693 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3305 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3305] = 26
                                            mem[_3305 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3463 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3463 + 68] = mem[idx + _3305 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3463 + 68] = mem[_3463 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3463 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3386 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3386] = 26
                                            mem[_3386 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3542 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3542 + 68] = mem[idx + _3386 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3542 + 68] = mem[_3542 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3542 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1946 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1946] = 26
                                    mem[_1946 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _1978 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _1978 + 68] = mem[idx + _1946 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1978 + 68] = mem[_1978 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _1978 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _2189 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2189] = 26
                                        mem[_2189 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2275 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2275 + 68] = mem[idx + _2189 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2275 + 68] = mem[_2275 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2275 + -mem[64] + 100
                                        if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                        _2591 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2591] = 26
                                        mem[_2591 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2690 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2690 + 68] = mem[idx + _2591 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2690 + 68] = mem[_2690 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2690 + -mem[64] + 100
                                        if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3304 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3304] = 26
                                            mem[_3304 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3460 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3460 + 68] = mem[idx + _3304 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3460 + 68] = mem[_3460 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3460 + -mem[64] + 100
                                        else:
                                            if devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3385 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3385] = 26
                                            mem[_3385 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3539 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3539 + 68] = mem[idx + _3385 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3539 + 68] = mem[_3539 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3539 + -mem[64] + 100
                                    else:
                                        if 10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2232 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2232] = 26
                                        mem[_2232 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2315 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2315 + 68] = mem[idx + _2232 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2315 + 68] = mem[_2315 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2315 + -mem[64] + 100
                                        if (10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024
                                        _2640 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2640] = 26
                                        mem[_2640 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2750 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2750 + 68] = mem[idx + _2640 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2750 + 68] = mem[_2750 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2750 + -mem[64] + 100
                                        if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3384 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3384] = 26
                                            mem[_3384 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3536 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3536 + 68] = mem[idx + _3384 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3536 + 68] = mem[_3536 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3536 + -mem[64] + 100
                                        else:
                                            if devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3459 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3459] = 26
                                            mem[_3459 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3630 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3630 + 68] = mem[idx + _3459 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3630 + 68] = mem[_3630 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3630 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                    else:
                        if poolInfo[idx].field_512 >= bonusEndBlock:
                            _1786 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1786] = 30
                            mem[_1786 + 32] = 'SafeMath: subtraction overflow'
                            if poolInfo[idx].field_512 > block.number:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _1786 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.number - poolInfo[idx].field_512:
                                _1896 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1896] = 26
                                mem[_1896 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _1905 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1905 + 68] = mem[idx + _1896 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1905 + 68] = mem[_1905 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _1905 + -mem[64] + 100
                                require idx < poolInfo.length
                                mem[0] = 10
                                if not 0 / totalAllocPoint:
                                    _2038 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2038] = 26
                                    mem[_2038 + 32] = 'SafeMath: division by zero'
                                    if not poolInfo[idx].field_1024:
                                        _2068 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2068 + 68] = mem[idx + _2038 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2068 + 68] = mem[_2068 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2068 + -mem[64] + 100
                                    if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                    _2353 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2353] = 26
                                    mem[_2353 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2428 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2428 + 68] = mem[idx + _2353 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2428 + 68] = mem[_2428 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2428 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _2931 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2931] = 26
                                        mem[_2931 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3039 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3039 + 68] = mem[idx + _2931 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3039 + 68] = mem[_3039 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3039 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _2984 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2984] = 26
                                        mem[_2984 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3100 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3100 + 68] = mem[idx + _2984 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3100 + 68] = mem[_3100 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3100 + -mem[64] + 100
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _2053 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2053] = 26
                                    mem[_2053 + 32] = 'SafeMath: division by zero'
                                    if not poolInfo[idx].field_1024:
                                        _2092 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2092 + 68] = mem[idx + _2053 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2092 + 68] = mem[_2092 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2092 + -mem[64] + 100
                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                    _2391 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2391] = 26
                                    mem[_2391 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2464 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2464 + 68] = mem[idx + _2391 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2464 + 68] = mem[_2464 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2464 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _2983 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2983] = 26
                                        mem[_2983 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3097 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3097 + 68] = mem[idx + _2983 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3097 + 68] = mem[_3097 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3097 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3038 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3038] = 26
                                        mem[_3038 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3161 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3161 + 68] = mem[idx + _3038 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3161 + 68] = mem[_3161 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3161 + -mem[64] + 100
                                ('stor', ('name', 'treasuryDivRate', 5))
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock) / block.number - poolInfo[idx].field_512 != mmPerBlock:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock):
                                    _1901 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1901] = 26
                                    mem[_1901 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _1913 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _1913 + 68] = mem[idx + _1901 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1913 + 68] = mem[_1913 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _1913 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2052 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2052] = 26
                                        mem[_2052 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2089 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2089 + 68] = mem[idx + _2052 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2089 + 68] = mem[_2089 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2089 + -mem[64] + 100
                                        if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                        _2390 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2390] = 26
                                        mem[_2390 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2461 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2461 + 68] = mem[idx + _2390 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2461 + 68] = mem[_2461 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2461 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2982 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2982] = 26
                                            mem[_2982 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3094 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3094 + 68] = mem[idx + _2982 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3094 + 68] = mem[_3094 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3094 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3037 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3037] = 26
                                            mem[_3037 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3158 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3158 + 68] = mem[idx + _3037 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3158 + 68] = mem[_3158 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3158 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2067 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2067] = 26
                                        mem[_2067 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2117 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2117 + 68] = mem[idx + _2067 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2117 + 68] = mem[_2117 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2117 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                        _2427 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2427] = 26
                                        mem[_2427 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2500 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2500 + 68] = mem[idx + _2427 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2500 + 68] = mem[_2500 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2500 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3036 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3036] = 26
                                            mem[_3036 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3155 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3155 + 68] = mem[idx + _3036 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3155 + 68] = mem[_3155 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3155 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3093 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3093] = 26
                                            mem[_3093 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3222 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3222 + 68] = mem[idx + _3093 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3222 + 68] = mem[_3222 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3222 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1904 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1904] = 26
                                    mem[_1904 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _1920 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _1920 + 68] = mem[idx + _1904 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1920 + 68] = mem[_1920 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _1920 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _2066 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2066] = 26
                                        mem[_2066 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2114 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2114 + 68] = mem[idx + _2066 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2114 + 68] = mem[_2114 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2114 + -mem[64] + 100
                                        if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                        _2426 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2426] = 26
                                        mem[_2426 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2497 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2497 + 68] = mem[idx + _2426 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2497 + 68] = mem[_2497 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2497 + -mem[64] + 100
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3035 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3035] = 26
                                            mem[_3035 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3152 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3152 + 68] = mem[idx + _3035 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3152 + 68] = mem[_3152 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3152 + -mem[64] + 100
                                        else:
                                            if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3092 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3092] = 26
                                            mem[_3092 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3219 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3219 + 68] = mem[idx + _3092 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3219 + 68] = mem[_3219 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3219 + -mem[64] + 100
                                    else:
                                        if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2088 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2088] = 26
                                        mem[_2088 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2144 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2144 + 68] = mem[idx + _2088 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2144 + 68] = mem[_2144 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2144 + -mem[64] + 100
                                        if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024
                                        _2460 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2460] = 26
                                        mem[_2460 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2538 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2538 + 68] = mem[idx + _2460 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2538 + 68] = mem[_2538 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2538 + -mem[64] + 100
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3091 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3091] = 26
                                            mem[_3091 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3216 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3216 + 68] = mem[idx + _3091 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3216 + 68] = mem[_3216 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3216 + -mem[64] + 100
                                        else:
                                            if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3151 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3151] = 26
                                            mem[_3151 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3290 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3290 + 68] = mem[idx + _3151 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3290 + 68] = mem[_3290 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3290 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                        else:
                            _1785 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1785] = 30
                            mem[_1785 + 32] = 'SafeMath: subtraction overflow'
                            if bonusEndBlock > block.number:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _1785 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            _1820 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1820] = 30
                            mem[_1820 + 32] = 'SafeMath: subtraction overflow'
                            if poolInfo[idx].field_512 > bonusEndBlock:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _1820 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not bonusEndBlock - poolInfo[idx].field_512:
                                if block.number - bonusEndBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not block.number - bonusEndBlock:
                                    _2035 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2035] = 26
                                    mem[_2035 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2063 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2063 + 68] = mem[idx + _2035 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2063 + 68] = mem[_2063 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2063 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2425 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2425] = 26
                                        mem[_2425 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2494 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2494 + 68] = mem[idx + _2425 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2494 + 68] = mem[_2494 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2494 + -mem[64] + 100
                                        if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                        _2922 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2922] = 26
                                        mem[_2922 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _3032 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3032 + 68] = mem[idx + _2922 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3032 + 68] = mem[_3032 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3032 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3807 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3807] = 26
                                            mem[_3807 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4026 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4026 + 68] = mem[idx + _3807 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4026 + 68] = mem[_4026 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4026 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3912 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3912] = 26
                                            mem[_3912 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4150 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4150 + 68] = mem[idx + _3912 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4150 + 68] = mem[_4150 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4150 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2459 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2459] = 26
                                        mem[_2459 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2535 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2535 + 68] = mem[idx + _2459 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2535 + 68] = mem[_2535 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2535 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                        _2979 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2979] = 26
                                        mem[_2979 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _3088 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3088 + 68] = mem[idx + _2979 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3088 + 68] = mem[_3088 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3088 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3911 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3911] = 26
                                            mem[_3911 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4147 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4147 + 68] = mem[idx + _3911 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4147 + 68] = mem[_4147 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4147 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4025 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4025] = 26
                                            mem[_4025 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4272 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4272 + 68] = mem[idx + _4025 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4272 + 68] = mem[_4272 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4272 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) / block.number - bonusEndBlock != mmPerBlock:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock):
                                        _2049 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2049] = 26
                                        mem[_2049 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2085 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2085 + 68] = mem[idx + _2049 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2085 + 68] = mem[_2085 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2085 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2458 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2458] = 26
                                            mem[_2458 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2532 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2532 + 68] = mem[idx + _2458 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2532 + 68] = mem[_2532 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2532 + -mem[64] + 100
                                            if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                            _2978 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2978] = 26
                                            mem[_2978 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3085 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3085 + 68] = mem[idx + _2978 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3085 + 68] = mem[_3085 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3085 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3910 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3910] = 26
                                                mem[_3910 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4144 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4144 + 68] = mem[idx + _3910 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4144 + 68] = mem[_4144 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4144 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4024 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4024] = 26
                                                mem[_4024 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4269 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4269 + 68] = mem[idx + _4024 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4269 + 68] = mem[_4269 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4269 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2493 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2493] = 26
                                            mem[_2493 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2580 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2580 + 68] = mem[idx + _2493 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2580 + 68] = mem[_2580 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2580 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                            _3031 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3031] = 26
                                            mem[_3031 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3147 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3147 + 68] = mem[idx + _3031 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3147 + 68] = mem[_3147 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3147 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4023 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4023] = 26
                                                mem[_4023 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4266 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4266 + 68] = mem[idx + _4023 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4266 + 68] = mem[_4266 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4266 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4143 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4143] = 26
                                                mem[_4143 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4385 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4385 + 68] = mem[idx + _4143 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4385 + 68] = mem[_4385 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4385 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2062 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2062] = 26
                                        mem[_2062 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2110 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2110 + 68] = mem[idx + _2062 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2110 + 68] = mem[_2110 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2110 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _2492 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2492] = 26
                                            mem[_2492 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2577 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2577 + 68] = mem[idx + _2492 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2577 + 68] = mem[_2577 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2577 + -mem[64] + 100
                                            if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                            _3030 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3030] = 26
                                            mem[_3030 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3144 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3144 + 68] = mem[idx + _3030 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3144 + 68] = mem[_3144 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3144 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4022 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4022] = 26
                                                mem[_4022 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4263 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4263 + 68] = mem[idx + _4022 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4263 + 68] = mem[_4263 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4263 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4142 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4142] = 26
                                                mem[_4142 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4382 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4382 + 68] = mem[idx + _4142 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4382 + 68] = mem[_4382 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4382 + -mem[64] + 100
                                        else:
                                            if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2531 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2531] = 26
                                            mem[_2531 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2626 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2626 + 68] = mem[idx + _2531 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2626 + 68] = mem[_2626 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2626 + -mem[64] + 100
                                            if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024
                                            _3084 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3084] = 26
                                            mem[_3084 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3209 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3209 + 68] = mem[idx + _3084 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3209 + 68] = mem[_3209 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3209 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4141 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4141] = 26
                                                mem[_4141 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4379 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4379 + 68] = mem[idx + _4141 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4379 + 68] = mem[_4379 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4379 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4262 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4262] = 26
                                                mem[_4262 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4492 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4492 + 68] = mem[idx + _4262 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4492 + 68] = mem[_4492 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4492 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                            else:
                                if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if block.number + (9 * bonusEndBlock) < 10 * bonusEndBlock:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not block.number + (9 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                                    _2048 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2048] = 26
                                    mem[_2048 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2082 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2082 + 68] = mem[idx + _2048 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2082 + 68] = mem[_2082 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2082 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2455 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2455] = 26
                                        mem[_2455 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2528 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2528 + 68] = mem[idx + _2455 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2528 + 68] = mem[_2528 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2528 + -mem[64] + 100
                                        if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                        _2977 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2977] = 26
                                        mem[_2977 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _3081 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3081 + 68] = mem[idx + _2977 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3081 + 68] = mem[_3081 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3081 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3907 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3907] = 26
                                            mem[_3907 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4138 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4138 + 68] = mem[idx + _3907 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4138 + 68] = mem[_4138 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4138 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4021 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4021] = 26
                                            mem[_4021 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4259 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4259 + 68] = mem[idx + _4021 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4259 + 68] = mem[_4259 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4259 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2491 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2491] = 26
                                        mem[_2491 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2574 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2574 + 68] = mem[idx + _2491 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2574 + 68] = mem[_2574 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2574 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                        _3029 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3029] = 26
                                        mem[_3029 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _3141 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3141 + 68] = mem[idx + _3029 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3141 + 68] = mem[_3141 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3141 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4020 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4020] = 26
                                            mem[_4020 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4256 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4256 + 68] = mem[idx + _4020 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4256 + 68] = mem[_4256 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4256 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4137 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4137] = 26
                                            mem[_4137 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4375 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4375 + 68] = mem[idx + _4137 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4375 + 68] = mem[_4375 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4375 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) / block.number + (9 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != mmPerBlock:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock):
                                        _2061 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2061] = 26
                                        mem[_2061 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2107 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2107 + 68] = mem[idx + _2061 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2107 + 68] = mem[_2107 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2107 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2490 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2490] = 26
                                            mem[_2490 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2571 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2571 + 68] = mem[idx + _2490 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2571 + 68] = mem[_2571 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2571 + -mem[64] + 100
                                            if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                            _3028 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3028] = 26
                                            mem[_3028 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3138 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3138 + 68] = mem[idx + _3028 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3138 + 68] = mem[_3138 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3138 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4019 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4019] = 26
                                                mem[_4019 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4253 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4253 + 68] = mem[idx + _4019 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4253 + 68] = mem[_4253 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4253 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4136 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4136] = 26
                                                mem[_4136 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4372 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4372 + 68] = mem[idx + _4136 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4372 + 68] = mem[_4372 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4372 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2527 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2527] = 26
                                            mem[_2527 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2622 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2622 + 68] = mem[idx + _2527 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2622 + 68] = mem[_2622 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2622 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                            _3080 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3080] = 26
                                            mem[_3080 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3205 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3205 + 68] = mem[idx + _3080 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3205 + 68] = mem[_3205 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3205 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4135 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4135] = 26
                                                mem[_4135 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4369 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4369 + 68] = mem[idx + _4135 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4369 + 68] = mem[_4369 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4369 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4252 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4252] = 26
                                                mem[_4252 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4484 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4484 + 68] = mem[idx + _4252 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4484 + 68] = mem[_4484 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4484 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2081 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2081] = 26
                                        mem[_2081 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2137 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2137 + 68] = mem[idx + _2081 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2137 + 68] = mem[_2137 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2137 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _2526 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2526] = 26
                                            mem[_2526 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2619 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2619 + 68] = mem[idx + _2526 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2619 + 68] = mem[_2619 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2619 + -mem[64] + 100
                                            if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                            _3079 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3079] = 26
                                            mem[_3079 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3202 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3202 + 68] = mem[idx + _3079 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3202 + 68] = mem[_3202 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3202 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4134 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4134] = 26
                                                mem[_4134 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4366 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4366 + 68] = mem[idx + _4134 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4366 + 68] = mem[_4366 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4366 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4251 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4251] = 26
                                                mem[_4251 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4481 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4481 + 68] = mem[idx + _4251 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4481 + 68] = mem[_4481 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4481 + -mem[64] + 100
                                        else:
                                            if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2570 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2570] = 26
                                            mem[_2570 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2672 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2672 + 68] = mem[idx + _2570 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2672 + 68] = mem[_2672 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2672 + -mem[64] + 100
                                            if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024
                                            _3137 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3137] = 26
                                            mem[_3137 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3276 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3276 + 68] = mem[idx + _3137 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3276 + 68] = mem[_3276 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3276 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4250 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4250] = 26
                                                mem[_4250 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4478 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4478 + 68] = mem[idx + _4250 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4478 + 68] = mem[_4478 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4478 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4365 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4365] = 26
                                                mem[_4365 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4584 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4584 + 68] = mem[idx + _4365 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4584 + 68] = mem[_4584 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4584 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
            else:
                mem[mem[64] + 4] = this.address
                require ext_code.size(poolInfo[idx].field_0)
                staticcall poolInfo[idx].field_0.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0]:
                    if block.number <= bonusEndBlock:
                        _1790 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1790] = 30
                        mem[_1790 + 32] = 'SafeMath: subtraction overflow'
                        if poolInfo[idx].field_512 > block.number:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _1790 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[idx].field_512:
                            _1941 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1941] = 26
                            mem[_1941 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _1971 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1971 + 68] = mem[idx + _1941 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1971 + 68] = mem[_1971 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _1971 + -mem[64] + 100
                            require idx < poolInfo.length
                            mem[0] = 10
                            if not 0 / totalAllocPoint:
                                _2174 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2174] = 26
                                mem[_2174 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    _2258 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2258 + 68] = mem[idx + _2174 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2258 + 68] = mem[_2258 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _2258 + -mem[64] + 100
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                _2569 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2569] = 26
                                mem[_2569 + 32] = 'SafeMath: division by zero'
                                if not devFundDivRate:
                                    _2669 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2669 + 68] = mem[idx + _2569 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2669 + 68] = mem[_2669 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _2669 + -mem[64] + 100
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3275 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3275] = 26
                                    mem[_3275 + 32] = 'SafeMath: division by zero'
                                    if not treasuryDivRate:
                                        _3434 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3434 + 68] = mem[idx + _3275 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3434 + 68] = mem[_3434 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _3434 + -mem[64] + 100
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3355 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3355] = 26
                                    mem[_3355 + 32] = 'SafeMath: division by zero'
                                    if not treasuryDivRate:
                                        _3515 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3515 + 68] = mem[idx + _3355 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3515 + 68] = mem[_3515 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _3515 + -mem[64] + 100
                            else:
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _2214 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2214] = 26
                                mem[_2214 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    _2304 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2304 + 68] = mem[idx + _2214 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2304 + 68] = mem[_2304 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _2304 + -mem[64] + 100
                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                _2618 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2618] = 26
                                mem[_2618 + 32] = 'SafeMath: division by zero'
                                if not devFundDivRate:
                                    _2726 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2726 + 68] = mem[idx + _2618 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2726 + 68] = mem[_2726 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _2726 + -mem[64] + 100
                                if not 0 / totalAllocPoint / devFundDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3354 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3354] = 26
                                    mem[_3354 + 32] = 'SafeMath: division by zero'
                                    if not treasuryDivRate:
                                        _3512 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3512 + 68] = mem[idx + _3354 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3512 + 68] = mem[_3512 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _3512 + -mem[64] + 100
                                else:
                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3433 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3433] = 26
                                    mem[_3433 + 32] = 'SafeMath: division by zero'
                                    if not treasuryDivRate:
                                        _3596 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _3596 + 68] = mem[idx + _3433 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3596 + 68] = mem[_3596 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _3596 + -mem[64] + 100
                            ('stor', ('name', 'treasuryDivRate', 5))
                            if not 0 / totalAllocPoint / treasuryDivRate:
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(mmAddress)
                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                        else:
                            if (10 * block.number) - (10 * poolInfo[idx].field_512) / block.number - poolInfo[idx].field_512 != 10:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (10 * block.number) - (10 * poolInfo[idx].field_512):
                                _1956 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1956] = 26
                                mem[_1956 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _1989 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1989 + 68] = mem[idx + _1956 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1989 + 68] = mem[_1989 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _1989 + -mem[64] + 100
                                require idx < poolInfo.length
                                mem[0] = 10
                                if not 0 / totalAllocPoint:
                                    _2213 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2213] = 26
                                    mem[_2213 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        _2301 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2301 + 68] = mem[idx + _2213 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2301 + 68] = mem[_2301 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2301 + -mem[64] + 100
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    _2617 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2617] = 26
                                    mem[_2617 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2723 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2723 + 68] = mem[idx + _2617 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2723 + 68] = mem[_2723 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2723 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3353 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3353] = 26
                                        mem[_3353 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3509 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3509 + 68] = mem[idx + _3353 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3509 + 68] = mem[_3509 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3509 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3432 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3432] = 26
                                        mem[_3432 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3593 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3593 + 68] = mem[idx + _3432 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3593 + 68] = mem[_3593 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3593 + -mem[64] + 100
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _2257 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2257] = 26
                                    mem[_2257 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        _2346 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2346 + 68] = mem[idx + _2257 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2346 + 68] = mem[_2346 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2346 + -mem[64] + 100
                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    _2668 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2668] = 26
                                    mem[_2668 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2785 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2785 + 68] = mem[idx + _2668 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2785 + 68] = mem[_2785 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2785 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3431 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3431] = 26
                                        mem[_3431 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3590 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3590 + 68] = mem[idx + _3431 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3590 + 68] = mem[_3590 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3590 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3508 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3508] = 26
                                        mem[_3508 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3680 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3680 + 68] = mem[idx + _3508 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3680 + 68] = mem[_3680 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3680 + -mem[64] + 100
                                ('stor', ('name', 'treasuryDivRate', 5))
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) / (10 * block.number) - (10 * poolInfo[idx].field_512) != mmPerBlock:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock):
                                    _1970 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1970] = 26
                                    mem[_1970 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2003 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2003 + 68] = mem[idx + _1970 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2003 + 68] = mem[_2003 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2003 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2256 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2256] = 26
                                        mem[_2256 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2343 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2343 + 68] = mem[idx + _2256 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2343 + 68] = mem[_2343 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2343 + -mem[64] + 100
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        _2667 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2667] = 26
                                        mem[_2667 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2782 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2782 + 68] = mem[idx + _2667 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2782 + 68] = mem[_2782 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2782 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3430 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3430] = 26
                                            mem[_3430 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3587 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3587 + 68] = mem[idx + _3430 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3587 + 68] = mem[_3587 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3587 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3507 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3507] = 26
                                            mem[_3507 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3677 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3677 + 68] = mem[idx + _3507 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3677 + 68] = mem[_3677 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3677 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2300 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2300] = 26
                                        mem[_2300 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2381 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2381 + 68] = mem[idx + _2300 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2381 + 68] = mem[_2381 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2381 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        _2722 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2722] = 26
                                        mem[_2722 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2845 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2845 + 68] = mem[idx + _2722 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2845 + 68] = mem[_2845 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2845 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3506 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3506] = 26
                                            mem[_3506 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3674 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3674 + 68] = mem[idx + _3506 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3674 + 68] = mem[_3674 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3674 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3586 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3586] = 26
                                            mem[_3586 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3773 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3773 + 68] = mem[idx + _3586 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3773 + 68] = mem[_3773 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3773 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1988 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1988] = 26
                                    mem[_1988 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2016 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2016 + 68] = mem[idx + _1988 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2016 + 68] = mem[_2016 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2016 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _2299 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2299] = 26
                                        mem[_2299 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2378 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2378 + 68] = mem[idx + _2299 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2378 + 68] = mem[_2378 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2378 + -mem[64] + 100
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        _2721 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2721] = 26
                                        mem[_2721 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2842 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2842 + 68] = mem[idx + _2721 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2842 + 68] = mem[_2842 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2842 + -mem[64] + 100
                                        if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3505 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3505] = 26
                                            mem[_3505 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3671 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3671 + 68] = mem[idx + _3505 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3671 + 68] = mem[_3671 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3671 + -mem[64] + 100
                                        else:
                                            if devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3585 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3585] = 26
                                            mem[_3585 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3770 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3770 + 68] = mem[idx + _3585 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3770 + 68] = mem[_3770 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3770 + -mem[64] + 100
                                    else:
                                        if 10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2342 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2342] = 26
                                        mem[_2342 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2411 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2411 + 68] = mem[idx + _2342 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2411 + 68] = mem[_2411 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2411 + -mem[64] + 100
                                        if (10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        _2781 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2781] = 26
                                        mem[_2781 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2905 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2905 + 68] = mem[idx + _2781 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2905 + 68] = mem[_2905 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2905 + -mem[64] + 100
                                        if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3584 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3584] = 26
                                            mem[_3584 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3767 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3767 + 68] = mem[idx + _3584 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3767 + 68] = mem[_3767 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3767 + -mem[64] + 100
                                        else:
                                            if devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3670 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3670] = 26
                                            mem[_3670 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3881 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3881 + 68] = mem[idx + _3670 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3881 + 68] = mem[_3881 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3881 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                    else:
                        if poolInfo[idx].field_512 >= bonusEndBlock:
                            _1799 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1799] = 30
                            mem[_1799 + 32] = 'SafeMath: subtraction overflow'
                            if poolInfo[idx].field_512 > block.number:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _1799 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.number - poolInfo[idx].field_512:
                                _1912 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1912] = 26
                                mem[_1912 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _1928 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1928 + 68] = mem[idx + _1912 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1928 + 68] = mem[_1928 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _1928 + -mem[64] + 100
                                require idx < poolInfo.length
                                mem[0] = 10
                                if not 0 / totalAllocPoint:
                                    _2078 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2078] = 26
                                    mem[_2078 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        _2132 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2132 + 68] = mem[idx + _2078 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2132 + 68] = mem[_2132 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2132 + -mem[64] + 100
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    _2442 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2442] = 26
                                    mem[_2442 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2515 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2515 + 68] = mem[idx + _2442 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2515 + 68] = mem[_2515 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2515 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3070 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3070] = 26
                                        mem[_3070 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3187 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3187 + 68] = mem[idx + _3070 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3187 + 68] = mem[_3187 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3187 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3125 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3125] = 26
                                        mem[_3125 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3260 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3260 + 68] = mem[idx + _3125 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3260 + 68] = mem[_3260 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3260 + -mem[64] + 100
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _2105 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2105] = 26
                                    mem[_2105 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        _2169 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2169 + 68] = mem[idx + _2105 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2169 + 68] = mem[_2169 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2169 + -mem[64] + 100
                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    _2476 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2476] = 26
                                    mem[_2476 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2561 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2561 + 68] = mem[idx + _2476 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2561 + 68] = mem[_2561 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2561 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3124 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3124] = 26
                                        mem[_3124 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3257 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3257 + 68] = mem[idx + _3124 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3257 + 68] = mem[_3257 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3257 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3186 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3186] = 26
                                        mem[_3186 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3341 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3341 + 68] = mem[idx + _3186 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3341 + 68] = mem[_3341 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3341 + -mem[64] + 100
                                ('stor', ('name', 'treasuryDivRate', 5))
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock) / block.number - poolInfo[idx].field_512 != mmPerBlock:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock):
                                    _1919 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1919] = 26
                                    mem[_1919 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _1938 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _1938 + 68] = mem[idx + _1919 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1938 + 68] = mem[_1938 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _1938 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2104 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2104] = 26
                                        mem[_2104 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2166 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2166 + 68] = mem[idx + _2104 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2166 + 68] = mem[_2166 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2166 + -mem[64] + 100
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        _2475 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2475] = 26
                                        mem[_2475 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2558 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2558 + 68] = mem[idx + _2475 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2558 + 68] = mem[_2558 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2558 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3123 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3123] = 26
                                            mem[_3123 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3254 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3254 + 68] = mem[idx + _3123 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3254 + 68] = mem[_3254 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3254 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3185 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3185] = 26
                                            mem[_3185 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3338 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3338 + 68] = mem[idx + _3185 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3338 + 68] = mem[_3338 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3338 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2131 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2131] = 26
                                        mem[_2131 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2207 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2207 + 68] = mem[idx + _2131 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2207 + 68] = mem[_2207 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2207 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        _2514 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2514] = 26
                                        mem[_2514 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2611 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2611 + 68] = mem[idx + _2514 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2611 + 68] = mem[_2611 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2611 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3184 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3184] = 26
                                            mem[_3184 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3335 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3335 + 68] = mem[idx + _3184 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3335 + 68] = mem[_3335 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3335 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3253 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3253] = 26
                                            mem[_3253 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3420 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3420 + 68] = mem[idx + _3253 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3420 + 68] = mem[_3420 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3420 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1927 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1927] = 26
                                    mem[_1927 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _1950 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _1950 + 68] = mem[idx + _1927 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1950 + 68] = mem[_1950 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _1950 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _2130 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2130] = 26
                                        mem[_2130 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2204 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2204 + 68] = mem[idx + _2130 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2204 + 68] = mem[_2204 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2204 + -mem[64] + 100
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        _2513 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2513] = 26
                                        mem[_2513 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2608 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2608 + 68] = mem[idx + _2513 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2608 + 68] = mem[_2608 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2608 + -mem[64] + 100
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3183 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3183] = 26
                                            mem[_3183 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3332 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3332 + 68] = mem[idx + _3183 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3332 + 68] = mem[_3332 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3332 + -mem[64] + 100
                                        else:
                                            if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3252 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3252] = 26
                                            mem[_3252 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3417 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3417 + 68] = mem[idx + _3252 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3417 + 68] = mem[_3417 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3417 + -mem[64] + 100
                                    else:
                                        if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2165 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2165] = 26
                                        mem[_2165 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2247 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2247 + 68] = mem[idx + _2165 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2247 + 68] = mem[_2247 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2247 + -mem[64] + 100
                                        if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        _2557 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2557] = 26
                                        mem[_2557 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2660 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2660 + 68] = mem[idx + _2557 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2660 + 68] = mem[_2660 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2660 + -mem[64] + 100
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3251 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3251] = 26
                                            mem[_3251 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3414 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3414 + 68] = mem[idx + _3251 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3414 + 68] = mem[_3414 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3414 + -mem[64] + 100
                                        else:
                                            if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3331 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3331] = 26
                                            mem[_3331 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3491 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3491 + 68] = mem[idx + _3331 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3491 + 68] = mem[_3491 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3491 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                        else:
                            _1798 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1798] = 30
                            mem[_1798 + 32] = 'SafeMath: subtraction overflow'
                            if bonusEndBlock > block.number:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _1798 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            _1849 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1849] = 30
                            mem[_1849 + 32] = 'SafeMath: subtraction overflow'
                            if poolInfo[idx].field_512 > bonusEndBlock:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _1849 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not bonusEndBlock - poolInfo[idx].field_512:
                                if block.number - bonusEndBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not block.number - bonusEndBlock:
                                    _2075 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2075] = 26
                                    mem[_2075 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2127 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2127 + 68] = mem[idx + _2075 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2127 + 68] = mem[_2127 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2127 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2512 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2512] = 26
                                        mem[_2512 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2605 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2605 + 68] = mem[idx + _2512 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2605 + 68] = mem[_2605 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2605 + -mem[64] + 100
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        _3061 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3061] = 26
                                        mem[_3061 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _3180 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3180 + 68] = mem[idx + _3061 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3180 + 68] = mem[_3180 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3180 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4090 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4090] = 26
                                            mem[_4090 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4321 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4321 + 68] = mem[idx + _4090 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4321 + 68] = mem[_4321 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4321 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4206 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4206] = 26
                                            mem[_4206 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4435 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4435 + 68] = mem[idx + _4206 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4435 + 68] = mem[_4435 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4435 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2556 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2556] = 26
                                        mem[_2556 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2657 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2657 + 68] = mem[idx + _2556 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2657 + 68] = mem[_2657 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2657 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        _3120 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3120] = 26
                                        mem[_3120 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _3248 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3248 + 68] = mem[idx + _3120 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3248 + 68] = mem[_3248 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3248 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4205 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4205] = 26
                                            mem[_4205 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4432 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4432 + 68] = mem[idx + _4205 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4432 + 68] = mem[_4432 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4432 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4320 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4320] = 26
                                            mem[_4320 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4544 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4544 + 68] = mem[idx + _4320 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4544 + 68] = mem[_4544 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4544 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) / block.number - bonusEndBlock != mmPerBlock:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock):
                                        _2101 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2101] = 26
                                        mem[_2101 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2162 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2162 + 68] = mem[idx + _2101 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2162 + 68] = mem[_2162 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2162 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2555 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2555] = 26
                                            mem[_2555 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2654 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2654 + 68] = mem[idx + _2555 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2654 + 68] = mem[_2654 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2654 + -mem[64] + 100
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            _3119 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3119] = 26
                                            mem[_3119 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3245 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3245 + 68] = mem[idx + _3119 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3245 + 68] = mem[_3245 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3245 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4204 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4204] = 26
                                                mem[_4204 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4429 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4429 + 68] = mem[idx + _4204 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4429 + 68] = mem[_4429 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4429 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4319 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4319] = 26
                                                mem[_4319 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4541 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4541 + 68] = mem[idx + _4319 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4541 + 68] = mem[_4541 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4541 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2604 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2604] = 26
                                            mem[_2604 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2710 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2710 + 68] = mem[idx + _2604 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2710 + 68] = mem[_2710 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2710 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            _3179 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3179] = 26
                                            mem[_3179 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3327 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3327 + 68] = mem[idx + _3179 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3327 + 68] = mem[_3327 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3327 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4318 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4318] = 26
                                                mem[_4318 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4538 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4538 + 68] = mem[idx + _4318 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4538 + 68] = mem[_4538 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4538 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4428 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4428] = 26
                                                mem[_4428 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4640 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4640 + 68] = mem[idx + _4428 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4640 + 68] = mem[_4640 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4640 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2126 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2126] = 26
                                        mem[_2126 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2200 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2200 + 68] = mem[idx + _2126 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2200 + 68] = mem[_2200 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2200 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _2603 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2603] = 26
                                            mem[_2603 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2707 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2707 + 68] = mem[idx + _2603 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2707 + 68] = mem[_2707 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2707 + -mem[64] + 100
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            _3178 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3178] = 26
                                            mem[_3178 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3324 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3324 + 68] = mem[idx + _3178 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3324 + 68] = mem[_3324 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3324 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4317 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4317] = 26
                                                mem[_4317 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4535 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4535 + 68] = mem[idx + _4317 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4535 + 68] = mem[_4535 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4535 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4427 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4427] = 26
                                                mem[_4427 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4637 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4637 + 68] = mem[idx + _4427 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4637 + 68] = mem[_4637 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4637 + -mem[64] + 100
                                        else:
                                            if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2653 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2653] = 26
                                            mem[_2653 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2767 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2767 + 68] = mem[idx + _2653 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2767 + 68] = mem[_2767 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2767 + -mem[64] + 100
                                            if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            _3244 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3244] = 26
                                            mem[_3244 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3407 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3407 + 68] = mem[idx + _3244 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3407 + 68] = mem[_3407 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3407 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4426 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4426] = 26
                                                mem[_4426 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4634 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4634 + 68] = mem[idx + _4426 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4634 + 68] = mem[_4634 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4634 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4534 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4534] = 26
                                                mem[_4534 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4715 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4715 + 68] = mem[idx + _4534 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4715 + 68] = mem[_4715 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4715 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                            else:
                                if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if block.number + (9 * bonusEndBlock) < 10 * bonusEndBlock:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not block.number + (9 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                                    _2100 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2100] = 26
                                    mem[_2100 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2159 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2159 + 68] = mem[idx + _2100 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2159 + 68] = mem[_2159 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2159 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2552 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2552] = 26
                                        mem[_2552 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2650 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2650 + 68] = mem[idx + _2552 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2650 + 68] = mem[_2650 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2650 + -mem[64] + 100
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        _3118 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3118] = 26
                                        mem[_3118 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _3241 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3241 + 68] = mem[idx + _3118 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3241 + 68] = mem[_3241 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3241 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4201 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4201] = 26
                                            mem[_4201 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4423 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4423 + 68] = mem[idx + _4201 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4423 + 68] = mem[_4423 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4423 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4316 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4316] = 26
                                            mem[_4316 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4531 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4531 + 68] = mem[idx + _4316 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4531 + 68] = mem[_4531 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4531 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2602 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2602] = 26
                                        mem[_2602 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2704 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2704 + 68] = mem[idx + _2602 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2704 + 68] = mem[_2704 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2704 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        _3177 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3177] = 26
                                        mem[_3177 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _3321 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3321 + 68] = mem[idx + _3177 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3321 + 68] = mem[_3321 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3321 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4315 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4315] = 26
                                            mem[_4315 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4528 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4528 + 68] = mem[idx + _4315 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4528 + 68] = mem[_4528 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4528 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4422 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_4422] = 26
                                            mem[_4422 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _4630 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _4630 + 68] = mem[idx + _4422 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_4630 + 68] = mem[_4630 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _4630 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) / block.number + (9 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != mmPerBlock:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock):
                                        _2125 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2125] = 26
                                        mem[_2125 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2197 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2197 + 68] = mem[idx + _2125 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2197 + 68] = mem[_2197 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2197 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2601 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2601] = 26
                                            mem[_2601 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2701 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2701 + 68] = mem[idx + _2601 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2701 + 68] = mem[_2701 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2701 + -mem[64] + 100
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            _3176 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3176] = 26
                                            mem[_3176 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3318 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3318 + 68] = mem[idx + _3176 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3318 + 68] = mem[_3318 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3318 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4314 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4314] = 26
                                                mem[_4314 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4525 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4525 + 68] = mem[idx + _4314 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4525 + 68] = mem[_4525 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4525 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4421 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4421] = 26
                                                mem[_4421 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4627 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4627 + 68] = mem[idx + _4421 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4627 + 68] = mem[_4627 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4627 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2649 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2649] = 26
                                            mem[_2649 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2763 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2763 + 68] = mem[idx + _2649 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2763 + 68] = mem[_2763 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2763 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            _3240 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3240] = 26
                                            mem[_3240 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3403 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3403 + 68] = mem[idx + _3240 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3403 + 68] = mem[_3403 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3403 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4420 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4420] = 26
                                                mem[_4420 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4624 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4624 + 68] = mem[idx + _4420 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4624 + 68] = mem[_4624 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4624 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4524 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4524] = 26
                                                mem[_4524 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4707 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4707 + 68] = mem[idx + _4524 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4707 + 68] = mem[_4707 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4707 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2158 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2158] = 26
                                        mem[_2158 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2240 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2240 + 68] = mem[idx + _2158 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2240 + 68] = mem[_2240 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2240 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _2648 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2648] = 26
                                            mem[_2648 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2760 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2760 + 68] = mem[idx + _2648 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2760 + 68] = mem[_2760 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2760 + -mem[64] + 100
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            _3239 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3239] = 26
                                            mem[_3239 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3400 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3400 + 68] = mem[idx + _3239 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3400 + 68] = mem[_3400 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3400 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4419 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4419] = 26
                                                mem[_4419 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4621 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4621 + 68] = mem[idx + _4419 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4621 + 68] = mem[_4621 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4621 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4523 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4523] = 26
                                                mem[_4523 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4704 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4704 + 68] = mem[idx + _4523 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4704 + 68] = mem[_4704 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4704 + -mem[64] + 100
                                        else:
                                            if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2700 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2700] = 26
                                            mem[_2700 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2824 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2824 + 68] = mem[idx + _2700 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2824 + 68] = mem[_2824 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2824 + -mem[64] + 100
                                            if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            _3317 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3317] = 26
                                            mem[_3317 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3477 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3477 + 68] = mem[idx + _3317 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3477 + 68] = mem[_3477 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3477 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4522 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4522] = 26
                                                mem[_4522 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4701 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4701 + 68] = mem[idx + _4522 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4701 + 68] = mem[_4701 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4701 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4620 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4620] = 26
                                                mem[_4620 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4765 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4765 + 68] = mem[idx + _4620 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4765 + 68] = mem[_4765 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4765 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
            poolInfo[idx].field_512 = block.number
        idx = idx + 1
        continue 
}

function set(uint256 arg1, uint256 arg2, bool arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 10
            if block.number > poolInfo[idx].field_512:
                require idx < poolInfo.length
                mem[0] = 10
                if not idx:
                    if poolInfo[idx].field_1024:
                        if block.number <= bonusEndBlock:
                            _1840 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1840] = 30
                            mem[_1840 + 32] = 'SafeMath: subtraction overflow'
                            if poolInfo[idx].field_512 > block.number:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _1840 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.number - poolInfo[idx].field_512:
                                _1972 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1972] = 26
                                mem[_1972 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _1991 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1991 + 68] = mem[idx + _1972 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1991 + 68] = mem[_1991 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _1991 + -mem[64] + 100
                                require idx < poolInfo.length
                                mem[0] = 10
                                if not 0 / totalAllocPoint:
                                    _2153 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2153] = 26
                                    mem[_2153 + 32] = 'SafeMath: division by zero'
                                    if not poolInfo[idx].field_1024:
                                        _2211 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2211 + 68] = mem[idx + _2153 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2211 + 68] = mem[_2211 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2211 + -mem[64] + 100
                                    if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                    _2528 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2528] = 26
                                    mem[_2528 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2603 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2603 + 68] = mem[idx + _2528 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2603 + 68] = mem[_2603 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2603 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3171 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3171] = 26
                                        mem[_3171 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3292 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3292 + 68] = mem[idx + _3171 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3292 + 68] = mem[_3292 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3292 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3231 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3231] = 26
                                        mem[_3231 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3370 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3370 + 68] = mem[idx + _3231 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3370 + 68] = mem[_3370 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3370 + -mem[64] + 100
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _2180 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2180] = 26
                                    mem[_2180 + 32] = 'SafeMath: division by zero'
                                    if not poolInfo[idx].field_1024:
                                        _2250 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2250 + 68] = mem[idx + _2180 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2250 + 68] = mem[_2250 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2250 + -mem[64] + 100
                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                    _2563 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2563] = 26
                                    mem[_2563 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2652 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2652 + 68] = mem[idx + _2563 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2652 + 68] = mem[_2652 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2652 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3230 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3230] = 26
                                        mem[_3230 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3367 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3367 + 68] = mem[idx + _3230 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3367 + 68] = mem[_3367 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3367 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3291 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3291] = 26
                                        mem[_3291 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3452 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3452 + 68] = mem[idx + _3291 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3452 + 68] = mem[_3452 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3452 + -mem[64] + 100
                                ('stor', ('name', 'treasuryDivRate', 5))
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (10 * block.number) - (10 * poolInfo[idx].field_512) / block.number - poolInfo[idx].field_512 != 10:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not (10 * block.number) - (10 * poolInfo[idx].field_512):
                                    _1982 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1982] = 26
                                    mem[_1982 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2003 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2003 + 68] = mem[idx + _1982 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2003 + 68] = mem[_2003 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2003 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2179 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2179] = 26
                                        mem[_2179 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2247 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2247 + 68] = mem[idx + _2179 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2247 + 68] = mem[_2247 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2247 + -mem[64] + 100
                                        if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                        _2562 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2562] = 26
                                        mem[_2562 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2649 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2649 + 68] = mem[idx + _2562 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2649 + 68] = mem[_2649 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2649 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3229 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3229] = 26
                                            mem[_3229 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3364 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3364 + 68] = mem[idx + _3229 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3364 + 68] = mem[_3364 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3364 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3290 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3290] = 26
                                            mem[_3290 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3449 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3449 + 68] = mem[idx + _3290 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3449 + 68] = mem[_3449 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3449 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2210 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2210] = 26
                                        mem[_2210 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2292 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2292 + 68] = mem[idx + _2210 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2292 + 68] = mem[_2292 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2292 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                        _2602 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2602] = 26
                                        mem[_2602 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2700 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2700 + 68] = mem[idx + _2602 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2700 + 68] = mem[_2700 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2700 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3289 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3289] = 26
                                            mem[_3289 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3446 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3446 + 68] = mem[idx + _3289 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3446 + 68] = mem[_3446 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3446 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3363 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3363] = 26
                                            mem[_3363 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3525 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3525 + 68] = mem[idx + _3363 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3525 + 68] = mem[_3525 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3525 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) / (10 * block.number) - (10 * poolInfo[idx].field_512) != mmPerBlock:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock):
                                        _1990 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1990] = 26
                                        mem[_1990 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2019 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2019 + 68] = mem[idx + _1990 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2019 + 68] = mem[_2019 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2019 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2209 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2209] = 26
                                            mem[_2209 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2289 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2289 + 68] = mem[idx + _2209 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2289 + 68] = mem[_2289 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2289 + -mem[64] + 100
                                            if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                            _2601 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2601] = 26
                                            mem[_2601 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2697 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2697 + 68] = mem[idx + _2601 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2697 + 68] = mem[_2697 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2697 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3288 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3288] = 26
                                                mem[_3288 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3443 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3443 + 68] = mem[idx + _3288 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3443 + 68] = mem[_3443 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3443 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3362 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3362] = 26
                                                mem[_3362 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3522 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3522 + 68] = mem[idx + _3362 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3522 + 68] = mem[_3522 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3522 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2246 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2246] = 26
                                            mem[_2246 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2334 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2334 + 68] = mem[idx + _2246 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2334 + 68] = mem[_2334 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2334 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                            _2648 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2648] = 26
                                            mem[_2648 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2749 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2749 + 68] = mem[idx + _2648 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2749 + 68] = mem[_2749 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2749 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3361 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3361] = 26
                                                mem[_3361 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3519 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3519 + 68] = mem[idx + _3361 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3519 + 68] = mem[_3519 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3519 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3442 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3442] = 26
                                                mem[_3442 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3598 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3598 + 68] = mem[idx + _3442 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3598 + 68] = mem[_3598 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3598 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2002 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2002] = 26
                                        mem[_2002 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2034 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2034 + 68] = mem[idx + _2002 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2034 + 68] = mem[_2034 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2034 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _2245 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2245] = 26
                                            mem[_2245 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2331 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2331 + 68] = mem[idx + _2245 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2331 + 68] = mem[_2331 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2331 + -mem[64] + 100
                                            if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                            _2647 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2647] = 26
                                            mem[_2647 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2746 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2746 + 68] = mem[idx + _2647 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2746 + 68] = mem[_2746 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2746 + -mem[64] + 100
                                            if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3360 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3360] = 26
                                                mem[_3360 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3516 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3516 + 68] = mem[idx + _3360 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3516 + 68] = mem[_3516 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3516 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3441 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3441] = 26
                                                mem[_3441 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3595 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3595 + 68] = mem[idx + _3441 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3595 + 68] = mem[_3595 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3595 + -mem[64] + 100
                                        else:
                                            if 10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2288 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2288] = 26
                                            mem[_2288 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2371 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2371 + 68] = mem[idx + _2288 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2371 + 68] = mem[_2371 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2371 + -mem[64] + 100
                                            if (10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024
                                            _2696 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2696] = 26
                                            mem[_2696 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2806 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2806 + 68] = mem[idx + _2696 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2806 + 68] = mem[_2806 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2806 + -mem[64] + 100
                                            if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3440 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3440] = 26
                                                mem[_3440 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3592 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3592 + 68] = mem[idx + _3440 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3592 + 68] = mem[_3592 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3592 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3515 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3515] = 26
                                                mem[_3515 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3686 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3686 + 68] = mem[idx + _3515 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3686 + 68] = mem[_3686 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3686 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                        else:
                            if poolInfo[idx].field_512 >= bonusEndBlock:
                                _1842 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1842] = 30
                                mem[_1842 + 32] = 'SafeMath: subtraction overflow'
                                if poolInfo[idx].field_512 > block.number:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _1842 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.number - poolInfo[idx].field_512:
                                    _1952 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1952] = 26
                                    mem[_1952 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _1961 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _1961 + 68] = mem[idx + _1952 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1961 + 68] = mem[_1961 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _1961 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2094 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2094] = 26
                                        mem[_2094 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2124 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2124 + 68] = mem[idx + _2094 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2124 + 68] = mem[_2124 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2124 + -mem[64] + 100
                                        if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                        _2409 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2409] = 26
                                        mem[_2409 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2484 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2484 + 68] = mem[idx + _2409 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2484 + 68] = mem[_2484 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2484 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _2987 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2987] = 26
                                            mem[_2987 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3095 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3095 + 68] = mem[idx + _2987 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3095 + 68] = mem[_3095 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3095 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3040 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3040] = 26
                                            mem[_3040 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3156 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3156 + 68] = mem[idx + _3040 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3156 + 68] = mem[_3156 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3156 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2109 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2109] = 26
                                        mem[_2109 + 32] = 'SafeMath: division by zero'
                                        if not poolInfo[idx].field_1024:
                                            _2148 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2148 + 68] = mem[idx + _2109 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2148 + 68] = mem[_2148 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2148 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                        _2447 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2447] = 26
                                        mem[_2447 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2520 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2520 + 68] = mem[idx + _2447 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2520 + 68] = mem[_2520 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2520 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3039 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3039] = 26
                                            mem[_3039 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3153 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3153 + 68] = mem[idx + _3039 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3153 + 68] = mem[_3153 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3153 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3094 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3094] = 26
                                            mem[_3094 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3217 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3217 + 68] = mem[idx + _3094 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3217 + 68] = mem[_3217 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3217 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock) / block.number - poolInfo[idx].field_512 != mmPerBlock:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock):
                                        _1957 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1957] = 26
                                        mem[_1957 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _1969 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _1969 + 68] = mem[idx + _1957 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_1969 + 68] = mem[_1969 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _1969 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2108 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2108] = 26
                                            mem[_2108 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2145 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2145 + 68] = mem[idx + _2108 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2145 + 68] = mem[_2145 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2145 + -mem[64] + 100
                                            if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                            _2446 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2446] = 26
                                            mem[_2446 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2517 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2517 + 68] = mem[idx + _2446 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2517 + 68] = mem[_2517 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2517 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3038 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3038] = 26
                                                mem[_3038 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3150 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3150 + 68] = mem[idx + _3038 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3150 + 68] = mem[_3150 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3150 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3093 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3093] = 26
                                                mem[_3093 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3214 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3214 + 68] = mem[idx + _3093 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3214 + 68] = mem[_3214 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3214 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2123 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2123] = 26
                                            mem[_2123 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2173 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2173 + 68] = mem[idx + _2123 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2173 + 68] = mem[_2173 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2173 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                            _2483 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2483] = 26
                                            mem[_2483 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2556 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2556 + 68] = mem[idx + _2483 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2556 + 68] = mem[_2556 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2556 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3092 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3092] = 26
                                                mem[_3092 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3211 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3211 + 68] = mem[idx + _3092 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3211 + 68] = mem[_3211 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3211 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3149 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3149] = 26
                                                mem[_3149 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3278 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3278 + 68] = mem[idx + _3149 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3278 + 68] = mem[_3278 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3278 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _1960 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1960] = 26
                                        mem[_1960 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _1976 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _1976 + 68] = mem[idx + _1960 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_1976 + 68] = mem[_1976 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _1976 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _2122 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2122] = 26
                                            mem[_2122 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2170 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2170 + 68] = mem[idx + _2122 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2170 + 68] = mem[_2170 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2170 + -mem[64] + 100
                                            if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                            _2482 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2482] = 26
                                            mem[_2482 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2553 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2553 + 68] = mem[idx + _2482 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2553 + 68] = mem[_2553 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2553 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3091 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3091] = 26
                                                mem[_3091 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3208 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3208 + 68] = mem[idx + _3091 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3208 + 68] = mem[_3208 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3208 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3148 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3148] = 26
                                                mem[_3148 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3275 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3275 + 68] = mem[idx + _3148 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3275 + 68] = mem[_3275 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3275 + -mem[64] + 100
                                        else:
                                            if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2144 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2144] = 26
                                            mem[_2144 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2200 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2200 + 68] = mem[idx + _2144 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2200 + 68] = mem[_2200 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2200 + -mem[64] + 100
                                            if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024
                                            _2516 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2516] = 26
                                            mem[_2516 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2594 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2594 + 68] = mem[idx + _2516 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2594 + 68] = mem[_2594 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2594 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3147 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3147] = 26
                                                mem[_3147 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3272 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3272 + 68] = mem[idx + _3147 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3272 + 68] = mem[_3272 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3272 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3207 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3207] = 26
                                                mem[_3207 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3346 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3346 + 68] = mem[idx + _3207 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3346 + 68] = mem[_3346 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3346 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                            else:
                                _1841 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1841] = 30
                                mem[_1841 + 32] = 'SafeMath: subtraction overflow'
                                if bonusEndBlock > block.number:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _1841 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                _1876 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1876] = 30
                                mem[_1876 + 32] = 'SafeMath: subtraction overflow'
                                if poolInfo[idx].field_512 > bonusEndBlock:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _1876 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not bonusEndBlock - poolInfo[idx].field_512:
                                    if block.number - bonusEndBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not block.number - bonusEndBlock:
                                        _2091 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2091] = 26
                                        mem[_2091 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2119 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2119 + 68] = mem[idx + _2091 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2119 + 68] = mem[_2119 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2119 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2481 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2481] = 26
                                            mem[_2481 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2550 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2550 + 68] = mem[idx + _2481 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2550 + 68] = mem[_2550 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2550 + -mem[64] + 100
                                            if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                            _2978 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2978] = 26
                                            mem[_2978 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3088 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3088 + 68] = mem[idx + _2978 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3088 + 68] = mem[_3088 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3088 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3863 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3863] = 26
                                                mem[_3863 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4082 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4082 + 68] = mem[idx + _3863 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4082 + 68] = mem[_4082 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4082 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3968 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3968] = 26
                                                mem[_3968 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4206 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4206 + 68] = mem[idx + _3968 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4206 + 68] = mem[_4206 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4206 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2515 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2515] = 26
                                            mem[_2515 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2591 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2591 + 68] = mem[idx + _2515 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2591 + 68] = mem[_2591 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2591 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                            _3035 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3035] = 26
                                            mem[_3035 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3144 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3144 + 68] = mem[idx + _3035 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3144 + 68] = mem[_3144 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3144 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3967 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3967] = 26
                                                mem[_3967 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4203 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4203 + 68] = mem[idx + _3967 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4203 + 68] = mem[_4203 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4203 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4081 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4081] = 26
                                                mem[_4081 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4328 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4328 + 68] = mem[idx + _4081 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4328 + 68] = mem[_4328 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4328 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) / block.number - bonusEndBlock != mmPerBlock:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock):
                                            _2105 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2105] = 26
                                            mem[_2105 + 32] = 'SafeMath: division by zero'
                                            if not totalAllocPoint:
                                                _2141 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2141 + 68] = mem[idx + _2105 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2141 + 68] = mem[_2141 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2141 + -mem[64] + 100
                                            require idx < poolInfo.length
                                            mem[0] = 10
                                            if not 0 / totalAllocPoint:
                                                _2514 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2514] = 26
                                                mem[_2514 + 32] = 'SafeMath: division by zero'
                                                if not poolInfo[idx].field_1024:
                                                    _2588 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2588 + 68] = mem[idx + _2514 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2588 + 68] = mem[_2588 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2588 + -mem[64] + 100
                                                if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                                _3034 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3034] = 26
                                                mem[_3034 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3141 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3141 + 68] = mem[idx + _3034 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3141 + 68] = mem[_3141 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3141 + -mem[64] + 100
                                                if not 0 / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _3966 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_3966] = 26
                                                    mem[_3966 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4200 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4200 + 68] = mem[idx + _3966 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4200 + 68] = mem[_4200 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4200 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4080 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4080] = 26
                                                    mem[_4080 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4325 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4325 + 68] = mem[idx + _4080 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4325 + 68] = mem[_4325 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4325 + -mem[64] + 100
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _2549 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2549] = 26
                                                mem[_2549 + 32] = 'SafeMath: division by zero'
                                                if not poolInfo[idx].field_1024:
                                                    _2636 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2636 + 68] = mem[idx + _2549 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2636 + 68] = mem[_2636 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2636 + -mem[64] + 100
                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                                _3087 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3087] = 26
                                                mem[_3087 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3203 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3203 + 68] = mem[idx + _3087 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3203 + 68] = mem[_3203 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3203 + -mem[64] + 100
                                                if not 0 / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4079 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4079] = 26
                                                    mem[_4079 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4322 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4322 + 68] = mem[idx + _4079 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4322 + 68] = mem[_4322 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4322 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4199 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4199] = 26
                                                    mem[_4199 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4441 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4441 + 68] = mem[idx + _4199 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4441 + 68] = mem[_4441 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4441 + -mem[64] + 100
                                            ('stor', ('name', 'treasuryDivRate', 5))
                                            if not 0 / totalAllocPoint / treasuryDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, 0
                                            else:
                                                if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = 0 / totalAllocPoint
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2118 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2118] = 26
                                            mem[_2118 + 32] = 'SafeMath: division by zero'
                                            if not totalAllocPoint:
                                                _2166 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2166 + 68] = mem[idx + _2118 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2166 + 68] = mem[_2166 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2166 + -mem[64] + 100
                                            require idx < poolInfo.length
                                            mem[0] = 10
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                                _2548 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2548] = 26
                                                mem[_2548 + 32] = 'SafeMath: division by zero'
                                                if not poolInfo[idx].field_1024:
                                                    _2633 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2633 + 68] = mem[idx + _2548 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2633 + 68] = mem[_2633 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2633 + -mem[64] + 100
                                                if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                                _3086 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3086] = 26
                                                mem[_3086 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3200 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3200 + 68] = mem[idx + _3086 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3200 + 68] = mem[_3200 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3200 + -mem[64] + 100
                                                if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4078 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4078] = 26
                                                    mem[_4078 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4319 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4319 + 68] = mem[idx + _4078 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4319 + 68] = mem[_4319 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4319 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4198 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4198] = 26
                                                    mem[_4198 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4438 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4438 + 68] = mem[idx + _4198 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4438 + 68] = mem[_4438 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4438 + -mem[64] + 100
                                            else:
                                                if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _2587 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2587] = 26
                                                mem[_2587 + 32] = 'SafeMath: division by zero'
                                                if not poolInfo[idx].field_1024:
                                                    _2682 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2682 + 68] = mem[idx + _2587 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2682 + 68] = mem[_2682 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2682 + -mem[64] + 100
                                                if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024
                                                _3140 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3140] = 26
                                                mem[_3140 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3265 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3265 + 68] = mem[idx + _3140 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3265 + 68] = mem[_3265 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3265 + -mem[64] + 100
                                                if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4197 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4197] = 26
                                                    mem[_4197 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4435 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4435 + 68] = mem[idx + _4197 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4435 + 68] = mem[_4435 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4435 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4318 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4318] = 26
                                                    mem[_4318 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4548 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4548 + 68] = mem[idx + _4318 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4548 + 68] = mem[_4548 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4548 + -mem[64] + 100
                                            ('stor', ('name', 'treasuryDivRate', 5))
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, 0
                                            else:
                                                if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                else:
                                    if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if block.number + (9 * bonusEndBlock) < 10 * bonusEndBlock:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not block.number + (9 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                                        _2104 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2104] = 26
                                        mem[_2104 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2138 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2138 + 68] = mem[idx + _2104 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2138 + 68] = mem[_2138 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2138 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2511 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2511] = 26
                                            mem[_2511 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2584 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2584 + 68] = mem[idx + _2511 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2584 + 68] = mem[_2584 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2584 + -mem[64] + 100
                                            if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                            _3033 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3033] = 26
                                            mem[_3033 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3137 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3137 + 68] = mem[idx + _3033 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3137 + 68] = mem[_3137 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3137 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3963 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3963] = 26
                                                mem[_3963 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4194 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4194 + 68] = mem[idx + _3963 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4194 + 68] = mem[_4194 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4194 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4077 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4077] = 26
                                                mem[_4077 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4315 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4315 + 68] = mem[idx + _4077 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4315 + 68] = mem[_4315 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4315 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2547 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2547] = 26
                                            mem[_2547 + 32] = 'SafeMath: division by zero'
                                            if not poolInfo[idx].field_1024:
                                                _2630 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2630 + 68] = mem[idx + _2547 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2630 + 68] = mem[_2630 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2630 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                            _3085 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3085] = 26
                                            mem[_3085 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3197 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3197 + 68] = mem[idx + _3085 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3197 + 68] = mem[_3197 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3197 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4076 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4076] = 26
                                                mem[_4076 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4312 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4312 + 68] = mem[idx + _4076 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4312 + 68] = mem[_4312 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4312 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4193 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4193] = 26
                                                mem[_4193 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4431 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4431 + 68] = mem[idx + _4193 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4431 + 68] = mem[_4431 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4431 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) / block.number + (9 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != mmPerBlock:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock):
                                            _2117 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2117] = 26
                                            mem[_2117 + 32] = 'SafeMath: division by zero'
                                            if not totalAllocPoint:
                                                _2163 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2163 + 68] = mem[idx + _2117 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2163 + 68] = mem[_2163 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2163 + -mem[64] + 100
                                            require idx < poolInfo.length
                                            mem[0] = 10
                                            if not 0 / totalAllocPoint:
                                                _2546 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2546] = 26
                                                mem[_2546 + 32] = 'SafeMath: division by zero'
                                                if not poolInfo[idx].field_1024:
                                                    _2627 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2627 + 68] = mem[idx + _2546 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2627 + 68] = mem[_2627 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2627 + -mem[64] + 100
                                                if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                                _3084 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3084] = 26
                                                mem[_3084 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3194 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3194 + 68] = mem[idx + _3084 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3194 + 68] = mem[_3194 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3194 + -mem[64] + 100
                                                if not 0 / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4075 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4075] = 26
                                                    mem[_4075 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4309 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4309 + 68] = mem[idx + _4075 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4309 + 68] = mem[_4309 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4309 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4192 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4192] = 26
                                                    mem[_4192 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4428 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4428 + 68] = mem[idx + _4192 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4428 + 68] = mem[_4428 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4428 + -mem[64] + 100
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _2583 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2583] = 26
                                                mem[_2583 + 32] = 'SafeMath: division by zero'
                                                if not poolInfo[idx].field_1024:
                                                    _2678 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2678 + 68] = mem[idx + _2583 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2678 + 68] = mem[_2678 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2678 + -mem[64] + 100
                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1024
                                                _3136 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3136] = 26
                                                mem[_3136 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3261 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3261 + 68] = mem[idx + _3136 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3261 + 68] = mem[_3261 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3261 + -mem[64] + 100
                                                if not 0 / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4191 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4191] = 26
                                                    mem[_4191 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4425 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4425 + 68] = mem[idx + _4191 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4425 + 68] = mem[_4425 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4425 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4308 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4308] = 26
                                                    mem[_4308 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4540 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4540 + 68] = mem[idx + _4308 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4540 + 68] = mem[_4540 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4540 + -mem[64] + 100
                                            ('stor', ('name', 'treasuryDivRate', 5))
                                            if not 0 / totalAllocPoint / treasuryDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, 0
                                            else:
                                                if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = 0 / totalAllocPoint
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2137 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2137] = 26
                                            mem[_2137 + 32] = 'SafeMath: division by zero'
                                            if not totalAllocPoint:
                                                _2193 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2193 + 68] = mem[idx + _2137 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2193 + 68] = mem[_2193 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2193 + -mem[64] + 100
                                            require idx < poolInfo.length
                                            mem[0] = 10
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                                _2582 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2582] = 26
                                                mem[_2582 + 32] = 'SafeMath: division by zero'
                                                if not poolInfo[idx].field_1024:
                                                    _2675 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2675 + 68] = mem[idx + _2582 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2675 + 68] = mem[_2675 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2675 + -mem[64] + 100
                                                if (0 / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1024
                                                _3135 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3135] = 26
                                                mem[_3135 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3258 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3258 + 68] = mem[idx + _3135 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3258 + 68] = mem[_3258 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3258 + -mem[64] + 100
                                                if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4190 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4190] = 26
                                                    mem[_4190 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4422 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4422 + 68] = mem[idx + _4190 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4422 + 68] = mem[_4422 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4422 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4307 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4307] = 26
                                                    mem[_4307 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4537 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4537 + 68] = mem[idx + _4307 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4537 + 68] = mem[_4537 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4537 + -mem[64] + 100
                                            else:
                                                if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _2626 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2626] = 26
                                                mem[_2626 + 32] = 'SafeMath: division by zero'
                                                if not poolInfo[idx].field_1024:
                                                    _2728 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2728 + 68] = mem[idx + _2626 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2728 + 68] = mem[_2728 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2728 + -mem[64] + 100
                                                if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1024
                                                _3193 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3193] = 26
                                                mem[_3193 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3332 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3332 + 68] = mem[idx + _3193 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3332 + 68] = mem[_3332 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3332 + -mem[64] + 100
                                                if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4306 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4306] = 26
                                                    mem[_4306 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4534 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4534 + 68] = mem[idx + _4306 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4534 + 68] = mem[_4534 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4534 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4421 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4421] = 26
                                                    mem[_4421 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4640 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4640 + 68] = mem[idx + _4421 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4640 + 68] = mem[_4640 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4640 + -mem[64] + 100
                                            ('stor', ('name', 'treasuryDivRate', 5))
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, 0
                                            else:
                                                if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                else:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(poolInfo[idx].field_0)
                    staticcall poolInfo[idx].field_0.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        if block.number <= bonusEndBlock:
                            _1846 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1846] = 30
                            mem[_1846 + 32] = 'SafeMath: subtraction overflow'
                            if poolInfo[idx].field_512 > block.number:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _1846 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.number - poolInfo[idx].field_512:
                                _1997 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1997] = 26
                                mem[_1997 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _2027 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2027 + 68] = mem[idx + _1997 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2027 + 68] = mem[_2027 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _2027 + -mem[64] + 100
                                require idx < poolInfo.length
                                mem[0] = 10
                                if not 0 / totalAllocPoint:
                                    _2230 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2230] = 26
                                    mem[_2230 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        _2314 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2314 + 68] = mem[idx + _2230 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2314 + 68] = mem[_2314 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2314 + -mem[64] + 100
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    _2625 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2625] = 26
                                    mem[_2625 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2725 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2725 + 68] = mem[idx + _2625 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2725 + 68] = mem[_2725 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2725 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3331 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3331] = 26
                                        mem[_3331 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3490 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3490 + 68] = mem[idx + _3331 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3490 + 68] = mem[_3490 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3490 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3411 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3411] = 26
                                        mem[_3411 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3571 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3571 + 68] = mem[idx + _3411 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3571 + 68] = mem[_3571 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3571 + -mem[64] + 100
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _2270 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2270] = 26
                                    mem[_2270 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        _2360 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2360 + 68] = mem[idx + _2270 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2360 + 68] = mem[_2360 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2360 + -mem[64] + 100
                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    _2674 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2674] = 26
                                    mem[_2674 + 32] = 'SafeMath: division by zero'
                                    if not devFundDivRate:
                                        _2782 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2782 + 68] = mem[idx + _2674 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2782 + 68] = mem[_2782 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2782 + -mem[64] + 100
                                    if not 0 / totalAllocPoint / devFundDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3410 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3410] = 26
                                        mem[_3410 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3568 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3568 + 68] = mem[idx + _3410 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3568 + 68] = mem[_3568 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3568 + -mem[64] + 100
                                    else:
                                        if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3489 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3489] = 26
                                        mem[_3489 + 32] = 'SafeMath: division by zero'
                                        if not treasuryDivRate:
                                            _3652 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _3652 + 68] = mem[idx + _3489 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_3652 + 68] = mem[_3652 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _3652 + -mem[64] + 100
                                ('stor', ('name', 'treasuryDivRate', 5))
                                if not 0 / totalAllocPoint / treasuryDivRate:
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, 0
                                else:
                                    if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint
                                require ext_code.size(mmAddress)
                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint
                            else:
                                if (10 * block.number) - (10 * poolInfo[idx].field_512) / block.number - poolInfo[idx].field_512 != 10:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not (10 * block.number) - (10 * poolInfo[idx].field_512):
                                    _2012 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2012] = 26
                                    mem[_2012 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _2045 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2045 + 68] = mem[idx + _2012 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2045 + 68] = mem[_2045 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _2045 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2269 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2269] = 26
                                        mem[_2269 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2357 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2357 + 68] = mem[idx + _2269 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2357 + 68] = mem[_2357 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2357 + -mem[64] + 100
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        _2673 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2673] = 26
                                        mem[_2673 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2779 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2779 + 68] = mem[idx + _2673 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2779 + 68] = mem[_2779 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2779 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3409 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3409] = 26
                                            mem[_3409 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3565 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3565 + 68] = mem[idx + _3409 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3565 + 68] = mem[_3565 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3565 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3488 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3488] = 26
                                            mem[_3488 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3649 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3649 + 68] = mem[idx + _3488 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3649 + 68] = mem[_3649 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3649 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2313 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2313] = 26
                                        mem[_2313 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2402 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2402 + 68] = mem[idx + _2313 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2402 + 68] = mem[_2402 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2402 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        _2724 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2724] = 26
                                        mem[_2724 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2841 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2841 + 68] = mem[idx + _2724 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2841 + 68] = mem[_2841 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2841 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3487 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3487] = 26
                                            mem[_3487 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3646 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3646 + 68] = mem[idx + _3487 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3646 + 68] = mem[_3646 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3646 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3564 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3564] = 26
                                            mem[_3564 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3736 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3736 + 68] = mem[idx + _3564 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3736 + 68] = mem[_3736 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3736 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) / (10 * block.number) - (10 * poolInfo[idx].field_512) != mmPerBlock:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock):
                                        _2026 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2026] = 26
                                        mem[_2026 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2059 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2059 + 68] = mem[idx + _2026 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2059 + 68] = mem[_2059 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2059 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2312 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2312] = 26
                                            mem[_2312 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2399 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2399 + 68] = mem[idx + _2312 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2399 + 68] = mem[_2399 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2399 + -mem[64] + 100
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            _2723 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2723] = 26
                                            mem[_2723 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2838 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2838 + 68] = mem[idx + _2723 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2838 + 68] = mem[_2838 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2838 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3486 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3486] = 26
                                                mem[_3486 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3643 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3643 + 68] = mem[idx + _3486 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3643 + 68] = mem[_3643 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3643 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3563 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3563] = 26
                                                mem[_3563 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3733 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3733 + 68] = mem[idx + _3563 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3733 + 68] = mem[_3733 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3733 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2356 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2356] = 26
                                            mem[_2356 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2437 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2437 + 68] = mem[idx + _2356 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2437 + 68] = mem[_2437 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2437 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            _2778 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2778] = 26
                                            mem[_2778 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2901 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2901 + 68] = mem[idx + _2778 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2901 + 68] = mem[_2901 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2901 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3562 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3562] = 26
                                                mem[_3562 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3730 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3730 + 68] = mem[idx + _3562 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3730 + 68] = mem[_3730 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3730 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3642 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3642] = 26
                                                mem[_3642 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3829 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3829 + 68] = mem[idx + _3642 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3829 + 68] = mem[_3829 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3829 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (10 * block.number * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2044 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2044] = 26
                                        mem[_2044 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2072 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2072 + 68] = mem[idx + _2044 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2072 + 68] = mem[_2072 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2072 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _2355 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2355] = 26
                                            mem[_2355 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2434 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2434 + 68] = mem[idx + _2355 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2434 + 68] = mem[_2434 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2434 + -mem[64] + 100
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            _2777 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2777] = 26
                                            mem[_2777 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2898 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2898 + 68] = mem[idx + _2777 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2898 + 68] = mem[_2898 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2898 + -mem[64] + 100
                                            if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3561 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3561] = 26
                                                mem[_3561 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3727 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3727 + 68] = mem[idx + _3561 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3727 + 68] = mem[_3727 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3727 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3641 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3641] = 26
                                                mem[_3641 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3826 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3826 + 68] = mem[idx + _3641 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3826 + 68] = mem[_3826 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3826 + -mem[64] + 100
                                        else:
                                            if 10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2398 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2398] = 26
                                            mem[_2398 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2467 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2467 + 68] = mem[idx + _2398 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2467 + 68] = mem[_2467 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2467 + -mem[64] + 100
                                            if (10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            _2837 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2837] = 26
                                            mem[_2837 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2961 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2961 + 68] = mem[idx + _2837 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2961 + 68] = mem[_2961 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2961 + -mem[64] + 100
                                            if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3640 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3640] = 26
                                                mem[_3640 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3823 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3823 + 68] = mem[idx + _3640 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3823 + 68] = mem[_3823 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3823 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3726 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3726] = 26
                                                mem[_3726 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3937 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3937 + 68] = mem[idx + _3726 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3937 + 68] = mem[_3937 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3937 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (10 * block.number * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                        else:
                            if poolInfo[idx].field_512 >= bonusEndBlock:
                                _1855 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1855] = 30
                                mem[_1855 + 32] = 'SafeMath: subtraction overflow'
                                if poolInfo[idx].field_512 > block.number:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _1855 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.number - poolInfo[idx].field_512:
                                    _1968 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1968] = 26
                                    mem[_1968 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        _1984 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _1984 + 68] = mem[idx + _1968 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1984 + 68] = mem[_1984 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _1984 + -mem[64] + 100
                                    require idx < poolInfo.length
                                    mem[0] = 10
                                    if not 0 / totalAllocPoint:
                                        _2134 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2134] = 26
                                        mem[_2134 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2188 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2188 + 68] = mem[idx + _2134 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2188 + 68] = mem[_2188 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2188 + -mem[64] + 100
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        _2498 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2498] = 26
                                        mem[_2498 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2571 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2571 + 68] = mem[idx + _2498 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2571 + 68] = mem[_2571 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2571 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3126 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3126] = 26
                                            mem[_3126 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3243 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3243 + 68] = mem[idx + _3126 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3243 + 68] = mem[_3243 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3243 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3181 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3181] = 26
                                            mem[_3181 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3316 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3316 + 68] = mem[idx + _3181 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3316 + 68] = mem[_3316 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3316 + -mem[64] + 100
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2161 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2161] = 26
                                        mem[_2161 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            _2225 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2225 + 68] = mem[idx + _2161 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2225 + 68] = mem[_2225 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2225 + -mem[64] + 100
                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        _2532 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2532] = 26
                                        mem[_2532 + 32] = 'SafeMath: division by zero'
                                        if not devFundDivRate:
                                            _2617 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2617 + 68] = mem[idx + _2532 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2617 + 68] = mem[_2617 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2617 + -mem[64] + 100
                                        if not 0 / totalAllocPoint / devFundDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3180 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3180] = 26
                                            mem[_3180 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3313 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3313 + 68] = mem[idx + _3180 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3313 + 68] = mem[_3313 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3313 + -mem[64] + 100
                                        else:
                                            if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3242 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3242] = 26
                                            mem[_3242 + 32] = 'SafeMath: division by zero'
                                            if not treasuryDivRate:
                                                _3397 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3397 + 68] = mem[idx + _3242 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3397 + 68] = mem[_3397 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3397 + -mem[64] + 100
                                    ('stor', ('name', 'treasuryDivRate', 5))
                                    if not 0 / totalAllocPoint / treasuryDivRate:
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, 0
                                    else:
                                        if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(mmAddress)
                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                else:
                                    if (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock) / block.number - poolInfo[idx].field_512 != mmPerBlock:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock):
                                        _1975 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1975] = 26
                                        mem[_1975 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _1994 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _1994 + 68] = mem[idx + _1975 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_1994 + 68] = mem[_1994 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _1994 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2160 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2160] = 26
                                            mem[_2160 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2222 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2222 + 68] = mem[idx + _2160 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2222 + 68] = mem[_2222 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2222 + -mem[64] + 100
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            _2531 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2531] = 26
                                            mem[_2531 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2614 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2614 + 68] = mem[idx + _2531 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2614 + 68] = mem[_2614 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2614 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3179 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3179] = 26
                                                mem[_3179 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3310 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3310 + 68] = mem[idx + _3179 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3310 + 68] = mem[_3310 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3310 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3241 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3241] = 26
                                                mem[_3241 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3394 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3394 + 68] = mem[idx + _3241 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3394 + 68] = mem[_3394 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3394 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2187 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2187] = 26
                                            mem[_2187 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2263 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2263 + 68] = mem[idx + _2187 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2263 + 68] = mem[_2263 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2263 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            _2570 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2570] = 26
                                            mem[_2570 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2667 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2667 + 68] = mem[idx + _2570 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2667 + 68] = mem[_2667 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2667 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3240 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3240] = 26
                                                mem[_3240 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3391 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3391 + 68] = mem[idx + _3240 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3391 + 68] = mem[_3391 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3391 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3309 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3309] = 26
                                                mem[_3309 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3476 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3476 + 68] = mem[idx + _3309 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3476 + 68] = mem[_3476 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3476 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) - (poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _1983 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1983] = 26
                                        mem[_1983 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2006 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2006 + 68] = mem[idx + _1983 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2006 + 68] = mem[_2006 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2006 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _2186 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2186] = 26
                                            mem[_2186 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2260 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2260 + 68] = mem[idx + _2186 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2260 + 68] = mem[_2260 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2260 + -mem[64] + 100
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            _2569 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2569] = 26
                                            mem[_2569 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2664 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2664 + 68] = mem[idx + _2569 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2664 + 68] = mem[_2664 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2664 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3239 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3239] = 26
                                                mem[_3239 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3388 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3388 + 68] = mem[idx + _3239 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3388 + 68] = mem[_3388 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3388 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3308 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3308] = 26
                                                mem[_3308 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3473 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3473 + 68] = mem[idx + _3308 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3473 + 68] = mem[_3473 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3473 + -mem[64] + 100
                                        else:
                                            if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2221 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2221] = 26
                                            mem[_2221 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2303 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2303 + 68] = mem[idx + _2221 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2303 + 68] = mem[_2303 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2303 + -mem[64] + 100
                                            if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            _2613 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2613] = 26
                                            mem[_2613 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _2716 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2716 + 68] = mem[idx + _2613 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2716 + 68] = mem[_2716 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2716 + -mem[64] + 100
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3307 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3307] = 26
                                                mem[_3307 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3470 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3470 + 68] = mem[idx + _3307 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3470 + 68] = mem[_3470 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3470 + -mem[64] + 100
                                            else:
                                                if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _3387 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3387] = 26
                                                mem[_3387 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _3547 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3547 + 68] = mem[idx + _3387 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3547 + 68] = mem[_3547 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3547 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                            else:
                                _1854 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1854] = 30
                                mem[_1854 + 32] = 'SafeMath: subtraction overflow'
                                if bonusEndBlock > block.number:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _1854 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                _1905 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1905] = 30
                                mem[_1905 + 32] = 'SafeMath: subtraction overflow'
                                if poolInfo[idx].field_512 > bonusEndBlock:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _1905 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not bonusEndBlock - poolInfo[idx].field_512:
                                    if block.number - bonusEndBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not block.number - bonusEndBlock:
                                        _2131 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2131] = 26
                                        mem[_2131 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2183 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2183 + 68] = mem[idx + _2131 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2183 + 68] = mem[_2183 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2183 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2568 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2568] = 26
                                            mem[_2568 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2661 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2661 + 68] = mem[idx + _2568 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2661 + 68] = mem[_2661 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2661 + -mem[64] + 100
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            _3117 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3117] = 26
                                            mem[_3117 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3236 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3236 + 68] = mem[idx + _3117 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3236 + 68] = mem[_3236 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3236 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4146 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4146] = 26
                                                mem[_4146 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4377 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4377 + 68] = mem[idx + _4146 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4377 + 68] = mem[_4377 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4377 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4262 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4262] = 26
                                                mem[_4262 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4491 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4491 + 68] = mem[idx + _4262 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4491 + 68] = mem[_4491 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4491 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2612 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2612] = 26
                                            mem[_2612 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2713 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2713 + 68] = mem[idx + _2612 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2713 + 68] = mem[_2713 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2713 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            _3176 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3176] = 26
                                            mem[_3176 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3304 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3304 + 68] = mem[idx + _3176 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3304 + 68] = mem[_3304 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3304 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4261 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4261] = 26
                                                mem[_4261 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4488 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4488 + 68] = mem[idx + _4261 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4488 + 68] = mem[_4488 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4488 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4376 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4376] = 26
                                                mem[_4376 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4600 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4600 + 68] = mem[idx + _4376 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4600 + 68] = mem[_4600 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4600 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) / block.number - bonusEndBlock != mmPerBlock:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock):
                                            _2157 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2157] = 26
                                            mem[_2157 + 32] = 'SafeMath: division by zero'
                                            if not totalAllocPoint:
                                                _2218 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2218 + 68] = mem[idx + _2157 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2218 + 68] = mem[_2218 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2218 + -mem[64] + 100
                                            require idx < poolInfo.length
                                            mem[0] = 10
                                            if not 0 / totalAllocPoint:
                                                _2611 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2611] = 26
                                                mem[_2611 + 32] = 'SafeMath: division by zero'
                                                if not ext_call.return_data[0]:
                                                    _2710 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2710 + 68] = mem[idx + _2611 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2710 + 68] = mem[_2710 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2710 + -mem[64] + 100
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                _3175 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3175] = 26
                                                mem[_3175 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3301 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3301 + 68] = mem[idx + _3175 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3301 + 68] = mem[_3301 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3301 + -mem[64] + 100
                                                if not 0 / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4260 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4260] = 26
                                                    mem[_4260 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4485 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4485 + 68] = mem[idx + _4260 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4485 + 68] = mem[_4485 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4485 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4375 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4375] = 26
                                                    mem[_4375 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4597 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4597 + 68] = mem[idx + _4375 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4597 + 68] = mem[_4597 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4597 + -mem[64] + 100
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _2660 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2660] = 26
                                                mem[_2660 + 32] = 'SafeMath: division by zero'
                                                if not ext_call.return_data[0]:
                                                    _2766 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2766 + 68] = mem[idx + _2660 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2766 + 68] = mem[_2766 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2766 + -mem[64] + 100
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                _3235 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3235] = 26
                                                mem[_3235 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3383 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3383 + 68] = mem[idx + _3235 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3383 + 68] = mem[_3383 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3383 + -mem[64] + 100
                                                if not 0 / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4374 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4374] = 26
                                                    mem[_4374 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4594 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4594 + 68] = mem[idx + _4374 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4594 + 68] = mem[_4594 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4594 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4484 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4484] = 26
                                                    mem[_4484 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4696 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4696 + 68] = mem[idx + _4484 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4696 + 68] = mem[_4696 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4696 + -mem[64] + 100
                                            ('stor', ('name', 'treasuryDivRate', 5))
                                            if not 0 / totalAllocPoint / treasuryDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, 0
                                            else:
                                                if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = 0 / totalAllocPoint
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) - (bonusEndBlock * mmPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2182 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2182] = 26
                                            mem[_2182 + 32] = 'SafeMath: division by zero'
                                            if not totalAllocPoint:
                                                _2256 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2256 + 68] = mem[idx + _2182 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2256 + 68] = mem[_2256 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2256 + -mem[64] + 100
                                            require idx < poolInfo.length
                                            mem[0] = 10
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                                _2659 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2659] = 26
                                                mem[_2659 + 32] = 'SafeMath: division by zero'
                                                if not ext_call.return_data[0]:
                                                    _2763 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2763 + 68] = mem[idx + _2659 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2763 + 68] = mem[_2763 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2763 + -mem[64] + 100
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                _3234 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3234] = 26
                                                mem[_3234 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3380 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3380 + 68] = mem[idx + _3234 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3380 + 68] = mem[_3380 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3380 + -mem[64] + 100
                                                if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4373 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4373] = 26
                                                    mem[_4373 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4591 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4591 + 68] = mem[idx + _4373 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4591 + 68] = mem[_4591 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4591 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4483 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4483] = 26
                                                    mem[_4483 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4693 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4693 + 68] = mem[idx + _4483 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4693 + 68] = mem[_4693 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4693 + -mem[64] + 100
                                            else:
                                                if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _2709 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2709] = 26
                                                mem[_2709 + 32] = 'SafeMath: division by zero'
                                                if not ext_call.return_data[0]:
                                                    _2823 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2823 + 68] = mem[idx + _2709 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2823 + 68] = mem[_2823 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2823 + -mem[64] + 100
                                                if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                _3300 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3300] = 26
                                                mem[_3300 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3463 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3463 + 68] = mem[idx + _3300 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3463 + 68] = mem[_3463 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3463 + -mem[64] + 100
                                                if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4482 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4482] = 26
                                                    mem[_4482 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4690 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4690 + 68] = mem[idx + _4482 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4690 + 68] = mem[_4690 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4690 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4590 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4590] = 26
                                                    mem[_4590 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4771 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4771 + 68] = mem[idx + _4590 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4771 + 68] = mem[_4771 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4771 + -mem[64] + 100
                                            ('stor', ('name', 'treasuryDivRate', 5))
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, 0
                                            else:
                                                if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                else:
                                    if (10 * bonusEndBlock) - (10 * poolInfo[idx].field_512) / bonusEndBlock - poolInfo[idx].field_512 != 10:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if block.number + (9 * bonusEndBlock) < 10 * bonusEndBlock:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not block.number + (9 * bonusEndBlock) - (10 * poolInfo[idx].field_512):
                                        _2156 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2156] = 26
                                        mem[_2156 + 32] = 'SafeMath: division by zero'
                                        if not totalAllocPoint:
                                            _2215 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _2215 + 68] = mem[idx + _2156 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_2215 + 68] = mem[_2215 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _2215 + -mem[64] + 100
                                        require idx < poolInfo.length
                                        mem[0] = 10
                                        if not 0 / totalAllocPoint:
                                            _2608 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2608] = 26
                                            mem[_2608 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2706 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2706 + 68] = mem[idx + _2608 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2706 + 68] = mem[_2706 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2706 + -mem[64] + 100
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            _3174 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3174] = 26
                                            mem[_3174 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3297 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3297 + 68] = mem[idx + _3174 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3297 + 68] = mem[_3297 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3297 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4257 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4257] = 26
                                                mem[_4257 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4479 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4479 + 68] = mem[idx + _4257 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4479 + 68] = mem[_4479 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4479 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4372 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4372] = 26
                                                mem[_4372 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4587 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4587 + 68] = mem[idx + _4372 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4587 + 68] = mem[_4587 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4587 + -mem[64] + 100
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2658 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2658] = 26
                                            mem[_2658 + 32] = 'SafeMath: division by zero'
                                            if not ext_call.return_data[0]:
                                                _2760 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2760 + 68] = mem[idx + _2658 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2760 + 68] = mem[_2760 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2760 + -mem[64] + 100
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            _3233 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_3233] = 26
                                            mem[_3233 + 32] = 'SafeMath: division by zero'
                                            if not devFundDivRate:
                                                _3377 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _3377 + 68] = mem[idx + _3233 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_3377 + 68] = mem[_3377 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _3377 + -mem[64] + 100
                                            if not 0 / totalAllocPoint / devFundDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, 0
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4371 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4371] = 26
                                                mem[_4371 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4584 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4584 + 68] = mem[idx + _4371 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4584 + 68] = mem[_4584 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4584 + -mem[64] + 100
                                            else:
                                                if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4478 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_4478] = 26
                                                mem[_4478 + 32] = 'SafeMath: division by zero'
                                                if not treasuryDivRate:
                                                    _4686 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _4686 + 68] = mem[idx + _4478 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_4686 + 68] = mem[_4686 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _4686 + -mem[64] + 100
                                        ('stor', ('name', 'treasuryDivRate', 5))
                                        if not 0 / totalAllocPoint / treasuryDivRate:
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, 0
                                        else:
                                            if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(mmAddress)
                                        call mmAddress.mint(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                    else:
                                        if (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) / block.number + (9 * bonusEndBlock) - (10 * poolInfo[idx].field_512) != mmPerBlock:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock):
                                            _2181 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2181] = 26
                                            mem[_2181 + 32] = 'SafeMath: division by zero'
                                            if not totalAllocPoint:
                                                _2253 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2253 + 68] = mem[idx + _2181 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2253 + 68] = mem[_2253 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2253 + -mem[64] + 100
                                            require idx < poolInfo.length
                                            mem[0] = 10
                                            if not 0 / totalAllocPoint:
                                                _2657 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2657] = 26
                                                mem[_2657 + 32] = 'SafeMath: division by zero'
                                                if not ext_call.return_data[0]:
                                                    _2757 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2757 + 68] = mem[idx + _2657 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2757 + 68] = mem[_2757 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2757 + -mem[64] + 100
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                _3232 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3232] = 26
                                                mem[_3232 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3374 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3374 + 68] = mem[idx + _3232 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3374 + 68] = mem[_3374 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3374 + -mem[64] + 100
                                                if not 0 / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4370 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4370] = 26
                                                    mem[_4370 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4581 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4581 + 68] = mem[idx + _4370 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4581 + 68] = mem[_4581 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4581 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4477 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4477] = 26
                                                    mem[_4477 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4683 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4683 + 68] = mem[idx + _4477 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4683 + 68] = mem[_4683 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4683 + -mem[64] + 100
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _2705 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2705] = 26
                                                mem[_2705 + 32] = 'SafeMath: division by zero'
                                                if not ext_call.return_data[0]:
                                                    _2819 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2819 + 68] = mem[idx + _2705 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2819 + 68] = mem[_2819 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2819 + -mem[64] + 100
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                _3296 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3296] = 26
                                                mem[_3296 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3459 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3459 + 68] = mem[idx + _3296 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3459 + 68] = mem[_3459 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3459 + -mem[64] + 100
                                                if not 0 / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4476 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4476] = 26
                                                    mem[_4476 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4680 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4680 + 68] = mem[idx + _4476 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4680 + 68] = mem[_4680 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4680 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * 0 / totalAllocPoint / devFundDivRate / 0 / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * 0 / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4580 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4580] = 26
                                                    mem[_4580 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4763 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4763 + 68] = mem[idx + _4580 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4763 + 68] = mem[_4763 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4763 + -mem[64] + 100
                                            ('stor', ('name', 'treasuryDivRate', 5))
                                            if not 0 / totalAllocPoint / treasuryDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, 0
                                            else:
                                                if treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate / 0 / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, treasuryMultiplier * 0 / totalAllocPoint / treasuryDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = 0 / totalAllocPoint
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                        else:
                                            if (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / (block.number * mmPerBlock) + (9 * bonusEndBlock * mmPerBlock) - (10 * poolInfo[idx].field_512 * mmPerBlock) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _2214 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_2214] = 26
                                            mem[_2214 + 32] = 'SafeMath: division by zero'
                                            if not totalAllocPoint:
                                                _2296 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _2296 + 68] = mem[idx + _2214 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_2296 + 68] = mem[_2296 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _2296 + -mem[64] + 100
                                            require idx < poolInfo.length
                                            mem[0] = 10
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                                _2704 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2704] = 26
                                                mem[_2704 + 32] = 'SafeMath: division by zero'
                                                if not ext_call.return_data[0]:
                                                    _2816 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2816 + 68] = mem[idx + _2704 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2816 + 68] = mem[_2816 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2816 + -mem[64] + 100
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                _3295 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3295] = 26
                                                mem[_3295 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3456 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3456 + 68] = mem[idx + _3295 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3456 + 68] = mem[_3456 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3456 + -mem[64] + 100
                                                if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4475 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4475] = 26
                                                    mem[_4475 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4677 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4677 + 68] = mem[idx + _4475 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4677 + 68] = mem[_4677 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4677 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4579 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4579] = 26
                                                    mem[_4579 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4760 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4760 + 68] = mem[idx + _4579 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4760 + 68] = mem[_4760 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4760 + -mem[64] + 100
                                            else:
                                                if 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _2756 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_2756] = 26
                                                mem[_2756 + 32] = 'SafeMath: division by zero'
                                                if not ext_call.return_data[0]:
                                                    _2880 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _2880 + 68] = mem[idx + _2756 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_2880 + 68] = mem[_2880 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _2880 + -mem[64] + 100
                                                if (10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                _3373 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_3373] = 26
                                                mem[_3373 + 32] = 'SafeMath: division by zero'
                                                if not devFundDivRate:
                                                    _3533 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _3533 + 68] = mem[idx + _3373 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_3533 + 68] = mem[_3533 + 74 len 26]
                                                    revert with memory
                                                      from mem[64]
                                                       len _3533 + -mem[64] + 100
                                                if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate:
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, 0
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4578 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4578] = 26
                                                    mem[_4578 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4757 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4757 + 68] = mem[idx + _4578 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4757 + 68] = mem[_4757 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4757 + -mem[64] + 100
                                                else:
                                                    if devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate != devMultiplier:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require ext_code.size(mmAddress)
                                                    call mmAddress.mint(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args devaddr, devMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4676 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4676] = 26
                                                    mem[_4676 + 32] = 'SafeMath: division by zero'
                                                    if not treasuryDivRate:
                                                        _4821 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _4821 + 68] = mem[idx + _4676 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_4821 + 68] = mem[_4821 + 74 len 26]
                                                        revert with memory
                                                          from mem[64]
                                                           len _4821 + -mem[64] + 100
                                            ('stor', ('name', 'treasuryDivRate', 5))
                                            if not (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate:
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, 0
                                            else:
                                                if treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate / (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate != treasuryMultiplier:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require ext_code.size(mmAddress)
                                                call mmAddress.mint(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args treasuryAddr, treasuryMultiplier * (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint / treasuryDivRate
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(mmAddress)
                                            call mmAddress.mint(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * mmPerBlock * poolInfo[idx].field_256) + (9 * bonusEndBlock * mmPerBlock * poolInfo[idx].field_256) - (10 * poolInfo[idx].field_512 * mmPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
    require arg1 < poolInfo.length
    if poolInfo[arg1].field_256 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow'
    if arg2 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = arg2 + totalAllocPoint - poolInfo[arg1].field_256
    require arg1 < poolInfo.length
    poolInfo[arg1].field_256 = arg2
}



}
