contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#
const totalSupply = 100 * 10^18


address owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
array of address stor5;
uint256 stor6;
uint256 totalFees;
array of uint256 name;
array of uint256 symbol;
uint8 decimals;

function name() payable {
    return name[0 len name.length]
}

function totalFees() payable {
    return totalFees
}

function decimals() payable {
    return decimals
}

function owner() payable {
    return owner
}

function symbol() payable {
    return symbol[0 len symbol.length]
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor4[address(arg1)])
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return allowance[address(arg1)][address(arg2)]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x734f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        if stor5[idx] != arg1:
            idx = idx + 1
            continue 
        require stor5.length - 1 < stor5.length
        require idx < stor5.length
        stor5[idx] = stor5[stor5.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        require stor5.length
        stor5[stor5.length] = 0
        stor5.length--
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 > allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 
                    32,
                    37,
                    0x6e45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572,
                    mem[165 len 27],
                    mem[219 len 5]
    if not msg.sender:
        revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[296 len 28]
    if not arg1:
        revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[294 len 30]
    allowance[address(msg.sender)][address(arg1)] -= arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if allowance[address(msg.sender)][address(arg1)] + arg2 < allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] += arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor6:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                    mem[206 len 22]
    idx = 0
    s = 100 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _77 = mem[64]
            mem[64] = mem[64] + 64
            mem[_77] = 26
            mem[_77 + 32] = 'SafeMath: division by zero'
            _95 = mem[64]
            mem[64] = mem[64] + 64
            mem[_95] = 26
            mem[_95 + 32] = 'SafeMath: division by zero'
            if stor6 / 100 * 10^18 > 0:
                require stor6 / 100 * 10^18
                return (arg1 / stor6 / 100 * 10^18)
            _101 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_101 + idx + 68] = mem[_95 + idx + 32]
                idx = idx + 32
                continue 
            mem[_101 + 68] = mem[_101 + 74 len 26]
            revert with memory
              from mem[64]
               len _101 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _81 = mem[64]
            mem[64] = mem[64] + 64
            mem[_81] = 26
            mem[_81 + 32] = 'SafeMath: division by zero'
            _107 = mem[64]
            mem[64] = mem[64] + 64
            mem[_107] = 26
            mem[_107 + 32] = 'SafeMath: division by zero'
            if stor6 / 100 * 10^18 > 0:
                require stor6 / 100 * 10^18
                return (arg1 / stor6 / 100 * 10^18)
            _113 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_113 + idx + 68] = mem[_107 + idx + 32]
                idx = idx + 32
                continue 
            mem[_113 + 68] = mem[_113 + 74 len 26]
            revert with memory
              from mem[64]
               len _113 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 1
        _80 = mem[64]
        mem[64] = mem[64] + 64
        mem[_80] = 30
        mem[_80 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _82 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_82 + idx + 68] = mem[_80 + idx + 32]
                idx = idx + 32
                continue 
            mem[_82 + 68] = mem[_82 + 70 len 30]
            revert with memory
              from mem[64]
               len _82 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        _96 = mem[64]
        mem[64] = mem[64] + 64
        mem[_96] = 30
        mem[_96 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _104 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_104 + idx + 68] = mem[_96 + idx + 32]
            idx = idx + 32
            continue 
        mem[_104 + 68] = mem[_104 + 70 len 30]
        revert with memory
          from mem[64]
           len _104 + -mem[64] + 100
    if t < stor6 / 100 * 10^18:
        if stor6 / 100 * 10^18 <= 0:
            revert with 0, 'SafeMath: division by zero'
        if stor6 / 100 * 10^18:
            return (arg1 / stor6 / 100 * 10^18)
    else:
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        if s:
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero'
            if t / s:
                return (arg1 / t / s)
    revert
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor6:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                    mem[206 len 22]
    idx = 0
    s = 100 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _82 = mem[64]
            mem[64] = mem[64] + 64
            mem[_82] = 26
            mem[_82 + 32] = 'SafeMath: division by zero'
            _100 = mem[64]
            mem[64] = mem[64] + 64
            mem[_100] = 26
            mem[_100 + 32] = 'SafeMath: division by zero'
            if stor6 / 100 * 10^18 > 0:
                require stor6 / 100 * 10^18
                return (stor1[address(arg1)] / stor6 / 100 * 10^18)
            _106 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_106 + idx + 68] = mem[_100 + idx + 32]
                idx = idx + 32
                continue 
            mem[_106 + 68] = mem[_106 + 74 len 26]
            revert with memory
              from mem[64]
               len _106 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _86 = mem[64]
            mem[64] = mem[64] + 64
            mem[_86] = 26
            mem[_86 + 32] = 'SafeMath: division by zero'
            _112 = mem[64]
            mem[64] = mem[64] + 64
            mem[_112] = 26
            mem[_112 + 32] = 'SafeMath: division by zero'
            if stor6 / 100 * 10^18 > 0:
                require stor6 / 100 * 10^18
                return (stor1[address(arg1)] / stor6 / 100 * 10^18)
            _118 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_118 + idx + 68] = mem[_112 + idx + 32]
                idx = idx + 32
                continue 
            mem[_118 + 68] = mem[_118 + 74 len 26]
            revert with memory
              from mem[64]
               len _118 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 1
        _85 = mem[64]
        mem[64] = mem[64] + 64
        mem[_85] = 30
        mem[_85 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _87 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_87 + idx + 68] = mem[_85 + idx + 32]
                idx = idx + 32
                continue 
            mem[_87 + 68] = mem[_87 + 70 len 30]
            revert with memory
              from mem[64]
               len _87 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        _101 = mem[64]
        mem[64] = mem[64] + 64
        mem[_101] = 30
        mem[_101 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _109 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_109 + idx + 68] = mem[_101 + idx + 32]
            idx = idx + 32
            continue 
        mem[_109 + 68] = mem[_109 + 70 len 30]
        revert with memory
          from mem[64]
           len _109 + -mem[64] + 100
    if t < stor6 / 100 * 10^18:
        if stor6 / 100 * 10^18 <= 0:
            revert with 0, 'SafeMath: division by zero'
        if stor6 / 100 * 10^18:
            return (stor1[address(arg1)] / stor6 / 100 * 10^18)
    else:
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        if s:
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero'
            if t / s:
                return (stor1[address(arg1)] / t / s)
    revert
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor1[address(arg1)] > 0:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor6:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        42,
                        0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                        mem[206 len 22]
        idx = 0
        s = 100 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _90 = mem[64]
                mem[64] = mem[64] + 64
                mem[_90] = 26
                mem[_90 + 32] = 'SafeMath: division by zero'
                _108 = mem[64]
                mem[64] = mem[64] + 64
                mem[_108] = 26
                mem[_108 + 32] = 'SafeMath: division by zero'
                if stor6 / 100 * 10^18 > 0:
                    require stor6 / 100 * 10^18
                    stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 100 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor5[stor5.length] = arg1
                _114 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_114 + idx + 68] = mem[_108 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_114 + 68] = mem[_114 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _114 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _94 = mem[64]
                mem[64] = mem[64] + 64
                mem[_94] = 26
                mem[_94 + 32] = 'SafeMath: division by zero'
                _120 = mem[64]
                mem[64] = mem[64] + 64
                mem[_120] = 26
                mem[_120 + 32] = 'SafeMath: division by zero'
                if stor6 / 100 * 10^18 > 0:
                    require stor6 / 100 * 10^18
                    stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 100 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor5[stor5.length] = arg1
                _126 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_126 + idx + 68] = mem[_120 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_126 + 68] = mem[_126 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _126 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 1
            _93 = mem[64]
            mem[64] = mem[64] + 64
            mem[_93] = 30
            mem[_93 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _95 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_95 + idx + 68] = mem[_93 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_95 + 68] = mem[_95 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _95 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            _109 = mem[64]
            mem[64] = mem[64] + 64
            mem[_109] = 30
            mem[_109 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _117 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_117 + idx + 68] = mem[_109 + idx + 32]
                idx = idx + 32
                continue 
            mem[_117 + 68] = mem[_117 + 70 len 30]
            revert with memory
              from mem[64]
               len _117 + -mem[64] + 100
        if t < stor6 / 100 * 10^18:
            if stor6 / 100 * 10^18 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require stor6 / 100 * 10^18
            stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 100 * 10^18
        else:
            if s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require s
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require t / s
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
    stor4[address(arg1)] = 1
    stor5.length++
    stor5[stor5.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    if arg1 > 100 * 10^18:
        revert with 0, 'Amount must be less than supply'
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    mem[64] = 224
    mem[160] = 30
    mem[192] = 'SafeMath: subtraction overflow'
    if arg1 / 100 > arg1:
        revert with 0, 'SafeMath: subtraction overflow'
    if arg2:
        idx = 0
        s = 100 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _409 = mem[64]
                mem[64] = mem[64] + 64
                mem[_409] = 26
                mem[_409 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 / 100:
                        return 0
                    require arg1 / 100
                    if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _502 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_502] = 30
                    mem[_502 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 / 100 * stor6 / 100 * 10^18 <= 0:
                        return (-1 * arg1 / 100 * stor6 / 100 * 10^18)
                    _525 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_525 + idx + 68] = mem[_502 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_525 + 68] = mem[_525 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _525 + -mem[64] + 100
                require arg1
                if arg1 * stor6 / 100 * 10^18 / arg1 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not arg1 / 100:
                    _501 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_501] = 30
                    mem[_501 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 100 * 10^18:
                        return (arg1 * stor6 / 100 * 10^18)
                    _522 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_522 + idx + 68] = mem[_501 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_522 + 68] = mem[_522 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _522 + -mem[64] + 100
                require arg1 / 100
                if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _521 = mem[64]
                mem[64] = mem[64] + 64
                mem[_521] = 30
                mem[_521 + 32] = 'SafeMath: subtraction overflow'
                if arg1 / 100 * stor6 / 100 * 10^18 <= arg1 * stor6 / 100 * 10^18:
                    return ((arg1 * stor6 / 100 * 10^18) - (arg1 / 100 * stor6 / 100 * 10^18))
                _553 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_553 + idx + 68] = mem[_521 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_553 + 68] = mem[_553 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _553 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _417 = mem[64]
                mem[64] = mem[64] + 64
                mem[_417] = 26
                mem[_417 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 / 100:
                        return 0
                    require arg1 / 100
                    if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _529 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_529] = 30
                    mem[_529 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 / 100 * stor6 / 100 * 10^18 <= 0:
                        return (-1 * arg1 / 100 * stor6 / 100 * 10^18)
                    _562 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_562 + idx + 68] = mem[_529 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_562 + 68] = mem[_562 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _562 + -mem[64] + 100
                require arg1
                if arg1 * stor6 / 100 * 10^18 / arg1 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not arg1 / 100:
                    _528 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_528] = 30
                    mem[_528 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 100 * 10^18:
                        return (arg1 * stor6 / 100 * 10^18)
                    _559 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_559 + idx + 68] = mem[_528 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_559 + 68] = mem[_559 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _559 + -mem[64] + 100
                require arg1 / 100
                if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _558 = mem[64]
                mem[64] = mem[64] + 64
                mem[_558] = 30
                mem[_558 + 32] = 'SafeMath: subtraction overflow'
                if arg1 / 100 * stor6 / 100 * 10^18 <= arg1 * stor6 / 100 * 10^18:
                    return ((arg1 * stor6 / 100 * 10^18) - (arg1 / 100 * stor6 / 100 * 10^18))
                _608 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_608 + idx + 68] = mem[_558 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_608 + 68] = mem[_608 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _608 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 1
            _415 = mem[64]
            mem[64] = mem[64] + 64
            mem[_415] = 30
            mem[_415 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _419 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_419 + idx + 68] = mem[_415 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_419 + 68] = mem[_419 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _419 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            _445 = mem[64]
            mem[64] = mem[64] + 64
            mem[_445] = 30
            mem[_445 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _453 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_453 + idx + 68] = mem[_445 + idx + 32]
                idx = idx + 32
                continue 
            mem[_453 + 68] = mem[_453 + 70 len 30]
            revert with memory
              from mem[64]
               len _453 + -mem[64] + 100
        _393 = mem[64]
        mem[64] = mem[64] + 64
        mem[_393] = 26
        mem[_393 + 32] = 'SafeMath: division by zero'
        if t < stor6 / 100 * 10^18:
            _426 = mem[64]
            mem[64] = mem[64] + 64
            mem[_426] = 26
            mem[_426 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not arg1 / 100:
                    return 0
                require arg1 / 100
                if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if arg1 / 100 * stor6 / 100 * 10^18 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (-1 * arg1 / 100 * stor6 / 100 * 10^18)
            require arg1
            if arg1 * stor6 / 100 * 10^18 / arg1 != stor6 / 100 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not arg1 / 100:
                if 0 > arg1 * stor6 / 100 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (arg1 * stor6 / 100 * 10^18)
            require arg1 / 100
            if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if arg1 / 100 * stor6 / 100 * 10^18 > arg1 * stor6 / 100 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((arg1 * stor6 / 100 * 10^18) - (arg1 / 100 * stor6 / 100 * 10^18))
        _425 = mem[64]
        mem[64] = mem[64] + 64
        mem[_425] = 26
        mem[_425 + 32] = 'SafeMath: division by zero'
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        require s
        if not arg1:
            if not arg1 / 100:
                return 0
            require arg1 / 100
            if arg1 / 100 * t / s / arg1 / 100 != t / s:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if arg1 / 100 * t / s > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return (-1 * arg1 / 100 * t / s)
        require arg1
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not arg1 / 100:
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow'
            return (arg1 * t / s)
        require arg1 / 100
        if arg1 / 100 * t / s / arg1 / 100 != t / s:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if arg1 / 100 * t / s > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((arg1 * t / s) - (arg1 / 100 * t / s))
    idx = 0
    s = 100 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _412 = mem[64]
            mem[64] = mem[64] + 64
            mem[_412] = 26
            mem[_412 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not arg1 / 100:
                    return 0
                require arg1 / 100
                if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _505 = mem[64]
                mem[64] = mem[64] + 64
                mem[_505] = 30
                mem[_505 + 32] = 'SafeMath: subtraction overflow'
                if arg1 / 100 * stor6 / 100 * 10^18 <= 0:
                    return 0
                _536 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_536 + idx + 68] = mem[_505 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_536 + 68] = mem[_536 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _536 + -mem[64] + 100
            require arg1
            if arg1 * stor6 / 100 * 10^18 / arg1 != stor6 / 100 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not arg1 / 100:
                _504 = mem[64]
                mem[64] = mem[64] + 64
                mem[_504] = 30
                mem[_504 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 100 * 10^18:
                    return (arg1 * stor6 / 100 * 10^18)
                _533 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_533 + idx + 68] = mem[_504 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_533 + 68] = mem[_533 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _533 + -mem[64] + 100
            require arg1 / 100
            if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _532 = mem[64]
            mem[64] = mem[64] + 64
            mem[_532] = 30
            mem[_532 + 32] = 'SafeMath: subtraction overflow'
            if arg1 / 100 * stor6 / 100 * 10^18 <= arg1 * stor6 / 100 * 10^18:
                return (arg1 * stor6 / 100 * 10^18)
            _569 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_569 + idx + 68] = mem[_532 + idx + 32]
                idx = idx + 32
                continue 
            mem[_569 + 68] = mem[_569 + 70 len 30]
            revert with memory
              from mem[64]
               len _569 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _418 = mem[64]
            mem[64] = mem[64] + 64
            mem[_418] = 26
            mem[_418 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not arg1 / 100:
                    return 0
                require arg1 / 100
                if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _540 = mem[64]
                mem[64] = mem[64] + 64
                mem[_540] = 30
                mem[_540 + 32] = 'SafeMath: subtraction overflow'
                if arg1 / 100 * stor6 / 100 * 10^18 <= 0:
                    return 0
                _578 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_578 + idx + 68] = mem[_540 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_578 + 68] = mem[_578 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _578 + -mem[64] + 100
            require arg1
            if arg1 * stor6 / 100 * 10^18 / arg1 != stor6 / 100 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not arg1 / 100:
                _539 = mem[64]
                mem[64] = mem[64] + 64
                mem[_539] = 30
                mem[_539 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 100 * 10^18:
                    return (arg1 * stor6 / 100 * 10^18)
                _575 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_575 + idx + 68] = mem[_539 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_575 + 68] = mem[_575 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _575 + -mem[64] + 100
            require arg1 / 100
            if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _574 = mem[64]
            mem[64] = mem[64] + 64
            mem[_574] = 30
            mem[_574 + 32] = 'SafeMath: subtraction overflow'
            if arg1 / 100 * stor6 / 100 * 10^18 <= arg1 * stor6 / 100 * 10^18:
                return (arg1 * stor6 / 100 * 10^18)
            _632 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_632 + idx + 68] = mem[_574 + idx + 32]
                idx = idx + 32
                continue 
            mem[_632 + 68] = mem[_632 + 70 len 30]
            revert with memory
              from mem[64]
               len _632 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 1
        _416 = mem[64]
        mem[64] = mem[64] + 64
        mem[_416] = 30
        mem[_416 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _422 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_422 + idx + 68] = mem[_416 + idx + 32]
                idx = idx + 32
                continue 
            mem[_422 + 68] = mem[_422 + 70 len 30]
            revert with memory
              from mem[64]
               len _422 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        _447 = mem[64]
        mem[64] = mem[64] + 64
        mem[_447] = 30
        mem[_447 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _458 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_458 + idx + 68] = mem[_447 + idx + 32]
            idx = idx + 32
            continue 
        mem[_458 + 68] = mem[_458 + 70 len 30]
        revert with memory
          from mem[64]
           len _458 + -mem[64] + 100
    _398 = mem[64]
    mem[64] = mem[64] + 64
    mem[_398] = 26
    mem[_398 + 32] = 'SafeMath: division by zero'
    if t < stor6 / 100 * 10^18:
        _428 = mem[64]
        mem[64] = mem[64] + 64
        mem[_428] = 26
        mem[_428 + 32] = 'SafeMath: division by zero'
        if not arg1:
            if arg1 / 100:
                require arg1 / 100
                if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if arg1 / 100 * stor6 / 100 * 10^18 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                else:
                    return 0
            else:
                return 0
        require arg1
        if arg1 * stor6 / 100 * 10^18 / arg1 != stor6 / 100 * 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not arg1 / 100:
            if 0 > arg1 * stor6 / 100 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
        else:
            require arg1 / 100
            if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if arg1 / 100 * stor6 / 100 * 10^18 > arg1 * stor6 / 100 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
        return (arg1 * stor6 / 100 * 10^18)
    _427 = mem[64]
    mem[64] = mem[64] + 64
    mem[_427] = 26
    mem[_427 + 32] = 'SafeMath: division by zero'
    if s <= 0:
        revert with 0, 'SafeMath: division by zero'
    require s
    if not arg1:
        if arg1 / 100:
            require arg1 / 100
            if arg1 / 100 * t / s / arg1 / 100 != t / s:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if arg1 / 100 * t / s > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            else:
                return 0
        else:
            return 0
    require arg1
    if arg1 * t / s / arg1 != t / s:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
    if not arg1 / 100:
        if 0 > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow'
    else:
        require arg1 / 100
        if arg1 / 100 * t / s / arg1 / 100 != t / s:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if arg1 / 100 * t / s > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow'
    return (arg1 * t / s)
}

function reflect(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[0] = msg.sender
    mem[32] = 4
    if stor4[address(msg.sender)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    44,
                    0x734578636c75646564206164647265737365732063616e6e6f742063616c6c20746869732066756e6374696f,
                    mem[208 len 20]
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    mem[64] = 224
    mem[160] = 30
    mem[192] = 'SafeMath: subtraction overflow'
    if arg1 / 100 > arg1:
        revert with 0, 'SafeMath: subtraction overflow'
    idx = 0
    s = 100 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _495 = mem[64]
            mem[64] = mem[64] + 64
            mem[_495] = 26
            mem[_495 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not arg1 / 100:
                    _536 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_536] = 30
                    mem[_536 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 1
                    _586 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_586] = 30
                    mem[_586 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _616 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_616 + idx + 68] = mem[_586 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_616 + 68] = mem[_616 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _616 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _679 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_679] = 30
                    mem[_679 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _725 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_725 + idx + 68] = mem[_679 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_725 + 68] = mem[_725 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _725 + -mem[64] + 100
                require arg1 / 100
                if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _542 = mem[64]
                mem[64] = mem[64] + 64
                mem[_542] = 30
                mem[_542 + 32] = 'SafeMath: subtraction overflow'
                if arg1 / 100 * stor6 / 100 * 10^18 > 0:
                    _556 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_556 + idx + 68] = mem[_542 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_556 + 68] = mem[_556 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _556 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _615 = mem[64]
                mem[64] = mem[64] + 64
                mem[_615] = 30
                mem[_615 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _657 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_657 + idx + 68] = mem[_615 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_657 + 68] = mem[_657 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _657 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _722 = mem[64]
                mem[64] = mem[64] + 64
                mem[_722] = 30
                mem[_722 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor6:
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _773 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_773 + idx + 68] = mem[_722 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_773 + 68] = mem[_773 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _773 + -mem[64] + 100
            require arg1
            if arg1 * stor6 / 100 * 10^18 / arg1 != stor6 / 100 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not arg1 / 100:
                _541 = mem[64]
                mem[64] = mem[64] + 64
                mem[_541] = 30
                mem[_541 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor6 / 100 * 10^18:
                    _553 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_553 + idx + 68] = mem[_541 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_553 + 68] = mem[_553 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _553 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _614 = mem[64]
                mem[64] = mem[64] + 64
                mem[_614] = 30
                mem[_614 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                    _654 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_654 + idx + 68] = mem[_614 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_654 + 68] = mem[_654 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _654 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100 * 10^18
                _719 = mem[64]
                mem[64] = mem[64] + 64
                mem[_719] = 30
                mem[_719 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100 * 10^18 <= stor6:
                    stor6 += -1 * arg1 * stor6 / 100 * 10^18
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _770 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_770 + idx + 68] = mem[_719 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_770 + 68] = mem[_770 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _770 + -mem[64] + 100
            require arg1 / 100
            if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _552 = mem[64]
            mem[64] = mem[64] + 64
            mem[_552] = 30
            mem[_552 + 32] = 'SafeMath: subtraction overflow'
            if arg1 / 100 * stor6 / 100 * 10^18 > arg1 * stor6 / 100 * 10^18:
                _569 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_569 + idx + 68] = mem[_552 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_569 + 68] = mem[_569 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _569 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            _653 = mem[64]
            mem[64] = mem[64] + 64
            mem[_653] = 30
            mem[_653 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                _698 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_698 + idx + 68] = mem[_653 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_698 + 68] = mem[_698 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _698 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100 * 10^18
            _767 = mem[64]
            mem[64] = mem[64] + 64
            mem[_767] = 30
            mem[_767 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100 * 10^18 <= stor6:
                stor6 += -1 * arg1 * stor6 / 100 * 10^18
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _827 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_827 + idx + 68] = mem[_767 + idx + 32]
                idx = idx + 32
                continue 
            mem[_827 + 68] = mem[_827 + 70 len 30]
            revert with memory
              from mem[64]
               len _827 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] <= s:
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 1
            _498 = mem[64]
            mem[64] = mem[64] + 64
            mem[_498] = 30
            mem[_498 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _500 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_500 + idx + 68] = mem[_498 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_500 + 68] = mem[_500 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _500 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            _513 = mem[64]
            mem[64] = mem[64] + 64
            mem[_513] = 30
            mem[_513 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _518 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_518 + idx + 68] = mem[_513 + idx + 32]
                idx = idx + 32
                continue 
            mem[_518 + 68] = mem[_518 + 70 len 30]
            revert with memory
              from mem[64]
               len _518 + -mem[64] + 100
        _499 = mem[64]
        mem[64] = mem[64] + 64
        mem[_499] = 26
        mem[_499 + 32] = 'SafeMath: division by zero'
        if not arg1:
            if not arg1 / 100:
                _543 = mem[64]
                mem[64] = mem[64] + 64
                mem[_543] = 30
                mem[_543 + 32] = 'SafeMath: subtraction overflow'
                mem[0] = msg.sender
                mem[32] = 1
                _623 = mem[64]
                mem[64] = mem[64] + 64
                mem[_623] = 30
                mem[_623 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _666 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_666 + idx + 68] = mem[_623 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_666 + 68] = mem[_666 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _666 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _728 = mem[64]
                mem[64] = mem[64] + 64
                mem[_728] = 30
                mem[_728 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor6:
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _783 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_783 + idx + 68] = mem[_728 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_783 + 68] = mem[_783 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _783 + -mem[64] + 100
            require arg1 / 100
            if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _560 = mem[64]
            mem[64] = mem[64] + 64
            mem[_560] = 30
            mem[_560 + 32] = 'SafeMath: subtraction overflow'
            if arg1 / 100 * stor6 / 100 * 10^18 > 0:
                _579 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_579 + idx + 68] = mem[_560 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_579 + 68] = mem[_579 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _579 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            _665 = mem[64]
            mem[64] = mem[64] + 64
            mem[_665] = 30
            mem[_665 + 32] = 'SafeMath: subtraction overflow'
            if 0 > stor1[address(msg.sender)]:
                _710 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_710 + idx + 68] = mem[_665 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_710 + 68] = mem[_710 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _710 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            _780 = mem[64]
            mem[64] = mem[64] + 64
            mem[_780] = 30
            mem[_780 + 32] = 'SafeMath: subtraction overflow'
            if 0 <= stor6:
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _841 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_841 + idx + 68] = mem[_780 + idx + 32]
                idx = idx + 32
                continue 
            mem[_841 + 68] = mem[_841 + 70 len 30]
            revert with memory
              from mem[64]
               len _841 + -mem[64] + 100
        require arg1
        if arg1 * stor6 / 100 * 10^18 / arg1 != stor6 / 100 * 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not arg1 / 100:
            _559 = mem[64]
            mem[64] = mem[64] + 64
            mem[_559] = 30
            mem[_559 + 32] = 'SafeMath: subtraction overflow'
            if 0 > arg1 * stor6 / 100 * 10^18:
                _576 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_576 + idx + 68] = mem[_559 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_576 + 68] = mem[_576 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _576 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            _664 = mem[64]
            mem[64] = mem[64] + 64
            mem[_664] = 30
            mem[_664 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                _707 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_707 + idx + 68] = mem[_664 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_707 + 68] = mem[_707 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _707 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100 * 10^18
            _777 = mem[64]
            mem[64] = mem[64] + 64
            mem[_777] = 30
            mem[_777 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100 * 10^18 <= stor6:
                stor6 += -1 * arg1 * stor6 / 100 * 10^18
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _838 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_838 + idx + 68] = mem[_777 + idx + 32]
                idx = idx + 32
                continue 
            mem[_838 + 68] = mem[_838 + 70 len 30]
            revert with memory
              from mem[64]
               len _838 + -mem[64] + 100
        require arg1 / 100
        if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _575 = mem[64]
        mem[64] = mem[64] + 64
        mem[_575] = 30
        mem[_575 + 32] = 'SafeMath: subtraction overflow'
        if arg1 / 100 * stor6 / 100 * 10^18 > arg1 * stor6 / 100 * 10^18:
            _606 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_606 + idx + 68] = mem[_575 + idx + 32]
                idx = idx + 32
                continue 
            mem[_606 + 68] = mem[_606 + 70 len 30]
            revert with memory
              from mem[64]
               len _606 + -mem[64] + 100
        mem[0] = msg.sender
        mem[32] = 1
        _706 = mem[64]
        mem[64] = mem[64] + 64
        mem[_706] = 30
        mem[_706 + 32] = 'SafeMath: subtraction overflow'
        if arg1 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
            _753 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_753 + idx + 68] = mem[_706 + idx + 32]
                idx = idx + 32
                continue 
            mem[_753 + 68] = mem[_753 + 70 len 30]
            revert with memory
              from mem[64]
               len _753 + -mem[64] + 100
        mem[0] = msg.sender
        mem[32] = 1
        stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100 * 10^18
        _835 = mem[64]
        mem[64] = mem[64] + 64
        mem[_835] = 30
        mem[_835 + 32] = 'SafeMath: subtraction overflow'
        if arg1 * stor6 / 100 * 10^18 <= stor6:
            stor6 += -1 * arg1 * stor6 / 100 * 10^18
            if totalFees + arg1 < totalFees:
                revert with 0, 'SafeMath: addition overflow'
            totalFees += arg1
        _887 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_887 + idx + 68] = mem[_835 + idx + 32]
            idx = idx + 32
            continue 
        mem[_887 + 68] = mem[_887 + 70 len 30]
        revert with memory
          from mem[64]
           len _887 + -mem[64] + 100
    _487 = mem[64]
    mem[64] = mem[64] + 64
    mem[_487] = 26
    mem[_487 + 32] = 'SafeMath: division by zero'
    if t < stor6 / 100 * 10^18:
        _504 = mem[64]
        mem[64] = mem[64] + 64
        mem[_504] = 26
        mem[_504 + 32] = 'SafeMath: division by zero'
        if not arg1:
            if arg1 / 100:
                require arg1 / 100
                if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if arg1 / 100 * stor6 / 100 * 10^18 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
            if 0 > stor1[address(msg.sender)]:
                revert with 0, 'SafeMath: subtraction overflow'
            if 0 > stor6:
                revert with 0, 'SafeMath: subtraction overflow'
        else:
            require arg1
            if arg1 * stor6 / 100 * 10^18 / arg1 != stor6 / 100 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not arg1 / 100:
                if 0 > arg1 * stor6 / 100 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require arg1 / 100
                if arg1 / 100 * stor6 / 100 * 10^18 / arg1 / 100 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if arg1 / 100 * stor6 / 100 * 10^18 > arg1 * stor6 / 100 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                revert with 0, 'SafeMath: subtraction overflow'
            stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100 * 10^18
            if arg1 * stor6 / 100 * 10^18 > stor6:
                revert with 0, 'SafeMath: subtraction overflow'
            stor6 += -1 * arg1 * stor6 / 100 * 10^18
    else:
        _503 = mem[64]
        mem[64] = mem[64] + 64
        mem[_503] = 26
        mem[_503 + 32] = 'SafeMath: division by zero'
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        require s
        if not arg1:
            if arg1 / 100:
                require arg1 / 100
                if arg1 / 100 * t / s / arg1 / 100 != t / s:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if arg1 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
            if 0 > stor1[address(msg.sender)]:
                revert with 0, 'SafeMath: subtraction overflow'
            if 0 > stor6:
                revert with 0, 'SafeMath: subtraction overflow'
        else:
            require arg1
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not arg1 / 100:
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require arg1 / 100
                if arg1 / 100 * t / s / arg1 / 100 != t / s:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if arg1 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow'
            if arg1 * t / s > stor1[address(msg.sender)]:
                revert with 0, 'SafeMath: subtraction overflow'
            stor1[address(msg.sender)] += -1 * arg1 * t / s
            if arg1 * t / s > stor6:
                revert with 0, 'SafeMath: subtraction overflow'
            stor6 += -1 * arg1 * t / s
    if totalFees + arg1 < totalFees:
        revert with 0, 'SafeMath: addition overflow'
    totalFees += arg1
}

function transfer(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x6f45524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,
                    mem[201 len 27]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,
                    mem[199 len 29]
    if arg2 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    41,
                    0x655472616e7366657220616d6f756e74206d7573742062652067726561746572207468616e207a6572,
                    mem[205 len 23]
    if not stor4[address(msg.sender)]:
        if stor4[address(msg.sender)]:
            if stor4[address(msg.sender)]:
                mem[0] = msg.sender
                mem[32] = 4
                if not stor4[address(msg.sender)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = 100 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _21306 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21306] = 26
                            mem[_21306 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    _22577 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22577] = 30
                                    mem[_22577 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _24007 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24007] = 30
                                    mem[_24007 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _24937 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24937 + idx + 68] = mem[_24007 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24937 + 68] = mem[_24937 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24937 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _29885 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29885] = 30
                                    mem[_29885 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _31495 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_31495 + idx + 68] = mem[_29885 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31495 + 68] = mem[_31495 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31495 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _22733 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22733] = 30
                                mem[_22733 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    _23017 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23017 + idx + 68] = mem[_22733 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23017 + 68] = mem[_23017 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23017 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _24936 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24936] = 30
                                mem[_24936 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _25908 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_25908 + idx + 68] = mem[_24936 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25908 + 68] = mem[_25908 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _25908 + -mem[64] + 100
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                _31494 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31494] = 30
                                mem[_31494 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _32986 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_32986 + idx + 68] = mem[_31494 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32986 + 68] = mem[_32986 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _32986 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                _22732 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22732] = 30
                                mem[_22732 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    _23014 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23014 + idx + 68] = mem[_22732 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23014 + 68] = mem[_23014 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23014 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _24935 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24935] = 30
                                mem[_24935 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _25905 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_25905 + idx + 68] = mem[_24935 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25905 + 68] = mem[_25905 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _25905 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                _31493 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31493] = 30
                                mem[_31493 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _32983 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_32983 + idx + 68] = mem[_31493 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32983 + 68] = mem[_32983 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _32983 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23013 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23013] = 30
                            mem[_23013 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                _23480 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23480 + idx + 68] = mem[_23013 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23480 + 68] = mem[_23480 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23480 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _25904 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25904] = 30
                            mem[_25904 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _27188 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_27188 + idx + 68] = mem[_25904 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27188 + 68] = mem[_27188 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _27188 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                            _32982 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32982] = 30
                            mem[_32982 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _34287 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_34287 + idx + 68] = mem[_32982 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_34287 + 68] = mem[_34287 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _34287 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _21399 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21399] = 30
                            mem[_21399 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _21461 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_21461 + idx + 68] = mem[_21399 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21461 + 68] = mem[_21461 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _21461 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _21864 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21864] = 30
                            mem[_21864 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _21959 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_21959 + idx + 68] = mem[_21864 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_21959 + 68] = mem[_21959 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _21959 + -mem[64] + 100
                        _21430 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21430] = 26
                        mem[_21430 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not arg2 / 100:
                                _22734 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22734] = 30
                                mem[_22734 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _24944 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24944] = 30
                                mem[_24944 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _25918 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_25918 + idx + 68] = mem[_24944 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25918 + 68] = mem[_25918 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _25918 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _31502 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31502] = 30
                                mem[_31502 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _32993 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_32993 + idx + 68] = mem[_31502 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32993 + 68] = mem[_32993 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _32993 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23021 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23021] = 30
                            mem[_23021 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                _23490 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23490 + idx + 68] = mem[_23021 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23490 + 68] = mem[_23490 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23490 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _25917 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25917] = 30
                            mem[_25917 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _27204 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_27204 + idx + 68] = mem[_25917 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27204 + 68] = mem[_27204 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _27204 + -mem[64] + 100
                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            _32992 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32992] = 30
                            mem[_32992 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _34299 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_34299 + idx + 68] = mem[_32992 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_34299 + 68] = mem[_34299 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _34299 + -mem[64] + 100
                        require arg2
                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not arg2 / 100:
                            _23020 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23020] = 30
                            mem[_23020 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100 * 10^18:
                                _23487 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23487 + idx + 68] = mem[_23020 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23487 + 68] = mem[_23487 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23487 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _25916 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25916] = 30
                            mem[_25916 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _27201 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_27201 + idx + 68] = mem[_25916 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27201 + 68] = mem[_27201 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _27201 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                            _32991 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32991] = 30
                            mem[_32991 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _34296 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_34296 + idx + 68] = mem[_32991 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_34296 + 68] = mem[_34296 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _34296 + -mem[64] + 100
                        require arg2 / 100
                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _23486 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23486] = 30
                        mem[_23486 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                            _24177 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_24177 + idx + 68] = mem[_23486 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24177 + 68] = mem[_24177 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _24177 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _27200 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27200] = 30
                        mem[_27200 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                            _28689 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_28689 + idx + 68] = mem[_27200 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_28689 + 68] = mem[_28689 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _28689 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                        _34295 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34295] = 30
                        mem[_34295 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            if totalFees + (arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100
                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                            return 1
                        _35609 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_35609 + idx + 68] = mem[_34295 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_35609 + 68] = mem[_35609 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _35609 + -mem[64] + 100
                    _21058 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21058] = 26
                    mem[_21058 + 32] = 'SafeMath: division by zero'
                    if t < stor6 / 100 * 10^18:
                        _21555 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21555] = 26
                        mem[_21555 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        else:
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                    else:
                        _21554 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21554] = 26
                        mem[_21554 + 32] = 'SafeMath: division by zero'
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require s
                        if not arg2:
                            if not arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                if arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * t / s
                        else:
                            require arg2
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                if arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * t / s
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not stor4[address(arg1)]:
                        idx = 0
                        s = 100 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _21309 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21309] = 26
                                mem[_21309 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22578 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22578] = 30
                                        mem[_22578 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _24012 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24012] = 30
                                        mem[_24012 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _24949 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_24949 + idx + 68] = mem[_24012 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24949 + 68] = mem[_24949 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _24949 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _29899 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29899] = 30
                                        mem[_29899 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _31516 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31516 + idx + 68] = mem[_29899 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31516 + 68] = mem[_31516 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31516 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _22736 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22736] = 30
                                    mem[_22736 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23028 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23028 + idx + 68] = mem[_22736 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23028 + 68] = mem[_23028 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23028 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _24948 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24948] = 30
                                    mem[_24948 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _25935 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_25935 + idx + 68] = mem[_24948 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25935 + 68] = mem[_25935 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _25935 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _31515 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31515] = 30
                                    mem[_31515 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33010 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33010 + idx + 68] = mem[_31515 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33010 + 68] = mem[_33010 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33010 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _22735 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22735] = 30
                                    mem[_22735 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23025 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23025 + idx + 68] = mem[_22735 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23025 + 68] = mem[_23025 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23025 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _24947 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24947] = 30
                                    mem[_24947 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _25932 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_25932 + idx + 68] = mem[_24947 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25932 + 68] = mem[_25932 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _25932 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _31514 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31514] = 30
                                    mem[_31514 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33007 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33007 + idx + 68] = mem[_31514 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33007 + 68] = mem[_33007 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33007 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23024 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23024] = 30
                                mem[_23024 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _23497 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23497 + idx + 68] = mem[_23024 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23497 + 68] = mem[_23497 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23497 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25931 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25931] = 30
                                mem[_25931 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27224 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27224 + idx + 68] = mem[_25931 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27224 + 68] = mem[_27224 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27224 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _33006 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33006] = 30
                                mem[_33006 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34315 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34315 + idx + 68] = mem[_33006 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34315 + 68] = mem[_34315 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34315 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _21400 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21400] = 30
                                mem[_21400 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _21464 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_21464 + idx + 68] = mem[_21400 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21464 + 68] = mem[_21464 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _21464 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _21866 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21866] = 30
                                mem[_21866 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _21964 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_21964 + idx + 68] = mem[_21866 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21964 + 68] = mem[_21964 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _21964 + -mem[64] + 100
                            _21431 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21431] = 26
                            mem[_21431 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    _22737 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22737] = 30
                                    mem[_22737 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _24956 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24956] = 30
                                    mem[_24956 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _25945 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_25945 + idx + 68] = mem[_24956 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25945 + 68] = mem[_25945 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _25945 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _31523 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31523] = 30
                                    mem[_31523 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33017 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33017 + idx + 68] = mem[_31523 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33017 + 68] = mem[_33017 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33017 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23032 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23032] = 30
                                mem[_23032 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    _23507 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23507 + idx + 68] = mem[_23032 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23507 + 68] = mem[_23507 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23507 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25944 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25944] = 30
                                mem[_25944 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _27240 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27240 + idx + 68] = mem[_25944 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27240 + 68] = mem[_27240 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27240 + -mem[64] + 100
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                _33016 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33016] = 30
                                mem[_33016 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34327 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34327 + idx + 68] = mem[_33016 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34327 + 68] = mem[_34327 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34327 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                _23031 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23031] = 30
                                mem[_23031 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    _23504 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23504 + idx + 68] = mem[_23031 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23504 + 68] = mem[_23504 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23504 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25943 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25943] = 30
                                mem[_25943 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27237 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27237 + idx + 68] = mem[_25943 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27237 + 68] = mem[_27237 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27237 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                _33015 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33015] = 30
                                mem[_33015 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34324 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34324 + idx + 68] = mem[_33015 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34324 + 68] = mem[_34324 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34324 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23503] = 30
                            mem[_23503 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                _24202 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24202 + idx + 68] = mem[_23503 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24202 + 68] = mem[_24202 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24202 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _27236 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27236] = 30
                            mem[_27236 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _28730 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_28730 + idx + 68] = mem[_27236 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28730 + 68] = mem[_28730 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _28730 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                            _34323 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34323] = 30
                            mem[_34323 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _35642 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_35642 + idx + 68] = mem[_34323 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_35642 + 68] = mem[_35642 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35642 + -mem[64] + 100
                        _21063 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21063] = 26
                        mem[_21063 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100 * 10^18:
                            _21557 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21557] = 26
                            mem[_21557 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        else:
                            _21556 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21556] = 26
                            mem[_21556 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                    else:
                        idx = 0
                        s = 100 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _21312 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21312] = 26
                                mem[_21312 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22579 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22579] = 30
                                        mem[_22579 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _24017 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24017] = 30
                                        mem[_24017 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _24961 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_24961 + idx + 68] = mem[_24017 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24961 + 68] = mem[_24961 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _24961 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26769 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26769] = 30
                                        mem[_26769 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _28304 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_28304 + idx + 68] = mem[_26769 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28304 + 68] = mem[_28304 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _28304 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _35670 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35670] = 30
                                        mem[_35670 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _37024 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_37024 + idx + 68] = mem[_35670 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37024 + 68] = mem[_37024 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37024 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _22739 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22739] = 30
                                    mem[_22739 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23039 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23039 + idx + 68] = mem[_22739 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23039 + 68] = mem[_23039 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23039 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _24960 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24960] = 30
                                    mem[_24960 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _25962 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_25962 + idx + 68] = mem[_24960 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25962 + 68] = mem[_25962 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _25962 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _28301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28301] = 30
                                    mem[_28301 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _29917 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_29917 + idx + 68] = mem[_28301 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29917 + 68] = mem[_29917 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _29917 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _37023 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37023] = 30
                                    mem[_37023 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _38215 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_38215 + idx + 68] = mem[_37023 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38215 + 68] = mem[_38215 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38215 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _22738 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22738] = 30
                                    mem[_22738 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23036 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23036 + idx + 68] = mem[_22738 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23036 + 68] = mem[_23036 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23036 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _24959 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24959] = 30
                                    mem[_24959 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _25959 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_25959 + idx + 68] = mem[_24959 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25959 + 68] = mem[_25959 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _25959 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _28298 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28298] = 30
                                    mem[_28298 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _29914 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_29914 + idx + 68] = mem[_28298 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29914 + 68] = mem[_29914 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _29914 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _37022 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37022] = 30
                                    mem[_37022 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _38212 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_38212 + idx + 68] = mem[_37022 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38212 + 68] = mem[_38212 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38212 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23035 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23035] = 30
                                mem[_23035 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _23514 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23514 + idx + 68] = mem[_23035 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23514 + 68] = mem[_23514 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23514 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 2
                                _25958 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25958] = 30
                                mem[_25958 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _27260 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27260 + idx + 68] = mem[_25958 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27260 + 68] = mem[_27260 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27260 + -mem[64] + 100
                                stor2[address(msg.sender)] -= arg2
                                mem[0] = msg.sender
                                mem[32] = 1
                                _29911 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29911] = 30
                                mem[_29911 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _31542 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_31542 + idx + 68] = mem[_29911 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31542 + 68] = mem[_31542 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31542 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _38211 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38211] = 30
                                mem[_38211 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _39146 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_39146 + idx + 68] = mem[_38211 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39146 + 68] = mem[_39146 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39146 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _21401 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21401] = 30
                                mem[_21401 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _21467 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_21467 + idx + 68] = mem[_21401 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21467 + 68] = mem[_21467 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _21467 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _21868 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21868] = 30
                                mem[_21868 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _21969 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_21969 + idx + 68] = mem[_21868 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21969 + 68] = mem[_21969 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _21969 + -mem[64] + 100
                            _21432 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21432] = 26
                            mem[_21432 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    _22740 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22740] = 30
                                    mem[_22740 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _24968 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24968] = 30
                                    mem[_24968 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _25972 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_25972 + idx + 68] = mem[_24968 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25972 + 68] = mem[_25972 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _25972 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _28307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28307] = 30
                                    mem[_28307 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _29929 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_29929 + idx + 68] = mem[_28307 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29929 + 68] = mem[_29929 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _29929 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _37029 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37029] = 30
                                    mem[_37029 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _38222 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_38222 + idx + 68] = mem[_37029 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38222 + 68] = mem[_38222 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38222 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23043 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23043] = 30
                                mem[_23043 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    _23524 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23524 + idx + 68] = mem[_23043 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23524 + 68] = mem[_23524 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23524 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 2
                                _25971 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25971] = 30
                                mem[_25971 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _27274 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27274 + idx + 68] = mem[_25971 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27274 + 68] = mem[_27274 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27274 + -mem[64] + 100
                                stor2[address(msg.sender)] -= arg2
                                mem[0] = msg.sender
                                mem[32] = 1
                                _29926 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29926] = 30
                                mem[_29926 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _31560 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_31560 + idx + 68] = mem[_29926 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31560 + 68] = mem[_31560 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31560 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                _38221 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38221] = 30
                                mem[_38221 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _39158 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_39158 + idx + 68] = mem[_38221 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39158 + 68] = mem[_39158 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39158 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                _23042 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23042] = 30
                                mem[_23042 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    _23521 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23521 + idx + 68] = mem[_23042 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23521 + 68] = mem[_23521 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23521 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 2
                                _25970 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25970] = 30
                                mem[_25970 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _27271 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27271 + idx + 68] = mem[_25970 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27271 + 68] = mem[_27271 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27271 + -mem[64] + 100
                                stor2[address(msg.sender)] -= arg2
                                mem[0] = msg.sender
                                mem[32] = 1
                                _29923 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29923] = 30
                                mem[_29923 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _31557 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_31557 + idx + 68] = mem[_29923 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31557 + 68] = mem[_31557 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31557 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                _38220 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38220] = 30
                                mem[_38220 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _39155 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_39155 + idx + 68] = mem[_38220 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39155 + 68] = mem[_39155 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39155 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23520 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23520] = 30
                            mem[_23520 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                _24227 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24227 + idx + 68] = mem[_23520 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24227 + 68] = mem[_24227 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24227 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 2
                            _27270 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27270] = 30
                            mem[_27270 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _28767 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_28767 + idx + 68] = mem[_27270 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28767 + 68] = mem[_28767 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _28767 + -mem[64] + 100
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _31554 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31554] = 30
                            mem[_31554 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _33053 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_33053 + idx + 68] = mem[_31554 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33053 + 68] = mem[_33053 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33053 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                            _39154 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39154] = 30
                            mem[_39154 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _39883 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_39883 + idx + 68] = mem[_39154 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_39883 + 68] = mem[_39883 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _39883 + -mem[64] + 100
                        _21068 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21068] = 26
                        mem[_21068 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100 * 10^18:
                            _21559 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21559] = 26
                            mem[_21559 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        else:
                            _21558 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21558] = 26
                            mem[_21558 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not arg2 / 100:
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
            else:
                mem[0] = arg1
                mem[32] = 4
                if not stor4[address(arg1)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = 100 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _21324 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21324] = 26
                            mem[_21324 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    _22583 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22583] = 30
                                    mem[_22583 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _24037 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24037] = 30
                                    mem[_24037 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _25009 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_25009 + idx + 68] = mem[_24037 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25009 + 68] = mem[_25009 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _25009 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _29995 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29995] = 30
                                    mem[_29995 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _31663 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_31663 + idx + 68] = mem[_29995 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31663 + 68] = mem[_31663 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _31663 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _22751 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22751] = 30
                                mem[_22751 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    _23083 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23083 + idx + 68] = mem[_22751 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23083 + 68] = mem[_23083 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23083 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25008 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25008] = 30
                                mem[_25008 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _26070 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_26070 + idx + 68] = mem[_25008 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26070 + 68] = mem[_26070 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _26070 + -mem[64] + 100
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                _31662 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31662] = 30
                                mem[_31662 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _33172 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_33172 + idx + 68] = mem[_31662 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33172 + 68] = mem[_33172 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33172 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                _22750 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22750] = 30
                                mem[_22750 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    _23080 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23080 + idx + 68] = mem[_22750 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23080 + 68] = mem[_23080 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23080 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25007 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25007] = 30
                                mem[_25007 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _26067 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_26067 + idx + 68] = mem[_25007 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26067 + 68] = mem[_26067 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _26067 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                _31661 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31661] = 30
                                mem[_31661 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _33169 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_33169 + idx + 68] = mem[_31661 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33169 + 68] = mem[_33169 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33169 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23079 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23079] = 30
                            mem[_23079 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                _23582 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23582 + idx + 68] = mem[_23079 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23582 + 68] = mem[_23582 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23582 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _26066 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26066] = 30
                            mem[_26066 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _27400 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_27400 + idx + 68] = mem[_26066 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27400 + 68] = mem[_27400 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _27400 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                            _33168 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33168] = 30
                            mem[_33168 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _34473 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_34473 + idx + 68] = mem[_33168 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_34473 + 68] = mem[_34473 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _34473 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _21405 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21405] = 30
                            mem[_21405 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _21479 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_21479 + idx + 68] = mem[_21405 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21479 + 68] = mem[_21479 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _21479 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _21876 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21876] = 30
                            mem[_21876 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _21989 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_21989 + idx + 68] = mem[_21876 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_21989 + 68] = mem[_21989 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _21989 + -mem[64] + 100
                        _21436 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21436] = 26
                        mem[_21436 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not arg2 / 100:
                                _22752 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22752] = 30
                                mem[_22752 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25016 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25016] = 30
                                mem[_25016 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _26080 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_26080 + idx + 68] = mem[_25016 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26080 + 68] = mem[_26080 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _26080 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _31670 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31670] = 30
                                mem[_31670 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _33179 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_33179 + idx + 68] = mem[_31670 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33179 + 68] = mem[_33179 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33179 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23087 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23087] = 30
                            mem[_23087 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                _23592 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23592 + idx + 68] = mem[_23087 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23592 + 68] = mem[_23592 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23592 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _26079 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26079] = 30
                            mem[_26079 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _27416 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_27416 + idx + 68] = mem[_26079 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27416 + 68] = mem[_27416 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _27416 + -mem[64] + 100
                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            _33178 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33178] = 30
                            mem[_33178 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _34485 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_34485 + idx + 68] = mem[_33178 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_34485 + 68] = mem[_34485 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _34485 + -mem[64] + 100
                        require arg2
                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not arg2 / 100:
                            _23086 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23086] = 30
                            mem[_23086 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100 * 10^18:
                                _23589 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23589 + idx + 68] = mem[_23086 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23589 + 68] = mem[_23589 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23589 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _26078 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26078] = 30
                            mem[_26078 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _27413 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_27413 + idx + 68] = mem[_26078 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27413 + 68] = mem[_27413 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _27413 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                            _33177 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33177] = 30
                            mem[_33177 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _34482 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_34482 + idx + 68] = mem[_33177 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_34482 + 68] = mem[_34482 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _34482 + -mem[64] + 100
                        require arg2 / 100
                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _23588 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23588] = 30
                        mem[_23588 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                            _24327 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_24327 + idx + 68] = mem[_23588 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24327 + 68] = mem[_24327 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _24327 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _27412 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27412] = 30
                        mem[_27412 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                            _28923 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_28923 + idx + 68] = mem[_27412 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_28923 + 68] = mem[_28923 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _28923 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                        _34481 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34481] = 30
                        mem[_34481 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            if totalFees + (arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100
                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                            return 1
                        _35791 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_35791 + idx + 68] = mem[_34481 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_35791 + 68] = mem[_35791 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _35791 + -mem[64] + 100
                    _21088 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21088] = 26
                    mem[_21088 + 32] = 'SafeMath: division by zero'
                    if t < stor6 / 100 * 10^18:
                        _21567 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21567] = 26
                        mem[_21567 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        else:
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                    else:
                        _21566 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21566] = 26
                        mem[_21566 + 32] = 'SafeMath: division by zero'
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require s
                        if not arg2:
                            if not arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                if arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * t / s
                        else:
                            require arg2
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                if arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * t / s
                else:
                    mem[0] = msg.sender
                    mem[32] = 4
                    if not stor4[address(msg.sender)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _21315 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21315] = 26
                                mem[_21315 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22580 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22580] = 30
                                        mem[_22580 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _24022 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24022] = 30
                                        mem[_24022 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _24973 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_24973 + idx + 68] = mem[_24022 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24973 + 68] = mem[_24973 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _24973 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _29940 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29940] = 30
                                        mem[_29940 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _31579 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31579 + idx + 68] = mem[_29940 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31579 + 68] = mem[_31579 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31579 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _22742 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22742] = 30
                                    mem[_22742 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23050 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23050 + idx + 68] = mem[_22742 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23050 + 68] = mem[_23050 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23050 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _24972 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24972] = 30
                                    mem[_24972 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _25989 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_25989 + idx + 68] = mem[_24972 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25989 + 68] = mem[_25989 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _25989 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _31578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31578] = 30
                                    mem[_31578 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33079 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33079 + idx + 68] = mem[_31578 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33079 + 68] = mem[_33079 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33079 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _22741 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22741] = 30
                                    mem[_22741 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23047 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23047 + idx + 68] = mem[_22741 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23047 + 68] = mem[_23047 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23047 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _24971 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24971] = 30
                                    mem[_24971 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _25986 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_25986 + idx + 68] = mem[_24971 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25986 + 68] = mem[_25986 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _25986 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _31577 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31577] = 30
                                    mem[_31577 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33076 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33076 + idx + 68] = mem[_31577 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33076 + 68] = mem[_33076 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33076 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23046 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23046] = 30
                                mem[_23046 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _23531 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23531 + idx + 68] = mem[_23046 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23531 + 68] = mem[_23531 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23531 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25985 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25985] = 30
                                mem[_25985 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27294 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27294 + idx + 68] = mem[_25985 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27294 + 68] = mem[_27294 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27294 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _33075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33075] = 30
                                mem[_33075 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34380 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34380 + idx + 68] = mem[_33075 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34380 + 68] = mem[_34380 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34380 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _21402 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21402] = 30
                                mem[_21402 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _21470 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_21470 + idx + 68] = mem[_21402 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21470 + 68] = mem[_21470 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _21470 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _21870 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21870] = 30
                                mem[_21870 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _21974 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_21974 + idx + 68] = mem[_21870 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21974 + 68] = mem[_21974 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _21974 + -mem[64] + 100
                            _21433 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21433] = 26
                            mem[_21433 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    _22743 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22743] = 30
                                    mem[_22743 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _24980 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24980] = 30
                                    mem[_24980 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _25999 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_25999 + idx + 68] = mem[_24980 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25999 + 68] = mem[_25999 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _25999 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _31586 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31586] = 30
                                    mem[_31586 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33086 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33086 + idx + 68] = mem[_31586 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33086 + 68] = mem[_33086 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33086 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23054 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23054] = 30
                                mem[_23054 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    _23541 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23541 + idx + 68] = mem[_23054 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23541 + 68] = mem[_23541 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23541 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25998 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25998] = 30
                                mem[_25998 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _27310 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27310 + idx + 68] = mem[_25998 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27310 + 68] = mem[_27310 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27310 + -mem[64] + 100
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                _33085 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33085] = 30
                                mem[_33085 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34392 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34392 + idx + 68] = mem[_33085 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34392 + 68] = mem[_34392 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34392 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                _23053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23053] = 30
                                mem[_23053 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    _23538 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23538 + idx + 68] = mem[_23053 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23538 + 68] = mem[_23538 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23538 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25997 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25997] = 30
                                mem[_25997 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27307 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27307 + idx + 68] = mem[_25997 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27307 + 68] = mem[_27307 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27307 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                _33084 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33084] = 30
                                mem[_33084 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34389 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34389 + idx + 68] = mem[_33084 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34389 + 68] = mem[_34389 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34389 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23537 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23537] = 30
                            mem[_23537 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                _24252 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24252 + idx + 68] = mem[_23537 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24252 + 68] = mem[_24252 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24252 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _27306 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27306] = 30
                            mem[_27306 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _28806 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_28806 + idx + 68] = mem[_27306 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28806 + 68] = mem[_28806 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _28806 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                            _34388 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34388] = 30
                            mem[_34388 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _35700 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_35700 + idx + 68] = mem[_34388 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_35700 + 68] = mem[_35700 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35700 + -mem[64] + 100
                        _21073 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21073] = 26
                        mem[_21073 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100 * 10^18:
                            _21561 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21561] = 26
                            mem[_21561 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        else:
                            _21560 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21560] = 26
                            mem[_21560 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not stor4[address(arg1)]:
                            idx = 0
                            s = 100 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _21318 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21318] = 26
                                    mem[_21318 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22581 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22581] = 30
                                            mem[_22581 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _24027 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24027] = 30
                                            mem[_24027 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _24985 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_24985 + idx + 68] = mem[_24027 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_24985 + 68] = mem[_24985 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _24985 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _29954 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29954] = 30
                                            mem[_29954 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _31600 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_31600 + idx + 68] = mem[_29954 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31600 + 68] = mem[_31600 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _31600 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _22745 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22745] = 30
                                        mem[_22745 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23061 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23061 + idx + 68] = mem[_22745 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23061 + 68] = mem[_23061 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23061 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _24984 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24984] = 30
                                        mem[_24984 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26016 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26016 + idx + 68] = mem[_24984 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26016 + 68] = mem[_26016 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26016 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _31599 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31599] = 30
                                        mem[_31599 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33103 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33103 + idx + 68] = mem[_31599 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33103 + 68] = mem[_33103 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33103 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _22744 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22744] = 30
                                        mem[_22744 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23058 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23058 + idx + 68] = mem[_22744 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23058 + 68] = mem[_23058 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23058 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _24983 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24983] = 30
                                        mem[_24983 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _26013 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26013 + idx + 68] = mem[_24983 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26013 + 68] = mem[_26013 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26013 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _31598 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31598] = 30
                                        mem[_31598 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33100 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33100 + idx + 68] = mem[_31598 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33100 + 68] = mem[_33100 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33100 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23057 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23057] = 30
                                    mem[_23057 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _23548 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23548 + idx + 68] = mem[_23057 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23548 + 68] = mem[_23548 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23548 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26012 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26012] = 30
                                    mem[_26012 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27330 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27330 + idx + 68] = mem[_26012 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27330 + 68] = mem[_27330 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27330 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _33099 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33099] = 30
                                    mem[_33099 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34408 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34408 + idx + 68] = mem[_33099 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34408 + 68] = mem[_34408 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34408 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _21403 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21403] = 30
                                    mem[_21403 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _21473 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_21473 + idx + 68] = mem[_21403 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21473 + 68] = mem[_21473 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _21473 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _21872 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21872] = 30
                                    mem[_21872 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _21979 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_21979 + idx + 68] = mem[_21872 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21979 + 68] = mem[_21979 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _21979 + -mem[64] + 100
                                _21434 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21434] = 26
                                mem[_21434 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22746 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22746] = 30
                                        mem[_22746 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _24992 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24992] = 30
                                        mem[_24992 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26026 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26026 + idx + 68] = mem[_24992 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26026 + 68] = mem[_26026 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26026 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _31607 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31607] = 30
                                        mem[_31607 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33110 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33110 + idx + 68] = mem[_31607 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33110 + 68] = mem[_33110 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33110 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23065 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23065] = 30
                                    mem[_23065 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23558 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23558 + idx + 68] = mem[_23065 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23558 + 68] = mem[_23558 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23558 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26025 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26025] = 30
                                    mem[_26025 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _27346 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27346 + idx + 68] = mem[_26025 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27346 + 68] = mem[_27346 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27346 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _33109 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33109] = 30
                                    mem[_33109 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34420 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34420 + idx + 68] = mem[_33109 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34420 + 68] = mem[_34420 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34420 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _23064 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23064] = 30
                                    mem[_23064 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23555 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23555 + idx + 68] = mem[_23064 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23555 + 68] = mem[_23555 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23555 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26024 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26024] = 30
                                    mem[_26024 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27343 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27343 + idx + 68] = mem[_26024 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27343 + 68] = mem[_27343 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27343 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _33108 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33108] = 30
                                    mem[_33108 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34417 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34417 + idx + 68] = mem[_33108 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34417 + 68] = mem[_34417 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34417 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23554 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23554] = 30
                                mem[_23554 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _24277 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24277 + idx + 68] = mem[_23554 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24277 + 68] = mem[_24277 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24277 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _27342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27342] = 30
                                mem[_27342 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _28847 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_28847 + idx + 68] = mem[_27342 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28847 + 68] = mem[_28847 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _28847 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _34416 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34416] = 30
                                mem[_34416 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _35733 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_35733 + idx + 68] = mem[_34416 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35733 + 68] = mem[_35733 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35733 + -mem[64] + 100
                            _21078 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21078] = 26
                            mem[_21078 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100 * 10^18:
                                _21563 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21563] = 26
                                mem[_21563 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                _21562 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21562] = 26
                                mem[_21562 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                        else:
                            idx = 0
                            s = 100 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _21321 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21321] = 26
                                    mem[_21321 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22582 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22582] = 30
                                            mem[_22582 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _24032 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24032] = 30
                                            mem[_24032 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _24997 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_24997 + idx + 68] = mem[_24032 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_24997 + 68] = mem[_24997 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _24997 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _26812 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26812] = 30
                                            mem[_26812 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _28342 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_28342 + idx + 68] = mem[_26812 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_28342 + 68] = mem[_28342 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _28342 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _35761 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35761] = 30
                                            mem[_35761 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _37105 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37105 + idx + 68] = mem[_35761 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37105 + 68] = mem[_37105 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37105 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _22748 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22748] = 30
                                        mem[_22748 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23072 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23072 + idx + 68] = mem[_22748 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23072 + 68] = mem[_23072 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23072 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _24996 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24996] = 30
                                        mem[_24996 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _26043 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26043 + idx + 68] = mem[_24996 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26043 + 68] = mem[_26043 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26043 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _28339 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28339] = 30
                                        mem[_28339 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _29972 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_29972 + idx + 68] = mem[_28339 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29972 + 68] = mem[_29972 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _29972 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _37104 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37104] = 30
                                        mem[_37104 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _38289 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38289 + idx + 68] = mem[_37104 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38289 + 68] = mem[_38289 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38289 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _22747 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22747] = 30
                                        mem[_22747 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23069 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23069 + idx + 68] = mem[_22747 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23069 + 68] = mem[_23069 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23069 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _24995 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24995] = 30
                                        mem[_24995 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _26040 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26040 + idx + 68] = mem[_24995 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26040 + 68] = mem[_26040 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26040 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _28336 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28336] = 30
                                        mem[_28336 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _29969 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_29969 + idx + 68] = mem[_28336 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29969 + 68] = mem[_29969 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _29969 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _37103 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37103] = 30
                                        mem[_37103 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _38286 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38286 + idx + 68] = mem[_37103 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38286 + 68] = mem[_38286 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38286 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23068 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23068] = 30
                                    mem[_23068 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _23565 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23565 + idx + 68] = mem[_23068 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23565 + 68] = mem[_23565 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23565 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _26039 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26039] = 30
                                    mem[_26039 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _27366 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27366 + idx + 68] = mem[_26039 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27366 + 68] = mem[_27366 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27366 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _29966 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29966] = 30
                                    mem[_29966 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _31626 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31626 + idx + 68] = mem[_29966 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31626 + 68] = mem[_31626 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31626 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _38285 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38285] = 30
                                    mem[_38285 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _39206 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39206 + idx + 68] = mem[_38285 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39206 + 68] = mem[_39206 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39206 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _21404 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21404] = 30
                                    mem[_21404 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _21476 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_21476 + idx + 68] = mem[_21404 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21476 + 68] = mem[_21476 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _21476 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _21874 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21874] = 30
                                    mem[_21874 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _21984 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_21984 + idx + 68] = mem[_21874 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21984 + 68] = mem[_21984 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _21984 + -mem[64] + 100
                                _21435 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21435] = 26
                                mem[_21435 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22749 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22749] = 30
                                        mem[_22749 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _25004 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25004] = 30
                                        mem[_25004 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _26053 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26053 + idx + 68] = mem[_25004 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26053 + 68] = mem[_26053 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26053 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _28345 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28345] = 30
                                        mem[_28345 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _29984 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_29984 + idx + 68] = mem[_28345 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29984 + 68] = mem[_29984 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _29984 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _37110 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37110] = 30
                                        mem[_37110 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _38296 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38296 + idx + 68] = mem[_37110 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38296 + 68] = mem[_38296 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38296 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23076 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23076] = 30
                                    mem[_23076 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23575 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23575 + idx + 68] = mem[_23076 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23575 + 68] = mem[_23575 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23575 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _26052 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26052] = 30
                                    mem[_26052 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _27380 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27380 + idx + 68] = mem[_26052 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27380 + 68] = mem[_27380 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27380 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _29981 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29981] = 30
                                    mem[_29981 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _31644 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31644 + idx + 68] = mem[_29981 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31644 + 68] = mem[_31644 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31644 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _38295 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38295] = 30
                                    mem[_38295 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _39218 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39218 + idx + 68] = mem[_38295 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39218 + 68] = mem[_39218 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39218 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _23075 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23075] = 30
                                    mem[_23075 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23572 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23572 + idx + 68] = mem[_23075 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23572 + 68] = mem[_23572 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23572 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _26051 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26051] = 30
                                    mem[_26051 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _27377 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27377 + idx + 68] = mem[_26051 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27377 + 68] = mem[_27377 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27377 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _29978 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29978] = 30
                                    mem[_29978 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _31641 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31641 + idx + 68] = mem[_29978 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31641 + 68] = mem[_31641 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31641 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _38294 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38294] = 30
                                    mem[_38294 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _39215 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39215 + idx + 68] = mem[_38294 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39215 + 68] = mem[_39215 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39215 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23571 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23571] = 30
                                mem[_23571 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _24302 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24302 + idx + 68] = mem[_23571 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24302 + 68] = mem[_24302 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24302 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 2
                                _27376 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27376] = 30
                                mem[_27376 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _28884 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_28884 + idx + 68] = mem[_27376 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28884 + 68] = mem[_28884 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _28884 + -mem[64] + 100
                                stor2[address(msg.sender)] -= arg2
                                mem[0] = msg.sender
                                mem[32] = 1
                                _31638 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31638] = 30
                                mem[_31638 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _33146 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33146 + idx + 68] = mem[_31638 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33146 + 68] = mem[_33146 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33146 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _39214 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39214] = 30
                                mem[_39214 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _39924 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_39924 + idx + 68] = mem[_39214 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39924 + 68] = mem[_39924 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39924 + -mem[64] + 100
                            _21083 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21083] = 26
                            mem[_21083 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100 * 10^18:
                                _21565 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21565] = 26
                                mem[_21565 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                _21564 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21564] = 26
                                mem[_21564 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
        else:
            mem[0] = arg1
            mem[32] = 4
            if stor4[address(arg1)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if arg2 / 100 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow'
                idx = 0
                s = 100 * 10^18
                t = stor6
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _21348 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21348] = 26
                        mem[_21348 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not arg2 / 100:
                                _22591 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22591] = 30
                                mem[_22591 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _24077 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24077] = 30
                                mem[_24077 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _25105 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_25105 + idx + 68] = mem[_24077 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25105 + 68] = mem[_25105 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _25105 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _32638 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32638] = 30
                                mem[_32638 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34076 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34076 + idx + 68] = mem[_32638 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34076 + 68] = mem[_34076 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34076 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _22775 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22775] = 30
                            mem[_22775 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                _23171 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23171 + idx + 68] = mem[_22775 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23171 + 68] = mem[_23171 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23171 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _25104 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25104] = 30
                            mem[_25104 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _26286 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_26286 + idx + 68] = mem[_25104 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26286 + 68] = mem[_26286 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _26286 + -mem[64] + 100
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            _34075 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34075] = 30
                            mem[_34075 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _35369 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_35369 + idx + 68] = mem[_34075 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_35369 + 68] = mem[_35369 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35369 + -mem[64] + 100
                        require arg2
                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not arg2 / 100:
                            _22774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22774] = 30
                            mem[_22774 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100 * 10^18:
                                _23168 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23168 + idx + 68] = mem[_22774 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23168 + 68] = mem[_23168 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23168 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _25103 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25103] = 30
                            mem[_25103 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _26283 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_26283 + idx + 68] = mem[_25103 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26283 + 68] = mem[_26283 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _26283 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                            _34074 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34074] = 30
                            mem[_34074 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _35366 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_35366 + idx + 68] = mem[_34074 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_35366 + 68] = mem[_35366 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35366 + -mem[64] + 100
                        require arg2 / 100
                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _23167 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23167] = 30
                        mem[_23167 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                            _23718 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_23718 + idx + 68] = mem[_23167 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23718 + 68] = mem[_23718 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _23718 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _26282 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26282] = 30
                        mem[_26282 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                            _27684 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_27684 + idx + 68] = mem[_26282 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_27684 + 68] = mem[_27684 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _27684 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                        _35365 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35365] = 30
                        mem[_35365 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            if totalFees + (arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100
                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                            return 1
                        _36685 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_36685 + idx + 68] = mem[_35365 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_36685 + 68] = mem[_36685 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36685 + -mem[64] + 100
                    require idx < stor5.length
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _21413 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21413] = 30
                        mem[_21413 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _21503 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_21503 + idx + 68] = mem[_21413 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_21503 + 68] = mem[_21503 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _21503 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _21892 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21892] = 30
                        mem[_21892 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _22029 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_22029 + idx + 68] = mem[_21892 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_22029 + 68] = mem[_22029 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _22029 + -mem[64] + 100
                    _21444 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21444] = 26
                    mem[_21444 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if not arg2 / 100:
                            _22776 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22776] = 30
                            mem[_22776 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 1
                            _25112 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25112] = 30
                            mem[_25112 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _26296 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_26296 + idx + 68] = mem[_25112 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26296 + 68] = mem[_26296 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _26296 + -mem[64] + 100
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _34081 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34081] = 30
                            mem[_34081 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _35376 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_35376 + idx + 68] = mem[_34081 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_35376 + 68] = mem[_35376 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35376 + -mem[64] + 100
                        require arg2 / 100
                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _23175 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23175] = 30
                        mem[_23175 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                            _23728 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_23728 + idx + 68] = mem[_23175 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23728 + 68] = mem[_23728 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _23728 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _26295 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26295] = 30
                        mem[_26295 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _27700 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_27700 + idx + 68] = mem[_26295 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_27700 + 68] = mem[_27700 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _27700 + -mem[64] + 100
                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        _35375 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35375] = 30
                        mem[_35375 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            if totalFees + (arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100
                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                            return 1
                        _36697 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_36697 + idx + 68] = mem[_35375 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_36697 + 68] = mem[_36697 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36697 + -mem[64] + 100
                    require arg2
                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not arg2 / 100:
                        _23174 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23174] = 30
                        mem[_23174 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 100 * 10^18:
                            _23725 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_23725 + idx + 68] = mem[_23174 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23725 + 68] = mem[_23725 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _23725 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _26294 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26294] = 30
                        mem[_26294 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                            _27697 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_27697 + idx + 68] = mem[_26294 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_27697 + 68] = mem[_27697 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _27697 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                        _35374 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35374] = 30
                        mem[_35374 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if totalFees + (arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100
                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                            return 1
                        _36694 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_36694 + idx + 68] = mem[_35374 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_36694 + 68] = mem[_36694 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36694 + -mem[64] + 100
                    require arg2 / 100
                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _23724 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23724] = 30
                    mem[_23724 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                        _24527 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_24527 + idx + 68] = mem[_23724 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_24527 + 68] = mem[_24527 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _24527 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _27696 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27696] = 30
                    mem[_27696 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                        _29239 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_29239 + idx + 68] = mem[_27696 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_29239 + 68] = mem[_29239 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _29239 + -mem[64] + 100
                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                    _36693 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_36693] = 30
                    mem[_36693 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        if totalFees + (arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg2 / 100
                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                        return 1
                    _37926 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_37926 + idx + 68] = mem[_36693 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_37926 + 68] = mem[_37926 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _37926 + -mem[64] + 100
                _21128 = mem[64]
                mem[64] = mem[64] + 64
                mem[_21128] = 26
                mem[_21128 + 32] = 'SafeMath: division by zero'
                if t < stor6 / 100 * 10^18:
                    _21583 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21583] = 26
                    mem[_21583 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if not arg2 / 100:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                    else:
                        require arg2
                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not arg2 / 100:
                            if 0 > arg2 * stor6 / 100 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                else:
                    _21582 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21582] = 26
                    mem[_21582 + 32] = 'SafeMath: division by zero'
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require s
                    if not arg2:
                        if not arg2 / 100:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require arg2 / 100
                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if arg2 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                            if arg2 / 100 * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor6 += -1 * arg2 / 100 * t / s
                    else:
                        require arg2
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not arg2 / 100:
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require arg2 / 100
                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if arg2 / 100 * t / s > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                            if arg2 / 100 * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor6 += -1 * arg2 / 100 * t / s
            else:
                if stor4[address(msg.sender)]:
                    mem[0] = msg.sender
                    mem[32] = 4
                    if not stor4[address(msg.sender)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _21327 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21327] = 26
                                mem[_21327 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22584 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22584] = 30
                                        mem[_22584 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _24042 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24042] = 30
                                        mem[_24042 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _25021 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_25021 + idx + 68] = mem[_24042 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25021 + 68] = mem[_25021 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _25021 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _30009 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30009] = 30
                                        mem[_30009 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _31684 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31684 + idx + 68] = mem[_30009 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31684 + 68] = mem[_31684 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31684 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _22754 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22754] = 30
                                    mem[_22754 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23094 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23094 + idx + 68] = mem[_22754 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23094 + 68] = mem[_23094 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23094 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25020 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25020] = 30
                                    mem[_25020 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _26097 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26097 + idx + 68] = mem[_25020 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26097 + 68] = mem[_26097 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26097 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _31683 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31683] = 30
                                    mem[_31683 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33196 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33196 + idx + 68] = mem[_31683 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33196 + 68] = mem[_33196 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33196 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _22753 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22753] = 30
                                    mem[_22753 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23091 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23091 + idx + 68] = mem[_22753 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23091 + 68] = mem[_23091 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23091 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25019 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25019] = 30
                                    mem[_25019 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _26094 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26094 + idx + 68] = mem[_25019 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26094 + 68] = mem[_26094 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26094 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _31682 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31682] = 30
                                    mem[_31682 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33193 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33193 + idx + 68] = mem[_31682 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33193 + 68] = mem[_33193 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33193 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23090 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23090] = 30
                                mem[_23090 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _23599 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23599 + idx + 68] = mem[_23090 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23599 + 68] = mem[_23599 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23599 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26093] = 30
                                mem[_26093 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27436 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27436 + idx + 68] = mem[_26093 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27436 + 68] = mem[_27436 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27436 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _33192 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33192] = 30
                                mem[_33192 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34501 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34501 + idx + 68] = mem[_33192 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34501 + 68] = mem[_34501 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34501 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _21406 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21406] = 30
                                mem[_21406 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _21482 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_21482 + idx + 68] = mem[_21406 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21482 + 68] = mem[_21482 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _21482 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _21878 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21878] = 30
                                mem[_21878 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _21994 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_21994 + idx + 68] = mem[_21878 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21994 + 68] = mem[_21994 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _21994 + -mem[64] + 100
                            _21437 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21437] = 26
                            mem[_21437 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    _22755 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22755] = 30
                                    mem[_22755 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25028 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25028] = 30
                                    mem[_25028 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _26107 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26107 + idx + 68] = mem[_25028 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26107 + 68] = mem[_26107 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26107 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _31691 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31691] = 30
                                    mem[_31691 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33203 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33203 + idx + 68] = mem[_31691 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33203 + 68] = mem[_33203 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33203 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23098 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23098] = 30
                                mem[_23098 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    _23609 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23609 + idx + 68] = mem[_23098 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23609 + 68] = mem[_23609 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23609 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26106 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26106] = 30
                                mem[_26106 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _27452 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27452 + idx + 68] = mem[_26106 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27452 + 68] = mem[_27452 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27452 + -mem[64] + 100
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                _33202 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33202] = 30
                                mem[_33202 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34513 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34513 + idx + 68] = mem[_33202 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34513 + 68] = mem[_34513 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34513 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                _23097 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23097] = 30
                                mem[_23097 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    _23606 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23606 + idx + 68] = mem[_23097 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23606 + 68] = mem[_23606 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23606 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26105 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26105] = 30
                                mem[_26105 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27449 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27449 + idx + 68] = mem[_26105 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27449 + 68] = mem[_27449 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27449 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                _33201 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33201] = 30
                                mem[_33201 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34510 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34510 + idx + 68] = mem[_33201 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34510 + 68] = mem[_34510 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34510 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23605 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23605] = 30
                            mem[_23605 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                _24352 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24352 + idx + 68] = mem[_23605 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24352 + 68] = mem[_24352 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24352 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _27448 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27448] = 30
                            mem[_27448 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _28964 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_28964 + idx + 68] = mem[_27448 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28964 + 68] = mem[_28964 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _28964 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                            _34509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34509] = 30
                            mem[_34509 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _35824 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_35824 + idx + 68] = mem[_34509 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_35824 + 68] = mem[_35824 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35824 + -mem[64] + 100
                        _21093 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21093] = 26
                        mem[_21093 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100 * 10^18:
                            _21569 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21569] = 26
                            mem[_21569 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        else:
                            _21568 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21568] = 26
                            mem[_21568 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not stor4[address(arg1)]:
                            idx = 0
                            s = 100 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _21330 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21330] = 26
                                    mem[_21330 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22585 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22585] = 30
                                            mem[_22585 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _24047 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24047] = 30
                                            mem[_24047 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _25033 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_25033 + idx + 68] = mem[_24047 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25033 + 68] = mem[_25033 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _25033 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _30023 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30023] = 30
                                            mem[_30023 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _31705 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_31705 + idx + 68] = mem[_30023 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31705 + 68] = mem[_31705 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _31705 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _22757 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22757] = 30
                                        mem[_22757 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23105 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23105 + idx + 68] = mem[_22757 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23105 + 68] = mem[_23105 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23105 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25032 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25032] = 30
                                        mem[_25032 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26124 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26124 + idx + 68] = mem[_25032 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26124 + 68] = mem[_26124 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26124 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _31704 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31704] = 30
                                        mem[_31704 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33220 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33220 + idx + 68] = mem[_31704 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33220 + 68] = mem[_33220 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33220 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _22756 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22756] = 30
                                        mem[_22756 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23102 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23102 + idx + 68] = mem[_22756 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23102 + 68] = mem[_23102 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23102 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25031 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25031] = 30
                                        mem[_25031 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _26121 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26121 + idx + 68] = mem[_25031 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26121 + 68] = mem[_26121 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26121 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _31703 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31703] = 30
                                        mem[_31703 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33217 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33217 + idx + 68] = mem[_31703 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33217 + 68] = mem[_33217 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33217 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23101 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23101] = 30
                                    mem[_23101 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _23616 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23616 + idx + 68] = mem[_23101 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23616 + 68] = mem[_23616 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23616 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26120 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26120] = 30
                                    mem[_26120 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27472 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27472 + idx + 68] = mem[_26120 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27472 + 68] = mem[_27472 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27472 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _33216 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33216] = 30
                                    mem[_33216 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34529 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34529 + idx + 68] = mem[_33216 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34529 + 68] = mem[_34529 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34529 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _21407 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21407] = 30
                                    mem[_21407 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _21485 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_21485 + idx + 68] = mem[_21407 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21485 + 68] = mem[_21485 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _21485 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _21880 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21880] = 30
                                    mem[_21880 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _21999 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_21999 + idx + 68] = mem[_21880 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21999 + 68] = mem[_21999 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _21999 + -mem[64] + 100
                                _21438 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21438] = 26
                                mem[_21438 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22758 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22758] = 30
                                        mem[_22758 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25040 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25040] = 30
                                        mem[_25040 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26134 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26134 + idx + 68] = mem[_25040 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26134 + 68] = mem[_26134 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26134 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _31712 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31712] = 30
                                        mem[_31712 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33227 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33227 + idx + 68] = mem[_31712 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33227 + 68] = mem[_33227 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33227 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23109 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23109] = 30
                                    mem[_23109 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23626 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23626 + idx + 68] = mem[_23109 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23626 + 68] = mem[_23626 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23626 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26133 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26133] = 30
                                    mem[_26133 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _27488 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27488 + idx + 68] = mem[_26133 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27488 + 68] = mem[_27488 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27488 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _33226 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33226] = 30
                                    mem[_33226 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34541 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34541 + idx + 68] = mem[_33226 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34541 + 68] = mem[_34541 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34541 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _23108 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23108] = 30
                                    mem[_23108 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23623 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23623 + idx + 68] = mem[_23108 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23623 + 68] = mem[_23623 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23623 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26132 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26132] = 30
                                    mem[_26132 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27485 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27485 + idx + 68] = mem[_26132 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27485 + 68] = mem[_27485 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27485 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _33225 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33225] = 30
                                    mem[_33225 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34538 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34538 + idx + 68] = mem[_33225 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34538 + 68] = mem[_34538 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34538 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23622 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23622] = 30
                                mem[_23622 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _24377 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24377 + idx + 68] = mem[_23622 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24377 + 68] = mem[_24377 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24377 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _27484 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27484] = 30
                                mem[_27484 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _29005 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_29005 + idx + 68] = mem[_27484 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29005 + 68] = mem[_29005 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29005 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _34537 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34537] = 30
                                mem[_34537 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _35857 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_35857 + idx + 68] = mem[_34537 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35857 + 68] = mem[_35857 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35857 + -mem[64] + 100
                            _21098 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21098] = 26
                            mem[_21098 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100 * 10^18:
                                _21571 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21571] = 26
                                mem[_21571 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                _21570 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21570] = 26
                                mem[_21570 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                        else:
                            idx = 0
                            s = 100 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _21333 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21333] = 26
                                    mem[_21333 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22586 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22586] = 30
                                            mem[_22586 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _24052 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24052] = 30
                                            mem[_24052 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _25045 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_25045 + idx + 68] = mem[_24052 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25045 + 68] = mem[_25045 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _25045 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _26869 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26869] = 30
                                            mem[_26869 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _28391 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_28391 + idx + 68] = mem[_26869 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_28391 + 68] = mem[_28391 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _28391 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _35885 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35885] = 30
                                            mem[_35885 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _37218 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37218 + idx + 68] = mem[_35885 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37218 + 68] = mem[_37218 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37218 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _22760 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22760] = 30
                                        mem[_22760 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23116 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23116 + idx + 68] = mem[_22760 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23116 + 68] = mem[_23116 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23116 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _25044 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25044] = 30
                                        mem[_25044 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _26151 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26151 + idx + 68] = mem[_25044 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26151 + 68] = mem[_26151 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26151 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _28388 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28388] = 30
                                        mem[_28388 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _30041 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_30041 + idx + 68] = mem[_28388 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30041 + 68] = mem[_30041 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _30041 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _37217 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37217] = 30
                                        mem[_37217 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _38390 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38390 + idx + 68] = mem[_37217 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38390 + 68] = mem[_38390 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38390 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _22759 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22759] = 30
                                        mem[_22759 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23113 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23113 + idx + 68] = mem[_22759 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23113 + 68] = mem[_23113 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23113 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _25043 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25043] = 30
                                        mem[_25043 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _26148 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26148 + idx + 68] = mem[_25043 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26148 + 68] = mem[_26148 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26148 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _28385 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28385] = 30
                                        mem[_28385 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _30038 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_30038 + idx + 68] = mem[_28385 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30038 + 68] = mem[_30038 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _30038 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _37216 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37216] = 30
                                        mem[_37216 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _38387 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38387 + idx + 68] = mem[_37216 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38387 + 68] = mem[_38387 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38387 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23112 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23112] = 30
                                    mem[_23112 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _23633 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23633 + idx + 68] = mem[_23112 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23633 + 68] = mem[_23633 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23633 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _26147 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26147] = 30
                                    mem[_26147 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _27508 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27508 + idx + 68] = mem[_26147 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27508 + 68] = mem[_27508 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27508 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _30035 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30035] = 30
                                    mem[_30035 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _31731 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31731 + idx + 68] = mem[_30035 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31731 + 68] = mem[_31731 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31731 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _38386 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38386] = 30
                                    mem[_38386 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _39284 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39284 + idx + 68] = mem[_38386 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39284 + 68] = mem[_39284 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39284 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _21408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21408] = 30
                                    mem[_21408 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _21488 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_21488 + idx + 68] = mem[_21408 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21488 + 68] = mem[_21488 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _21488 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _21882 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21882] = 30
                                    mem[_21882 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _22004 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22004 + idx + 68] = mem[_21882 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22004 + 68] = mem[_22004 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22004 + -mem[64] + 100
                                _21439 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21439] = 26
                                mem[_21439 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22761 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22761] = 30
                                        mem[_22761 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _25052 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25052] = 30
                                        mem[_25052 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _26161 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26161 + idx + 68] = mem[_25052 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26161 + 68] = mem[_26161 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26161 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _28394 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28394] = 30
                                        mem[_28394 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _30053 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_30053 + idx + 68] = mem[_28394 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30053 + 68] = mem[_30053 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _30053 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _37223 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37223] = 30
                                        mem[_37223 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _38397 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38397 + idx + 68] = mem[_37223 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38397 + 68] = mem[_38397 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38397 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23120 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23120] = 30
                                    mem[_23120 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23643 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23643 + idx + 68] = mem[_23120 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23643 + 68] = mem[_23643 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23643 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _26160 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26160] = 30
                                    mem[_26160 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _27522 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27522 + idx + 68] = mem[_26160 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27522 + 68] = mem[_27522 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27522 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _30050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30050] = 30
                                    mem[_30050 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _31749 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31749 + idx + 68] = mem[_30050 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31749 + 68] = mem[_31749 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31749 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _38396 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38396] = 30
                                    mem[_38396 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _39296 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39296 + idx + 68] = mem[_38396 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39296 + 68] = mem[_39296 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39296 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _23119 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23119] = 30
                                    mem[_23119 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23640 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23640 + idx + 68] = mem[_23119 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23640 + 68] = mem[_23640 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23640 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _26159 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26159] = 30
                                    mem[_26159 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _27519 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27519 + idx + 68] = mem[_26159 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27519 + 68] = mem[_27519 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27519 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _30047 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30047] = 30
                                    mem[_30047 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _31746 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31746 + idx + 68] = mem[_30047 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31746 + 68] = mem[_31746 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31746 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _38395 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38395] = 30
                                    mem[_38395 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _39293 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39293 + idx + 68] = mem[_38395 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39293 + 68] = mem[_39293 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39293 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23639 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23639] = 30
                                mem[_23639 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _24402 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24402 + idx + 68] = mem[_23639 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24402 + 68] = mem[_24402 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24402 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 2
                                _27518 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27518] = 30
                                mem[_27518 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _29042 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_29042 + idx + 68] = mem[_27518 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29042 + 68] = mem[_29042 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29042 + -mem[64] + 100
                                stor2[address(msg.sender)] -= arg2
                                mem[0] = msg.sender
                                mem[32] = 1
                                _31743 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31743] = 30
                                mem[_31743 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _33263 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33263 + idx + 68] = mem[_31743 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33263 + 68] = mem[_33263 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33263 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _39292 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39292] = 30
                                mem[_39292 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _39975 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_39975 + idx + 68] = mem[_39292 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39975 + 68] = mem[_39975 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39975 + -mem[64] + 100
                            _21103 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21103] = 26
                            mem[_21103 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100 * 10^18:
                                _21573 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21573] = 26
                                mem[_21573 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                _21572 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21572] = 26
                                mem[_21572 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    if not stor4[address(arg1)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _21345 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21345] = 26
                                mem[_21345 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22590 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22590] = 30
                                        mem[_22590 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _24072 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24072] = 30
                                        mem[_24072 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _25093 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_25093 + idx + 68] = mem[_24072 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25093 + 68] = mem[_25093 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _25093 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _30119 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30119] = 30
                                        mem[_30119 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _31852 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31852 + idx + 68] = mem[_30119 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31852 + 68] = mem[_31852 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31852 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _22772 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22772] = 30
                                    mem[_22772 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23160 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23160 + idx + 68] = mem[_22772 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23160 + 68] = mem[_23160 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23160 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25092 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25092] = 30
                                    mem[_25092 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _26259 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26259 + idx + 68] = mem[_25092 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26259 + 68] = mem[_26259 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26259 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _31851 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31851] = 30
                                    mem[_31851 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33382 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33382 + idx + 68] = mem[_31851 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33382 + 68] = mem[_33382 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33382 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _22771 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22771] = 30
                                    mem[_22771 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23157 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23157 + idx + 68] = mem[_22771 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23157 + 68] = mem[_23157 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23157 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25091 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25091] = 30
                                    mem[_25091 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _26256 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26256 + idx + 68] = mem[_25091 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26256 + 68] = mem[_26256 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26256 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _31850 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31850] = 30
                                    mem[_31850 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33379 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33379 + idx + 68] = mem[_31850 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33379 + 68] = mem[_33379 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33379 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23156 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23156] = 30
                                mem[_23156 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _23701 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23701 + idx + 68] = mem[_23156 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23701 + 68] = mem[_23701 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23701 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26255 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26255] = 30
                                mem[_26255 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27648 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27648 + idx + 68] = mem[_26255 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27648 + 68] = mem[_27648 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27648 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _33378 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33378] = 30
                                mem[_33378 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34687 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34687 + idx + 68] = mem[_33378 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34687 + 68] = mem[_34687 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34687 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _21412 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21412] = 30
                                mem[_21412 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _21500 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_21500 + idx + 68] = mem[_21412 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21500 + 68] = mem[_21500 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _21500 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _21890 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21890] = 30
                                mem[_21890 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _22024 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_22024 + idx + 68] = mem[_21890 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22024 + 68] = mem[_22024 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _22024 + -mem[64] + 100
                            _21443 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21443] = 26
                            mem[_21443 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    _22773 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22773] = 30
                                    mem[_22773 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25100 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25100] = 30
                                    mem[_25100 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _26269 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26269 + idx + 68] = mem[_25100 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26269 + 68] = mem[_26269 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26269 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _31859 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31859] = 30
                                    mem[_31859 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33389 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33389 + idx + 68] = mem[_31859 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33389 + 68] = mem[_33389 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33389 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23164 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23164] = 30
                                mem[_23164 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    _23711 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23711 + idx + 68] = mem[_23164 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23711 + 68] = mem[_23711 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23711 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26268 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26268] = 30
                                mem[_26268 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _27664 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27664 + idx + 68] = mem[_26268 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27664 + 68] = mem[_27664 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27664 + -mem[64] + 100
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                _33388 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33388] = 30
                                mem[_33388 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34699 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34699 + idx + 68] = mem[_33388 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34699 + 68] = mem[_34699 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34699 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                _23163 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23163] = 30
                                mem[_23163 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    _23708 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23708 + idx + 68] = mem[_23163 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23708 + 68] = mem[_23708 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23708 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26267 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26267] = 30
                                mem[_26267 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27661 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27661 + idx + 68] = mem[_26267 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27661 + 68] = mem[_27661 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27661 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                _33387 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33387] = 30
                                mem[_33387 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34696 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34696 + idx + 68] = mem[_33387 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34696 + 68] = mem[_34696 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34696 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23707 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23707] = 30
                            mem[_23707 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                _24502 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24502 + idx + 68] = mem[_23707 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24502 + 68] = mem[_24502 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24502 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _27660 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27660] = 30
                            mem[_27660 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _29198 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_29198 + idx + 68] = mem[_27660 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29198 + 68] = mem[_29198 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _29198 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                            _34695 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34695] = 30
                            mem[_34695 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _36006 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_36006 + idx + 68] = mem[_34695 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_36006 + 68] = mem[_36006 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36006 + -mem[64] + 100
                        _21123 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21123] = 26
                        mem[_21123 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100 * 10^18:
                            _21581 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21581] = 26
                            mem[_21581 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        else:
                            _21580 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21580] = 26
                            mem[_21580 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                    else:
                        mem[0] = msg.sender
                        mem[32] = 4
                        if not stor4[address(msg.sender)]:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _21336 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21336] = 26
                                    mem[_21336 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22587 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22587] = 30
                                            mem[_22587 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _24057 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24057] = 30
                                            mem[_24057 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _25057 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_25057 + idx + 68] = mem[_24057 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25057 + 68] = mem[_25057 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _25057 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _30064 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30064] = 30
                                            mem[_30064 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _31768 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_31768 + idx + 68] = mem[_30064 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31768 + 68] = mem[_31768 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _31768 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _22763 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22763] = 30
                                        mem[_22763 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23127 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23127 + idx + 68] = mem[_22763 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23127 + 68] = mem[_23127 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23127 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25056 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25056] = 30
                                        mem[_25056 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26178 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26178 + idx + 68] = mem[_25056 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26178 + 68] = mem[_26178 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26178 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _31767 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31767] = 30
                                        mem[_31767 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33289 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33289 + idx + 68] = mem[_31767 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33289 + 68] = mem[_33289 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33289 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _22762 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22762] = 30
                                        mem[_22762 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23124 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23124 + idx + 68] = mem[_22762 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23124 + 68] = mem[_23124 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23124 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25055 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25055] = 30
                                        mem[_25055 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _26175 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26175 + idx + 68] = mem[_25055 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26175 + 68] = mem[_26175 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26175 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _31766 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31766] = 30
                                        mem[_31766 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33286 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33286 + idx + 68] = mem[_31766 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33286 + 68] = mem[_33286 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33286 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23123 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23123] = 30
                                    mem[_23123 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _23650 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23650 + idx + 68] = mem[_23123 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23650 + 68] = mem[_23650 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23650 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26174 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26174] = 30
                                    mem[_26174 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27542 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27542 + idx + 68] = mem[_26174 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27542 + 68] = mem[_27542 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27542 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _33285 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33285] = 30
                                    mem[_33285 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34594 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34594 + idx + 68] = mem[_33285 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34594 + 68] = mem[_34594 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34594 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _21409 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21409] = 30
                                    mem[_21409 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _21491 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_21491 + idx + 68] = mem[_21409 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21491 + 68] = mem[_21491 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _21491 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _21884 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21884] = 30
                                    mem[_21884 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _22009 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22009 + idx + 68] = mem[_21884 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22009 + 68] = mem[_22009 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22009 + -mem[64] + 100
                                _21440 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21440] = 26
                                mem[_21440 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22764 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22764] = 30
                                        mem[_22764 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25064 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25064] = 30
                                        mem[_25064 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26188 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26188 + idx + 68] = mem[_25064 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26188 + 68] = mem[_26188 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26188 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _31775 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31775] = 30
                                        mem[_31775 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33296 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33296 + idx + 68] = mem[_31775 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33296 + 68] = mem[_33296 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33296 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23131 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23131] = 30
                                    mem[_23131 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23660 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23660 + idx + 68] = mem[_23131 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23660 + 68] = mem[_23660 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23660 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26187 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26187] = 30
                                    mem[_26187 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _27558 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27558 + idx + 68] = mem[_26187 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27558 + 68] = mem[_27558 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27558 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _33295 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33295] = 30
                                    mem[_33295 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34606 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34606 + idx + 68] = mem[_33295 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34606 + 68] = mem[_34606 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34606 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _23130 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23130] = 30
                                    mem[_23130 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23657 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23657 + idx + 68] = mem[_23130 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23657 + 68] = mem[_23657 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23657 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26186 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26186] = 30
                                    mem[_26186 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27555 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27555 + idx + 68] = mem[_26186 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27555 + 68] = mem[_27555 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27555 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _33294 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33294] = 30
                                    mem[_33294 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34603 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34603 + idx + 68] = mem[_33294 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34603 + 68] = mem[_34603 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34603 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23656 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23656] = 30
                                mem[_23656 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _24427 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24427 + idx + 68] = mem[_23656 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24427 + 68] = mem[_24427 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24427 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _27554 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27554] = 30
                                mem[_27554 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _29081 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_29081 + idx + 68] = mem[_27554 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29081 + 68] = mem[_29081 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29081 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _34602 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34602] = 30
                                mem[_34602 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _35915 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_35915 + idx + 68] = mem[_34602 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35915 + 68] = mem[_35915 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35915 + -mem[64] + 100
                            _21108 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21108] = 26
                            mem[_21108 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100 * 10^18:
                                _21575 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21575] = 26
                                mem[_21575 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                _21574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21574] = 26
                                mem[_21574 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                        else:
                            mem[0] = arg1
                            mem[32] = 4
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not stor4[address(arg1)]:
                                idx = 0
                                s = 100 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _21339 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21339] = 26
                                        mem[_21339 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100:
                                                _22588 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22588] = 30
                                                mem[_22588 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _24062 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24062] = 30
                                                mem[_24062 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _25069 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_25069 + idx + 68] = mem[_24062 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_25069 + 68] = mem[_25069 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _25069 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _30078 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_30078] = 30
                                                mem[_30078 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _31789 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_31789 + idx + 68] = mem[_30078 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_31789 + 68] = mem[_31789 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _31789 + -mem[64] + 100
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _22766 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22766] = 30
                                            mem[_22766 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                _23138 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23138 + idx + 68] = mem[_22766 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23138 + 68] = mem[_23138 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23138 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25068 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25068] = 30
                                            mem[_25068 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _26205 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26205 + idx + 68] = mem[_25068 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26205 + 68] = mem[_26205 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26205 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            _31788 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31788] = 30
                                            mem[_31788 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33313 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33313 + idx + 68] = mem[_31788 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33313 + 68] = mem[_33313 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33313 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            _22765 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22765] = 30
                                            mem[_22765 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                _23135 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23135 + idx + 68] = mem[_22765 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23135 + 68] = mem[_23135 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23135 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25067 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25067] = 30
                                            mem[_25067 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                _26202 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26202 + idx + 68] = mem[_25067 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26202 + 68] = mem[_26202 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26202 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            _31787 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31787] = 30
                                            mem[_31787 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33310 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33310 + idx + 68] = mem[_31787 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33310 + 68] = mem[_33310 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33310 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23134 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23134] = 30
                                        mem[_23134 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            _23667 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23667 + idx + 68] = mem[_23134 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23667 + 68] = mem[_23667 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23667 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26201 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26201] = 30
                                        mem[_26201 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _27578 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27578 + idx + 68] = mem[_26201 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27578 + 68] = mem[_27578 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27578 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        _33309 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33309] = 30
                                        mem[_33309 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _34622 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_34622 + idx + 68] = mem[_33309 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34622 + 68] = mem[_34622 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34622 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _21410 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21410] = 30
                                        mem[_21410 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _21494 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_21494 + idx + 68] = mem[_21410 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21494 + 68] = mem[_21494 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _21494 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _21886 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21886] = 30
                                        mem[_21886 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _22014 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22014 + idx + 68] = mem[_21886 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22014 + 68] = mem[_22014 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22014 + -mem[64] + 100
                                    _21441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21441] = 26
                                    mem[_21441 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22767 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22767] = 30
                                            mem[_22767 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25076 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25076] = 30
                                            mem[_25076 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _26215 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26215 + idx + 68] = mem[_25076 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26215 + 68] = mem[_26215 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26215 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _31796 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31796] = 30
                                            mem[_31796 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33320 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33320 + idx + 68] = mem[_31796 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33320 + 68] = mem[_33320 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33320 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23142 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23142] = 30
                                        mem[_23142 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23677 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23677 + idx + 68] = mem[_23142 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23677 + 68] = mem[_23677 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23677 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26214 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26214] = 30
                                        mem[_26214 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _27594 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27594 + idx + 68] = mem[_26214 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27594 + 68] = mem[_27594 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27594 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _33319 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33319] = 30
                                        mem[_33319 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _34634 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_34634 + idx + 68] = mem[_33319 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34634 + 68] = mem[_34634 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34634 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _23141 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23141] = 30
                                        mem[_23141 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23674 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23674 + idx + 68] = mem[_23141 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23674 + 68] = mem[_23674 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23674 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26213 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26213] = 30
                                        mem[_26213 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _27591 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27591 + idx + 68] = mem[_26213 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27591 + 68] = mem[_27591 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27591 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _33318 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33318] = 30
                                        mem[_33318 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _34631 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_34631 + idx + 68] = mem[_33318 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34631 + 68] = mem[_34631 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34631 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23673 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23673] = 30
                                    mem[_23673 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _24452 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24452 + idx + 68] = mem[_23673 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24452 + 68] = mem[_24452 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24452 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _27590 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27590] = 30
                                    mem[_27590 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _29122 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_29122 + idx + 68] = mem[_27590 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29122 + 68] = mem[_29122 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _29122 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _34630 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34630] = 30
                                    mem[_34630 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _35948 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35948 + idx + 68] = mem[_34630 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35948 + 68] = mem[_35948 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35948 + -mem[64] + 100
                                _21113 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21113] = 26
                                mem[_21113 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 100 * 10^18:
                                    _21577 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21577] = 26
                                    mem[_21577 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    _21576 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21576] = 26
                                    mem[_21576 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                            else:
                                idx = 0
                                s = 100 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _21342 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21342] = 26
                                        mem[_21342 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100:
                                                _22589 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22589] = 30
                                                mem[_22589 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _24067 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24067] = 30
                                                mem[_24067 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _25081 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_25081 + idx + 68] = mem[_24067 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_25081 + 68] = mem[_25081 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _25081 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _26912 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_26912] = 30
                                                mem[_26912 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _28429 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_28429 + idx + 68] = mem[_26912 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_28429 + 68] = mem[_28429 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _28429 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _35976 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35976] = 30
                                                mem[_35976 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _37299 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_37299 + idx + 68] = mem[_35976 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37299 + 68] = mem[_37299 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37299 + -mem[64] + 100
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _22769 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22769] = 30
                                            mem[_22769 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                _23149 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23149 + idx + 68] = mem[_22769 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23149 + 68] = mem[_23149 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23149 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _25080 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25080] = 30
                                            mem[_25080 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _26232 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26232 + idx + 68] = mem[_25080 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26232 + 68] = mem[_26232 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26232 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _28426 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28426] = 30
                                            mem[_28426 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _30096 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_30096 + idx + 68] = mem[_28426 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30096 + 68] = mem[_30096 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _30096 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            _37298 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37298] = 30
                                            mem[_37298 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _38464 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38464 + idx + 68] = mem[_37298 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38464 + 68] = mem[_38464 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38464 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            _22768 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22768] = 30
                                            mem[_22768 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                _23146 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23146 + idx + 68] = mem[_22768 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23146 + 68] = mem[_23146 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23146 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _25079 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25079] = 30
                                            mem[_25079 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _26229 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26229 + idx + 68] = mem[_25079 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26229 + 68] = mem[_26229 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26229 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _28423 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28423] = 30
                                            mem[_28423 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                _30093 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_30093 + idx + 68] = mem[_28423 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30093 + 68] = mem[_30093 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _30093 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            _37297 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37297] = 30
                                            mem[_37297 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _38461 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38461 + idx + 68] = mem[_37297 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38461 + 68] = mem[_38461 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38461 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23145 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23145] = 30
                                        mem[_23145 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            _23684 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23684 + idx + 68] = mem[_23145 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23684 + 68] = mem[_23684 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23684 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _26228 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26228] = 30
                                        mem[_26228 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _27614 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27614 + idx + 68] = mem[_26228 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27614 + 68] = mem[_27614 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27614 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _30090 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30090] = 30
                                        mem[_30090 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _31815 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_31815 + idx + 68] = mem[_30090 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31815 + 68] = mem[_31815 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _31815 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        _38460 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38460] = 30
                                        mem[_38460 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _39344 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39344 + idx + 68] = mem[_38460 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39344 + 68] = mem[_39344 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39344 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _21411 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21411] = 30
                                        mem[_21411 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _21497 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_21497 + idx + 68] = mem[_21411 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21497 + 68] = mem[_21497 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _21497 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _21888 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21888] = 30
                                        mem[_21888 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _22019 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22019 + idx + 68] = mem[_21888 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22019 + 68] = mem[_22019 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22019 + -mem[64] + 100
                                    _21442 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21442] = 26
                                    mem[_21442 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22770 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22770] = 30
                                            mem[_22770 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _25088 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25088] = 30
                                            mem[_25088 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _26242 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26242 + idx + 68] = mem[_25088 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26242 + 68] = mem[_26242 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26242 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _28432 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28432] = 30
                                            mem[_28432 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _30108 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_30108 + idx + 68] = mem[_28432 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30108 + 68] = mem[_30108 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _30108 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _37304 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37304] = 30
                                            mem[_37304 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _38471 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38471 + idx + 68] = mem[_37304 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38471 + 68] = mem[_38471 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38471 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23153 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23153] = 30
                                        mem[_23153 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23694 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23694 + idx + 68] = mem[_23153 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23694 + 68] = mem[_23694 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23694 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _26241 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26241] = 30
                                        mem[_26241 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _27628 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27628 + idx + 68] = mem[_26241 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27628 + 68] = mem[_27628 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27628 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _30105 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30105] = 30
                                        mem[_30105 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _31833 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_31833 + idx + 68] = mem[_30105 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31833 + 68] = mem[_31833 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _31833 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _38470 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38470] = 30
                                        mem[_38470 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _39356 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39356 + idx + 68] = mem[_38470 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39356 + 68] = mem[_39356 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39356 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _23152 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23152] = 30
                                        mem[_23152 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23691 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23691 + idx + 68] = mem[_23152 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23691 + 68] = mem[_23691 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23691 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _26240 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26240] = 30
                                        mem[_26240 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _27625 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27625 + idx + 68] = mem[_26240 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27625 + 68] = mem[_27625 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27625 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _30102 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30102] = 30
                                        mem[_30102 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _31830 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_31830 + idx + 68] = mem[_30102 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31830 + 68] = mem[_31830 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _31830 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _38469 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38469] = 30
                                        mem[_38469 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _39353 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39353 + idx + 68] = mem[_38469 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39353 + 68] = mem[_39353 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39353 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23690 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23690] = 30
                                    mem[_23690 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _24477 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24477 + idx + 68] = mem[_23690 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24477 + 68] = mem[_24477 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24477 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _27624 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27624] = 30
                                    mem[_27624 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _29159 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_29159 + idx + 68] = mem[_27624 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29159 + 68] = mem[_29159 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _29159 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _31827 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31827] = 30
                                    mem[_31827 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _33356 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33356 + idx + 68] = mem[_31827 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33356 + 68] = mem[_33356 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33356 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _39352 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39352] = 30
                                    mem[_39352 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _40016 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_40016 + idx + 68] = mem[_39352 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40016 + 68] = mem[_40016 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40016 + -mem[64] + 100
                                _21118 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21118] = 26
                                mem[_21118 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 100 * 10^18:
                                    _21579 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21579] = 26
                                    mem[_21579 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    _21578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21578] = 26
                                    mem[_21578 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
    else:
        mem[0] = arg1
        mem[32] = 4
        if not stor4[address(arg1)]:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            mem[64] = 224
            mem[160] = 30
            mem[192] = 'SafeMath: subtraction overflow'
            if arg2 / 100 > arg2:
                revert with 0, 'SafeMath: subtraction overflow'
            idx = 0
            s = 100 * 10^18
            t = stor6
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _21396 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21396] = 26
                    mem[_21396 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if not arg2 / 100:
                            _22607 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22607] = 30
                            mem[_22607 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 2
                            _24157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24157] = 30
                            mem[_24157 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _25297 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_25297 + idx + 68] = mem[_24157 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25297 + 68] = mem[_25297 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _25297 + -mem[64] + 100
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _27169 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27169] = 30
                            mem[_27169 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _28654 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_28654 + idx + 68] = mem[_27169 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28654 + 68] = mem[_28654 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _28654 + -mem[64] + 100
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _34269 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34269] = 30
                            mem[_34269 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _35576 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_35576 + idx + 68] = mem[_34269 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_35576 + 68] = mem[_35576 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35576 + -mem[64] + 100
                        require arg2 / 100
                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _22823 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22823] = 30
                        mem[_22823 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                            _23347 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_23347 + idx + 68] = mem[_22823 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23347 + 68] = mem[_23347 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _23347 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 2
                        _25296 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25296] = 30
                        mem[_25296 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _26718 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_26718 + idx + 68] = mem[_25296 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_26718 + 68] = mem[_26718 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _26718 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _28651 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28651] = 30
                        mem[_28651 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _30421 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_30421 + idx + 68] = mem[_28651 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_30421 + 68] = mem[_30421 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30421 + -mem[64] + 100
                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        _35575 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35575] = 30
                        mem[_35575 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            if totalFees + (arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100
                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                            return 1
                        _36939 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_36939 + idx + 68] = mem[_35575 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_36939 + 68] = mem[_36939 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36939 + -mem[64] + 100
                    require arg2
                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not arg2 / 100:
                        _22822 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22822] = 30
                        mem[_22822 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 100 * 10^18:
                            _23344 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_23344 + idx + 68] = mem[_22822 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23344 + 68] = mem[_23344 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _23344 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 2
                        _25295 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25295] = 30
                        mem[_25295 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _26715 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_26715 + idx + 68] = mem[_25295 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_26715 + 68] = mem[_26715 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _26715 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _28648 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28648] = 30
                        mem[_28648 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                            _30418 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_30418 + idx + 68] = mem[_28648 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_30418 + 68] = mem[_30418 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30418 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                        _35574 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35574] = 30
                        mem[_35574 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if totalFees + (arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100
                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                            return 1
                        _36936 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_36936 + idx + 68] = mem[_35574 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_36936 + 68] = mem[_36936 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36936 + -mem[64] + 100
                    require arg2 / 100
                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _23343 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23343] = 30
                    mem[_23343 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                        _23990 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_23990 + idx + 68] = mem[_23343 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_23990 + 68] = mem[_23990 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _23990 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 2
                    _26714 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26714] = 30
                    mem[_26714 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _28252 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_28252 + idx + 68] = mem[_26714 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_28252 + 68] = mem[_28252 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _28252 + -mem[64] + 100
                    stor2[address(msg.sender)] -= arg2
                    mem[0] = msg.sender
                    mem[32] = 1
                    _30415 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30415] = 30
                    mem[_30415 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                        _32308 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_32308 + idx + 68] = mem[_30415 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_32308 + 68] = mem[_32308 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _32308 + -mem[64] + 100
                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                    _36935 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_36935] = 30
                    mem[_36935 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        if totalFees + (arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg2 / 100
                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                        return 1
                    _38135 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_38135 + idx + 68] = mem[_36935 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_38135 + 68] = mem[_38135 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _38135 + -mem[64] + 100
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] <= s:
                    require idx < stor5.length
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    _21429 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21429] = 30
                    mem[_21429 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor5[idx]] > t:
                        _21551 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_21551 + idx + 68] = mem[_21429 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_21551 + 68] = mem[_21551 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _21551 + -mem[64] + 100
                    require idx < stor5.length
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    _21924 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21924] = 30
                    mem[_21924 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor5[idx]] <= s:
                        idx = idx + 1
                        s = s - stor2[stor5[idx]]
                        t = t - stor1[stor5[idx]]
                        continue 
                    _22109 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_22109 + idx + 68] = mem[_21924 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_22109 + 68] = mem[_22109 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _22109 + -mem[64] + 100
                _21460 = mem[64]
                mem[64] = mem[64] + 64
                mem[_21460] = 26
                mem[_21460 + 32] = 'SafeMath: division by zero'
                if not arg2:
                    if not arg2 / 100:
                        _22824 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22824] = 30
                        mem[_22824 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 2
                        _25304 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25304] = 30
                        mem[_25304 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _26728 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_26728 + idx + 68] = mem[_25304 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_26728 + 68] = mem[_26728 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _26728 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _28657 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28657] = 30
                        mem[_28657 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _30433 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_30433 + idx + 68] = mem[_28657 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_30433 + 68] = mem[_30433 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _30433 + -mem[64] + 100
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        _35583 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35583] = 30
                        mem[_35583 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if totalFees + (arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100
                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                            return 1
                        _36946 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_36946 + idx + 68] = mem[_35583 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_36946 + 68] = mem[_36946 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36946 + -mem[64] + 100
                    require arg2 / 100
                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _23351 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23351] = 30
                    mem[_23351 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                        _24000 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_24000 + idx + 68] = mem[_23351 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_24000 + 68] = mem[_24000 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _24000 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 2
                    _26727 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26727] = 30
                    mem[_26727 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _28266 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_28266 + idx + 68] = mem[_26727 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_28266 + 68] = mem[_28266 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _28266 + -mem[64] + 100
                    stor2[address(msg.sender)] -= arg2
                    mem[0] = msg.sender
                    mem[32] = 1
                    _30430 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30430] = 30
                    mem[_30430 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _32326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_32326 + idx + 68] = mem[_30430 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_32326 + 68] = mem[_32326 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _32326 + -mem[64] + 100
                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                    _36945 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_36945] = 30
                    mem[_36945 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        if totalFees + (arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg2 / 100
                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                        return 1
                    _38147 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_38147 + idx + 68] = mem[_36945 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_38147 + 68] = mem[_38147 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _38147 + -mem[64] + 100
                require arg2
                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not arg2 / 100:
                    _23350 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23350] = 30
                    mem[_23350 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg2 * stor6 / 100 * 10^18:
                        _23997 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_23997 + idx + 68] = mem[_23350 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_23997 + 68] = mem[_23997 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _23997 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 2
                    _26726 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26726] = 30
                    mem[_26726 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _28263 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_28263 + idx + 68] = mem[_26726 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_28263 + 68] = mem[_28263 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _28263 + -mem[64] + 100
                    stor2[address(msg.sender)] -= arg2
                    mem[0] = msg.sender
                    mem[32] = 1
                    _30427 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30427] = 30
                    mem[_30427 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                        _32323 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_32323 + idx + 68] = mem[_30427 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_32323 + 68] = mem[_32323 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _32323 + -mem[64] + 100
                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                    _36944 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_36944] = 30
                    mem[_36944 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if totalFees + (arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg2 / 100
                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                        return 1
                    _38144 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_38144 + idx + 68] = mem[_36944 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_38144 + 68] = mem[_38144 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _38144 + -mem[64] + 100
                require arg2 / 100
                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _23996 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23996] = 30
                mem[_23996 + 32] = 'SafeMath: subtraction overflow'
                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                    _24927 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_24927 + idx + 68] = mem[_23996 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_24927 + 68] = mem[_24927 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _24927 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 2
                _28262 = mem[64]
                mem[64] = mem[64] + 64
                mem[_28262] = 30
                mem[_28262 + 32] = 'SafeMath: subtraction overflow'
                if arg2 > stor2[address(msg.sender)]:
                    _29867 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_29867 + idx + 68] = mem[_28262 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_29867 + 68] = mem[_29867 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _29867 + -mem[64] + 100
                stor2[address(msg.sender)] -= arg2
                mem[0] = msg.sender
                mem[32] = 1
                _32320 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32320] = 30
                mem[_32320 + 32] = 'SafeMath: subtraction overflow'
                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                    _33893 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_33893 + idx + 68] = mem[_32320 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_33893 + 68] = mem[_33893 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _33893 + -mem[64] + 100
                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[0] = arg1
                mem[32] = 1
                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                _38143 = mem[64]
                mem[64] = mem[64] + 64
                mem[_38143] = 30
                mem[_38143 + 32] = 'SafeMath: subtraction overflow'
                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                    if totalFees + (arg2 / 100) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg2 / 100
                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                    return 1
                _39094 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_39094 + idx + 68] = mem[_38143 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_39094 + 68] = mem[_39094 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _39094 + -mem[64] + 100
            _21208 = mem[64]
            mem[64] = mem[64] + 64
            mem[_21208] = 26
            mem[_21208 + 32] = 'SafeMath: division by zero'
            if t < stor6 / 100 * 10^18:
                _21615 = mem[64]
                mem[64] = mem[64] + 64
                mem[_21615] = 26
                mem[_21615 + 32] = 'SafeMath: division by zero'
                if not arg2:
                    if not arg2 / 100:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow'
                    else:
                        require arg2 / 100
                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                else:
                    require arg2
                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not arg2 / 100:
                        if 0 > arg2 * stor6 / 100 * 10^18:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow'
                    else:
                        require arg2 / 100
                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
            else:
                _21614 = mem[64]
                mem[64] = mem[64] + 64
                mem[_21614] = 26
                mem[_21614 + 32] = 'SafeMath: division by zero'
                if s <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require s
                if not arg2:
                    if not arg2 / 100:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow'
                    else:
                        require arg2 / 100
                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if arg2 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                        if arg2 / 100 * t / s > stor6:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor6 += -1 * arg2 / 100 * t / s
                else:
                    require arg2
                    if arg2 * t / s / arg2 != t / s:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not arg2 / 100:
                        if 0 > arg2 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * t / s > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow'
                    else:
                        require arg2 / 100
                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if arg2 / 100 * t / s > arg2 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * t / s > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                        if arg2 / 100 * t / s > stor6:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor6 += -1 * arg2 / 100 * t / s
        else:
            if stor4[address(msg.sender)]:
                if stor4[address(msg.sender)]:
                    mem[0] = msg.sender
                    mem[32] = 4
                    if not stor4[address(msg.sender)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _21351 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21351] = 26
                                mem[_21351 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22592 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22592] = 30
                                        mem[_22592 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _24082 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24082] = 30
                                        mem[_24082 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _25117 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_25117 + idx + 68] = mem[_24082 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25117 + 68] = mem[_25117 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _25117 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _30151 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30151] = 30
                                        mem[_30151 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _31899 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31899 + idx + 68] = mem[_30151 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31899 + 68] = mem[_31899 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31899 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _22778 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22778] = 30
                                    mem[_22778 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23182 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23182 + idx + 68] = mem[_22778 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23182 + 68] = mem[_23182 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23182 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25116 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25116] = 30
                                    mem[_25116 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _26313 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26313 + idx + 68] = mem[_25116 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26313 + 68] = mem[_26313 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26313 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _31898 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31898] = 30
                                    mem[_31898 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33430 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33430 + idx + 68] = mem[_31898 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33430 + 68] = mem[_33430 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33430 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _22777 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22777] = 30
                                    mem[_22777 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23179 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23179 + idx + 68] = mem[_22777 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23179 + 68] = mem[_23179 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23179 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25115 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25115] = 30
                                    mem[_25115 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _26310 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26310 + idx + 68] = mem[_25115 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26310 + 68] = mem[_26310 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26310 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _31897 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31897] = 30
                                    mem[_31897 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33427 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33427 + idx + 68] = mem[_31897 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33427 + 68] = mem[_33427 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33427 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23178] = 30
                                mem[_23178 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _23735 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23735 + idx + 68] = mem[_23178 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23735 + 68] = mem[_23735 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23735 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26309 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26309] = 30
                                mem[_26309 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27720 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27720 + idx + 68] = mem[_26309 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27720 + 68] = mem[_27720 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27720 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _33426 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33426] = 30
                                mem[_33426 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34729 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34729 + idx + 68] = mem[_33426 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34729 + 68] = mem[_34729 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34729 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _21414 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21414] = 30
                                mem[_21414 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _21506 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_21506 + idx + 68] = mem[_21414 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21506 + 68] = mem[_21506 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _21506 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _21894 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21894] = 30
                                mem[_21894 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _22034 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_22034 + idx + 68] = mem[_21894 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22034 + 68] = mem[_22034 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _22034 + -mem[64] + 100
                            _21445 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21445] = 26
                            mem[_21445 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    _22779 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22779] = 30
                                    mem[_22779 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25124 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25124] = 30
                                    mem[_25124 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _26323 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26323 + idx + 68] = mem[_25124 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26323 + 68] = mem[_26323 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26323 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _31906 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31906] = 30
                                    mem[_31906 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33437 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33437 + idx + 68] = mem[_31906 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33437 + 68] = mem[_33437 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33437 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23186 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23186] = 30
                                mem[_23186 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    _23745 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23745 + idx + 68] = mem[_23186 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23745 + 68] = mem[_23745 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23745 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26322 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26322] = 30
                                mem[_26322 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _27736 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27736 + idx + 68] = mem[_26322 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27736 + 68] = mem[_27736 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27736 + -mem[64] + 100
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                _33436 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33436] = 30
                                mem[_33436 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34741 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34741 + idx + 68] = mem[_33436 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34741 + 68] = mem[_34741 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34741 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                _23185 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23185] = 30
                                mem[_23185 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    _23742 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23742 + idx + 68] = mem[_23185 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23742 + 68] = mem[_23742 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23742 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26321 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26321] = 30
                                mem[_26321 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27733 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27733 + idx + 68] = mem[_26321 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27733 + 68] = mem[_27733 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27733 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                _33435 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33435] = 30
                                mem[_33435 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34738 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34738 + idx + 68] = mem[_33435 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34738 + 68] = mem[_34738 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34738 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23741 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23741] = 30
                            mem[_23741 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                _24552 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24552 + idx + 68] = mem[_23741 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24552 + 68] = mem[_24552 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24552 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _27732 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27732] = 30
                            mem[_27732 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _29280 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_29280 + idx + 68] = mem[_27732 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29280 + 68] = mem[_29280 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _29280 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                            _34737 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34737] = 30
                            mem[_34737 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _36045 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_36045 + idx + 68] = mem[_34737 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_36045 + 68] = mem[_36045 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36045 + -mem[64] + 100
                        _21133 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21133] = 26
                        mem[_21133 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100 * 10^18:
                            _21585 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21585] = 26
                            mem[_21585 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        else:
                            _21584 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21584] = 26
                            mem[_21584 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not stor4[address(arg1)]:
                            idx = 0
                            s = 100 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _21354 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21354] = 26
                                    mem[_21354 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22593 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22593] = 30
                                            mem[_22593 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _24087 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24087] = 30
                                            mem[_24087 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _25129 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_25129 + idx + 68] = mem[_24087 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25129 + 68] = mem[_25129 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _25129 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _30165 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30165] = 30
                                            mem[_30165 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _31920 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_31920 + idx + 68] = mem[_30165 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31920 + 68] = mem[_31920 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _31920 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _22781 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22781] = 30
                                        mem[_22781 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23193 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23193 + idx + 68] = mem[_22781 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23193 + 68] = mem[_23193 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23193 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25128 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25128] = 30
                                        mem[_25128 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26340 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26340 + idx + 68] = mem[_25128 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26340 + 68] = mem[_26340 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26340 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _31919 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31919] = 30
                                        mem[_31919 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33454 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33454 + idx + 68] = mem[_31919 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33454 + 68] = mem[_33454 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33454 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _22780 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22780] = 30
                                        mem[_22780 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23190 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23190 + idx + 68] = mem[_22780 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23190 + 68] = mem[_23190 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23190 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25127 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25127] = 30
                                        mem[_25127 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _26337 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26337 + idx + 68] = mem[_25127 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26337 + 68] = mem[_26337 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26337 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _31918 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31918] = 30
                                        mem[_31918 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33451 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33451 + idx + 68] = mem[_31918 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33451 + 68] = mem[_33451 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33451 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23189 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23189] = 30
                                    mem[_23189 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _23752 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23752 + idx + 68] = mem[_23189 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23752 + 68] = mem[_23752 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23752 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26336 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26336] = 30
                                    mem[_26336 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27756 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27756 + idx + 68] = mem[_26336 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27756 + 68] = mem[_27756 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27756 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _33450 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33450] = 30
                                    mem[_33450 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34757 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34757 + idx + 68] = mem[_33450 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34757 + 68] = mem[_34757 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34757 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _21415 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21415] = 30
                                    mem[_21415 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _21509 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_21509 + idx + 68] = mem[_21415 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21509 + 68] = mem[_21509 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _21509 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _21896 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21896] = 30
                                    mem[_21896 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _22039 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22039 + idx + 68] = mem[_21896 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22039 + 68] = mem[_22039 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22039 + -mem[64] + 100
                                _21446 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21446] = 26
                                mem[_21446 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22782 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22782] = 30
                                        mem[_22782 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25136 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25136] = 30
                                        mem[_25136 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26350 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26350 + idx + 68] = mem[_25136 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26350 + 68] = mem[_26350 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26350 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _31927 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31927] = 30
                                        mem[_31927 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33461 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33461 + idx + 68] = mem[_31927 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33461 + 68] = mem[_33461 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33461 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23197 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23197] = 30
                                    mem[_23197 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23762 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23762 + idx + 68] = mem[_23197 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23762 + 68] = mem[_23762 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23762 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26349 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26349] = 30
                                    mem[_26349 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _27772 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27772 + idx + 68] = mem[_26349 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27772 + 68] = mem[_27772 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27772 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _33460 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33460] = 30
                                    mem[_33460 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34769 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34769 + idx + 68] = mem[_33460 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34769 + 68] = mem[_34769 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34769 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _23196 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23196] = 30
                                    mem[_23196 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23759 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23759 + idx + 68] = mem[_23196 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23759 + 68] = mem[_23759 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23759 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26348 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26348] = 30
                                    mem[_26348 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27769 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27769 + idx + 68] = mem[_26348 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27769 + 68] = mem[_27769 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27769 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _33459 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33459] = 30
                                    mem[_33459 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34766 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34766 + idx + 68] = mem[_33459 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34766 + 68] = mem[_34766 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34766 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23758 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23758] = 30
                                mem[_23758 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _24577 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24577 + idx + 68] = mem[_23758 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24577 + 68] = mem[_24577 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24577 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _27768 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27768] = 30
                                mem[_27768 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _29321 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_29321 + idx + 68] = mem[_27768 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29321 + 68] = mem[_29321 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29321 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _34765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34765] = 30
                                mem[_34765 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _36078 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_36078 + idx + 68] = mem[_34765 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36078 + 68] = mem[_36078 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36078 + -mem[64] + 100
                            _21138 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21138] = 26
                            mem[_21138 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100 * 10^18:
                                _21587 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21587] = 26
                                mem[_21587 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                _21586 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21586] = 26
                                mem[_21586 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                        else:
                            idx = 0
                            s = 100 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _21357 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21357] = 26
                                    mem[_21357 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22594 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22594] = 30
                                            mem[_22594 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _24092 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24092] = 30
                                            mem[_24092 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _25141 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_25141 + idx + 68] = mem[_24092 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25141 + 68] = mem[_25141 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _25141 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _26983 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26983] = 30
                                            mem[_26983 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _28490 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_28490 + idx + 68] = mem[_26983 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_28490 + 68] = mem[_28490 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _28490 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _36106 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36106] = 30
                                            mem[_36106 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _37418 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37418 + idx + 68] = mem[_36106 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37418 + 68] = mem[_37418 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37418 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _22784 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22784] = 30
                                        mem[_22784 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23204 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23204 + idx + 68] = mem[_22784 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23204 + 68] = mem[_23204 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23204 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _25140 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25140] = 30
                                        mem[_25140 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _26367 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26367 + idx + 68] = mem[_25140 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26367 + 68] = mem[_26367 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26367 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _28487 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28487] = 30
                                        mem[_28487 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _30183 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_30183 + idx + 68] = mem[_28487 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30183 + 68] = mem[_30183 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _30183 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _37417 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37417] = 30
                                        mem[_37417 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _38575 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38575 + idx + 68] = mem[_37417 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38575 + 68] = mem[_38575 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38575 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _22783 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22783] = 30
                                        mem[_22783 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23201 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23201 + idx + 68] = mem[_22783 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23201 + 68] = mem[_23201 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23201 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _25139 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25139] = 30
                                        mem[_25139 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _26364 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26364 + idx + 68] = mem[_25139 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26364 + 68] = mem[_26364 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26364 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _28484 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28484] = 30
                                        mem[_28484 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _30180 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_30180 + idx + 68] = mem[_28484 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30180 + 68] = mem[_30180 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _30180 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _37416 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37416] = 30
                                        mem[_37416 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _38572 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38572 + idx + 68] = mem[_37416 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38572 + 68] = mem[_38572 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38572 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23200 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23200] = 30
                                    mem[_23200 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _23769 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23769 + idx + 68] = mem[_23200 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23769 + 68] = mem[_23769 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23769 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _26363 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26363] = 30
                                    mem[_26363 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _27792 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27792 + idx + 68] = mem[_26363 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27792 + 68] = mem[_27792 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27792 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _30177 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30177] = 30
                                    mem[_30177 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _31946 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31946 + idx + 68] = mem[_30177 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31946 + 68] = mem[_31946 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31946 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _38571 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38571] = 30
                                    mem[_38571 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _39432 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39432 + idx + 68] = mem[_38571 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39432 + 68] = mem[_39432 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39432 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _21416 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21416] = 30
                                    mem[_21416 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _21512 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_21512 + idx + 68] = mem[_21416 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21512 + 68] = mem[_21512 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _21512 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _21898 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21898] = 30
                                    mem[_21898 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _22044 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22044 + idx + 68] = mem[_21898 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22044 + 68] = mem[_22044 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22044 + -mem[64] + 100
                                _21447 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21447] = 26
                                mem[_21447 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22785 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22785] = 30
                                        mem[_22785 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _25148 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25148] = 30
                                        mem[_25148 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _26377 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26377 + idx + 68] = mem[_25148 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26377 + 68] = mem[_26377 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26377 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _28493 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28493] = 30
                                        mem[_28493 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _30195 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_30195 + idx + 68] = mem[_28493 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30195 + 68] = mem[_30195 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _30195 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _37423 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37423] = 30
                                        mem[_37423 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _38582 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38582 + idx + 68] = mem[_37423 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38582 + 68] = mem[_38582 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38582 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23208 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23208] = 30
                                    mem[_23208 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23779 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23779 + idx + 68] = mem[_23208 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23779 + 68] = mem[_23779 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23779 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _26376 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26376] = 30
                                    mem[_26376 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _27806 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27806 + idx + 68] = mem[_26376 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27806 + 68] = mem[_27806 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27806 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _30192 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30192] = 30
                                    mem[_30192 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _31964 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31964 + idx + 68] = mem[_30192 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31964 + 68] = mem[_31964 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31964 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _38581 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38581] = 30
                                    mem[_38581 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _39444 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39444 + idx + 68] = mem[_38581 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39444 + 68] = mem[_39444 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39444 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _23207 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23207] = 30
                                    mem[_23207 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23776 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23776 + idx + 68] = mem[_23207 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23776 + 68] = mem[_23776 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23776 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _26375 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26375] = 30
                                    mem[_26375 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _27803 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27803 + idx + 68] = mem[_26375 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27803 + 68] = mem[_27803 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27803 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _30189 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30189] = 30
                                    mem[_30189 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _31961 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_31961 + idx + 68] = mem[_30189 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31961 + 68] = mem[_31961 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _31961 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _38580 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38580] = 30
                                    mem[_38580 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _39441 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39441 + idx + 68] = mem[_38580 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39441 + 68] = mem[_39441 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39441 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23775 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23775] = 30
                                mem[_23775 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _24602 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24602 + idx + 68] = mem[_23775 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24602 + 68] = mem[_24602 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24602 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 2
                                _27802 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27802] = 30
                                mem[_27802 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _29358 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_29358 + idx + 68] = mem[_27802 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29358 + 68] = mem[_29358 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29358 + -mem[64] + 100
                                stor2[address(msg.sender)] -= arg2
                                mem[0] = msg.sender
                                mem[32] = 1
                                _31958 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31958] = 30
                                mem[_31958 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _33497 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33497 + idx + 68] = mem[_31958 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33497 + 68] = mem[_33497 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33497 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _39440 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39440] = 30
                                mem[_39440 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _40073 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_40073 + idx + 68] = mem[_39440 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_40073 + 68] = mem[_40073 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _40073 + -mem[64] + 100
                            _21143 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21143] = 26
                            mem[_21143 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100 * 10^18:
                                _21589 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21589] = 26
                                mem[_21589 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                _21588 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21588] = 26
                                mem[_21588 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    if not stor4[address(arg1)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _21369 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21369] = 26
                                mem[_21369 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22598 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22598] = 30
                                        mem[_22598 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _24112 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24112] = 30
                                        mem[_24112 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _25189 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_25189 + idx + 68] = mem[_24112 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25189 + 68] = mem[_25189 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _25189 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _30261 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30261] = 30
                                        mem[_30261 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _32067 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32067 + idx + 68] = mem[_30261 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32067 + 68] = mem[_32067 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32067 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _22796 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22796] = 30
                                    mem[_22796 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23248 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23248 + idx + 68] = mem[_22796 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23248 + 68] = mem[_23248 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23248 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25188 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25188] = 30
                                    mem[_25188 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _26475 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26475 + idx + 68] = mem[_25188 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26475 + 68] = mem[_26475 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26475 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _32066 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32066] = 30
                                    mem[_32066 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33616 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33616 + idx + 68] = mem[_32066 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33616 + 68] = mem[_33616 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33616 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _22795 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22795] = 30
                                    mem[_22795 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23245 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23245 + idx + 68] = mem[_22795 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23245 + 68] = mem[_23245 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23245 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25187 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25187] = 30
                                    mem[_25187 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _26472 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26472 + idx + 68] = mem[_25187 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26472 + 68] = mem[_26472 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26472 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _32065 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32065] = 30
                                    mem[_32065 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33613 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33613 + idx + 68] = mem[_32065 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33613 + 68] = mem[_33613 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33613 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23244 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23244] = 30
                                mem[_23244 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _23837 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23837 + idx + 68] = mem[_23244 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23837 + 68] = mem[_23837 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23837 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26471 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26471] = 30
                                mem[_26471 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27932 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27932 + idx + 68] = mem[_26471 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27932 + 68] = mem[_27932 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27932 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _33612 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33612] = 30
                                mem[_33612 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34915 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34915 + idx + 68] = mem[_33612 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34915 + 68] = mem[_34915 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34915 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _21420 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21420] = 30
                                mem[_21420 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _21524 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_21524 + idx + 68] = mem[_21420 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21524 + 68] = mem[_21524 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _21524 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _21906 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21906] = 30
                                mem[_21906 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _22064 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_22064 + idx + 68] = mem[_21906 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22064 + 68] = mem[_22064 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _22064 + -mem[64] + 100
                            _21451 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21451] = 26
                            mem[_21451 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    _22797 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22797] = 30
                                    mem[_22797 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _25196 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25196] = 30
                                    mem[_25196 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _26485 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_26485 + idx + 68] = mem[_25196 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26485 + 68] = mem[_26485 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _26485 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _32074 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32074] = 30
                                    mem[_32074 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _33623 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33623 + idx + 68] = mem[_32074 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33623 + 68] = mem[_33623 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33623 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23252 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23252] = 30
                                mem[_23252 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    _23847 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23847 + idx + 68] = mem[_23252 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23847 + 68] = mem[_23847 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23847 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26484 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26484] = 30
                                mem[_26484 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _27948 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27948 + idx + 68] = mem[_26484 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27948 + 68] = mem[_27948 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27948 + -mem[64] + 100
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                _33622 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33622] = 30
                                mem[_33622 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34927 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34927 + idx + 68] = mem[_33622 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34927 + 68] = mem[_34927 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34927 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                _23251 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23251] = 30
                                mem[_23251 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    _23844 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23844 + idx + 68] = mem[_23251 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23844 + 68] = mem[_23844 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23844 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _26483 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26483] = 30
                                mem[_26483 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _27945 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_27945 + idx + 68] = mem[_26483 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27945 + 68] = mem[_27945 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _27945 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                _33621 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33621] = 30
                                mem[_33621 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _34924 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_34924 + idx + 68] = mem[_33621 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34924 + 68] = mem[_34924 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _34924 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23843 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23843] = 30
                            mem[_23843 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                _24702 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24702 + idx + 68] = mem[_23843 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24702 + 68] = mem[_24702 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24702 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _27944 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27944] = 30
                            mem[_27944 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _29514 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_29514 + idx + 68] = mem[_27944 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29514 + 68] = mem[_29514 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _29514 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                            _34923 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34923] = 30
                            mem[_34923 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _36227 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_36227 + idx + 68] = mem[_34923 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_36227 + 68] = mem[_36227 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36227 + -mem[64] + 100
                        _21163 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21163] = 26
                        mem[_21163 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100 * 10^18:
                            _21597 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21597] = 26
                            mem[_21597 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        else:
                            _21596 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21596] = 26
                            mem[_21596 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                    if arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * t / s
                    else:
                        mem[0] = msg.sender
                        mem[32] = 4
                        if not stor4[address(msg.sender)]:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _21360 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21360] = 26
                                    mem[_21360 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22595 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22595] = 30
                                            mem[_22595 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _24097 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24097] = 30
                                            mem[_24097 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _25153 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_25153 + idx + 68] = mem[_24097 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25153 + 68] = mem[_25153 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _25153 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _30206 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30206] = 30
                                            mem[_30206 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _31983 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_31983 + idx + 68] = mem[_30206 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31983 + 68] = mem[_31983 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _31983 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _22787 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22787] = 30
                                        mem[_22787 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23215 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23215 + idx + 68] = mem[_22787 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23215 + 68] = mem[_23215 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23215 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25152 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25152] = 30
                                        mem[_25152 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26394 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26394 + idx + 68] = mem[_25152 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26394 + 68] = mem[_26394 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26394 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _31982 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31982] = 30
                                        mem[_31982 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33523 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33523 + idx + 68] = mem[_31982 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33523 + 68] = mem[_33523 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33523 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _22786 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22786] = 30
                                        mem[_22786 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23212 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23212 + idx + 68] = mem[_22786 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23212 + 68] = mem[_23212 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23212 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25151 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25151] = 30
                                        mem[_25151 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _26391 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26391 + idx + 68] = mem[_25151 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26391 + 68] = mem[_26391 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26391 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _31981 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31981] = 30
                                        mem[_31981 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33520 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33520 + idx + 68] = mem[_31981 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33520 + 68] = mem[_33520 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33520 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23211 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23211] = 30
                                    mem[_23211 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _23786 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23786 + idx + 68] = mem[_23211 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23786 + 68] = mem[_23786 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23786 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26390 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26390] = 30
                                    mem[_26390 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27826 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27826 + idx + 68] = mem[_26390 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27826 + 68] = mem[_27826 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27826 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _33519 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33519] = 30
                                    mem[_33519 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34822 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34822 + idx + 68] = mem[_33519 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34822 + 68] = mem[_34822 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34822 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _21417 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21417] = 30
                                    mem[_21417 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _21515 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_21515 + idx + 68] = mem[_21417 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21515 + 68] = mem[_21515 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _21515 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _21900 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21900] = 30
                                    mem[_21900 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _22049 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22049 + idx + 68] = mem[_21900 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22049 + 68] = mem[_22049 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22049 + -mem[64] + 100
                                _21448 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21448] = 26
                                mem[_21448 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22788 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22788] = 30
                                        mem[_22788 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25160 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25160] = 30
                                        mem[_25160 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26404 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26404 + idx + 68] = mem[_25160 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26404 + 68] = mem[_26404 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26404 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _31990 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31990] = 30
                                        mem[_31990 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33530 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33530 + idx + 68] = mem[_31990 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33530 + 68] = mem[_33530 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33530 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23219 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23219] = 30
                                    mem[_23219 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23796 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23796 + idx + 68] = mem[_23219 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23796 + 68] = mem[_23796 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23796 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26403 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26403] = 30
                                    mem[_26403 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _27842 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27842 + idx + 68] = mem[_26403 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27842 + 68] = mem[_27842 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27842 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _33529 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33529] = 30
                                    mem[_33529 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34834 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34834 + idx + 68] = mem[_33529 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34834 + 68] = mem[_34834 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34834 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _23218 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23218] = 30
                                    mem[_23218 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23793 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23793 + idx + 68] = mem[_23218 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23793 + 68] = mem[_23793 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23793 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26402 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26402] = 30
                                    mem[_26402 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27839 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27839 + idx + 68] = mem[_26402 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27839 + 68] = mem[_27839 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27839 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _33528 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33528] = 30
                                    mem[_33528 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34831 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34831 + idx + 68] = mem[_33528 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34831 + 68] = mem[_34831 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34831 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23792 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23792] = 30
                                mem[_23792 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _24627 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24627 + idx + 68] = mem[_23792 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24627 + 68] = mem[_24627 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24627 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _27838 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27838] = 30
                                mem[_27838 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _29397 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_29397 + idx + 68] = mem[_27838 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29397 + 68] = mem[_29397 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29397 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _34830 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34830] = 30
                                mem[_34830 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _36136 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_36136 + idx + 68] = mem[_34830 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36136 + 68] = mem[_36136 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36136 + -mem[64] + 100
                            _21148 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21148] = 26
                            mem[_21148 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100 * 10^18:
                                _21591 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21591] = 26
                                mem[_21591 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                _21590 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21590] = 26
                                mem[_21590 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                        else:
                            mem[0] = arg1
                            mem[32] = 4
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not stor4[address(arg1)]:
                                idx = 0
                                s = 100 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _21363 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21363] = 26
                                        mem[_21363 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100:
                                                _22596 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22596] = 30
                                                mem[_22596 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _24102 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24102] = 30
                                                mem[_24102 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _25165 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_25165 + idx + 68] = mem[_24102 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_25165 + 68] = mem[_25165 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _25165 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _30220 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_30220] = 30
                                                mem[_30220 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _32004 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32004 + idx + 68] = mem[_30220 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32004 + 68] = mem[_32004 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32004 + -mem[64] + 100
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _22790 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22790] = 30
                                            mem[_22790 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                _23226 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23226 + idx + 68] = mem[_22790 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23226 + 68] = mem[_23226 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23226 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25164 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25164] = 30
                                            mem[_25164 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _26421 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26421 + idx + 68] = mem[_25164 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26421 + 68] = mem[_26421 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26421 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            _32003 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32003] = 30
                                            mem[_32003 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33547 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33547 + idx + 68] = mem[_32003 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33547 + 68] = mem[_33547 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33547 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            _22789 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22789] = 30
                                            mem[_22789 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                _23223 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23223 + idx + 68] = mem[_22789 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23223 + 68] = mem[_23223 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23223 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25163 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25163] = 30
                                            mem[_25163 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                _26418 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26418 + idx + 68] = mem[_25163 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26418 + 68] = mem[_26418 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26418 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            _32002 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32002] = 30
                                            mem[_32002 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33544 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33544 + idx + 68] = mem[_32002 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33544 + 68] = mem[_33544 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33544 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23222 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23222] = 30
                                        mem[_23222 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            _23803 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23803 + idx + 68] = mem[_23222 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23803 + 68] = mem[_23803 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23803 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26417 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26417] = 30
                                        mem[_26417 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _27862 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27862 + idx + 68] = mem[_26417 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27862 + 68] = mem[_27862 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27862 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        _33543 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33543] = 30
                                        mem[_33543 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _34850 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_34850 + idx + 68] = mem[_33543 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34850 + 68] = mem[_34850 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34850 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _21418 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21418] = 30
                                        mem[_21418 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _21518 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_21518 + idx + 68] = mem[_21418 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21518 + 68] = mem[_21518 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _21518 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _21902 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21902] = 30
                                        mem[_21902 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _22054 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22054 + idx + 68] = mem[_21902 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22054 + 68] = mem[_22054 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22054 + -mem[64] + 100
                                    _21449 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21449] = 26
                                    mem[_21449 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22791 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22791] = 30
                                            mem[_22791 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25172 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25172] = 30
                                            mem[_25172 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _26431 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26431 + idx + 68] = mem[_25172 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26431 + 68] = mem[_26431 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26431 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _32011 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32011] = 30
                                            mem[_32011 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33554 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33554 + idx + 68] = mem[_32011 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33554 + 68] = mem[_33554 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33554 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23230 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23230] = 30
                                        mem[_23230 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23813 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23813 + idx + 68] = mem[_23230 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23813 + 68] = mem[_23813 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23813 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26430 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26430] = 30
                                        mem[_26430 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _27878 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27878 + idx + 68] = mem[_26430 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27878 + 68] = mem[_27878 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27878 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _33553 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33553] = 30
                                        mem[_33553 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _34862 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_34862 + idx + 68] = mem[_33553 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34862 + 68] = mem[_34862 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34862 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _23229 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23229] = 30
                                        mem[_23229 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23810 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23810 + idx + 68] = mem[_23229 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23810 + 68] = mem[_23810 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23810 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26429 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26429] = 30
                                        mem[_26429 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _27875 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27875 + idx + 68] = mem[_26429 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27875 + 68] = mem[_27875 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27875 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _33552 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33552] = 30
                                        mem[_33552 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _34859 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_34859 + idx + 68] = mem[_33552 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34859 + 68] = mem[_34859 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34859 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23809 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23809] = 30
                                    mem[_23809 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _24652 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24652 + idx + 68] = mem[_23809 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24652 + 68] = mem[_24652 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24652 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _27874 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27874] = 30
                                    mem[_27874 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _29438 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_29438 + idx + 68] = mem[_27874 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29438 + 68] = mem[_29438 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _29438 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _34858 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34858] = 30
                                    mem[_34858 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _36169 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36169 + idx + 68] = mem[_34858 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36169 + 68] = mem[_36169 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36169 + -mem[64] + 100
                                _21153 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21153] = 26
                                mem[_21153 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 100 * 10^18:
                                    _21593 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21593] = 26
                                    mem[_21593 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    _21592 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21592] = 26
                                    mem[_21592 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                            else:
                                idx = 0
                                s = 100 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _21366 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21366] = 26
                                        mem[_21366 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100:
                                                _22597 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22597] = 30
                                                mem[_22597 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _24107 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24107] = 30
                                                mem[_24107 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _25177 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_25177 + idx + 68] = mem[_24107 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_25177 + 68] = mem[_25177 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _25177 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _27026 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_27026] = 30
                                                mem[_27026 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _28528 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_28528 + idx + 68] = mem[_27026 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_28528 + 68] = mem[_28528 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _28528 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _36197 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36197] = 30
                                                mem[_36197 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _37499 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_37499 + idx + 68] = mem[_36197 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37499 + 68] = mem[_37499 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37499 + -mem[64] + 100
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _22793 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22793] = 30
                                            mem[_22793 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                _23237 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23237 + idx + 68] = mem[_22793 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23237 + 68] = mem[_23237 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23237 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _25176 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25176] = 30
                                            mem[_25176 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _26448 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26448 + idx + 68] = mem[_25176 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26448 + 68] = mem[_26448 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26448 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _28525 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28525] = 30
                                            mem[_28525 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _30238 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_30238 + idx + 68] = mem[_28525 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30238 + 68] = mem[_30238 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _30238 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            _37498 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37498] = 30
                                            mem[_37498 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _38649 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38649 + idx + 68] = mem[_37498 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38649 + 68] = mem[_38649 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38649 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            _22792 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22792] = 30
                                            mem[_22792 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                _23234 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23234 + idx + 68] = mem[_22792 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23234 + 68] = mem[_23234 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23234 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _25175 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25175] = 30
                                            mem[_25175 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _26445 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26445 + idx + 68] = mem[_25175 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26445 + 68] = mem[_26445 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26445 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _28522 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28522] = 30
                                            mem[_28522 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                _30235 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_30235 + idx + 68] = mem[_28522 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30235 + 68] = mem[_30235 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _30235 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            _37497 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37497] = 30
                                            mem[_37497 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _38646 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38646 + idx + 68] = mem[_37497 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38646 + 68] = mem[_38646 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38646 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23233 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23233] = 30
                                        mem[_23233 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            _23820 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23820 + idx + 68] = mem[_23233 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23820 + 68] = mem[_23820 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23820 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _26444 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26444] = 30
                                        mem[_26444 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _27898 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27898 + idx + 68] = mem[_26444 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27898 + 68] = mem[_27898 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27898 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _30232 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30232] = 30
                                        mem[_30232 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _32030 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32030 + idx + 68] = mem[_30232 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32030 + 68] = mem[_32030 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32030 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        _38645 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38645] = 30
                                        mem[_38645 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _39492 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39492 + idx + 68] = mem[_38645 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39492 + 68] = mem[_39492 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39492 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _21419 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21419] = 30
                                        mem[_21419 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _21521 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_21521 + idx + 68] = mem[_21419 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21521 + 68] = mem[_21521 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _21521 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _21904 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21904] = 30
                                        mem[_21904 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _22059 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22059 + idx + 68] = mem[_21904 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22059 + 68] = mem[_22059 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22059 + -mem[64] + 100
                                    _21450 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21450] = 26
                                    mem[_21450 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22794 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22794] = 30
                                            mem[_22794 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _25184 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25184] = 30
                                            mem[_25184 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _26458 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26458 + idx + 68] = mem[_25184 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26458 + 68] = mem[_26458 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26458 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _28531 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28531] = 30
                                            mem[_28531 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _30250 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_30250 + idx + 68] = mem[_28531 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30250 + 68] = mem[_30250 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _30250 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _37504 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37504] = 30
                                            mem[_37504 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _38656 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38656 + idx + 68] = mem[_37504 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38656 + 68] = mem[_38656 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38656 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23241 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23241] = 30
                                        mem[_23241 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23830 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23830 + idx + 68] = mem[_23241 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23830 + 68] = mem[_23830 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23830 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _26457 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26457] = 30
                                        mem[_26457 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _27912 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27912 + idx + 68] = mem[_26457 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27912 + 68] = mem[_27912 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27912 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _30247 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30247] = 30
                                        mem[_30247 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _32048 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32048 + idx + 68] = mem[_30247 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32048 + 68] = mem[_32048 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32048 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _38655 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38655] = 30
                                        mem[_38655 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _39504 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39504 + idx + 68] = mem[_38655 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39504 + 68] = mem[_39504 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39504 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _23240 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23240] = 30
                                        mem[_23240 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23827 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23827 + idx + 68] = mem[_23240 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23827 + 68] = mem[_23827 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23827 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _26456 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26456] = 30
                                        mem[_26456 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _27909 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_27909 + idx + 68] = mem[_26456 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27909 + 68] = mem[_27909 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _27909 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _30244 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30244] = 30
                                        mem[_30244 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _32045 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32045 + idx + 68] = mem[_30244 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32045 + 68] = mem[_32045 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32045 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _38654 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38654] = 30
                                        mem[_38654 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _39501 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39501 + idx + 68] = mem[_38654 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39501 + 68] = mem[_39501 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39501 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23826 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23826] = 30
                                    mem[_23826 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _24677 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24677 + idx + 68] = mem[_23826 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24677 + 68] = mem[_24677 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24677 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _27908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27908] = 30
                                    mem[_27908 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _29475 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_29475 + idx + 68] = mem[_27908 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29475 + 68] = mem[_29475 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _29475 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _32042 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32042] = 30
                                    mem[_32042 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _33590 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33590 + idx + 68] = mem[_32042 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33590 + 68] = mem[_33590 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33590 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _39500 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39500] = 30
                                    mem[_39500 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _40114 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_40114 + idx + 68] = mem[_39500 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40114 + 68] = mem[_40114 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40114 + -mem[64] + 100
                                _21158 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21158] = 26
                                mem[_21158 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 100 * 10^18:
                                    _21595 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21595] = 26
                                    mem[_21595 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    _21594 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21594] = 26
                                    mem[_21594 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
            else:
                mem[0] = arg1
                mem[32] = 4
                if stor4[address(arg1)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = 100 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _21393 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21393] = 26
                            mem[_21393 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100:
                                    _22606 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22606] = 30
                                    mem[_22606 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _24152 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24152] = 30
                                    mem[_24152 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _25285 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_25285 + idx + 68] = mem[_24152 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25285 + 68] = mem[_25285 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _25285 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _32949 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32949] = 30
                                    mem[_32949 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34253 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34253 + idx + 68] = mem[_32949 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34253 + 68] = mem[_34253 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34253 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _22820 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22820] = 30
                                mem[_22820 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    _23336 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23336 + idx + 68] = mem[_22820 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23336 + 68] = mem[_23336 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23336 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25284 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25284] = 30
                                mem[_25284 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _26691 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_26691 + idx + 68] = mem[_25284 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26691 + 68] = mem[_26691 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _26691 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                _34252 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34252] = 30
                                mem[_34252 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _35553 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_35553 + idx + 68] = mem[_34252 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35553 + 68] = mem[_35553 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35553 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                _22819 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22819] = 30
                                mem[_22819 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    _23333 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23333 + idx + 68] = mem[_22819 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23333 + 68] = mem[_23333 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23333 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25283 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25283] = 30
                                mem[_25283 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _26688 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_26688 + idx + 68] = mem[_25283 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26688 + 68] = mem[_26688 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _26688 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                _34251 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34251] = 30
                                mem[_34251 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _35550 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_35550 + idx + 68] = mem[_34251 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35550 + 68] = mem[_35550 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35550 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23332 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23332] = 30
                            mem[_23332 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                _23973 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23973 + idx + 68] = mem[_23332 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23973 + 68] = mem[_23973 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23973 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _26687 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26687] = 30
                            mem[_26687 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _28216 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_28216 + idx + 68] = mem[_26687 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28216 + 68] = mem[_28216 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _28216 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                            _35549 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35549] = 30
                            mem[_35549 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _36909 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_36909 + idx + 68] = mem[_35549 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_36909 + 68] = mem[_36909 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36909 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _21428 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21428] = 30
                            mem[_21428 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _21548 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_21548 + idx + 68] = mem[_21428 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21548 + 68] = mem[_21548 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _21548 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _21922 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21922] = 30
                            mem[_21922 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _22104 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_22104 + idx + 68] = mem[_21922 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_22104 + 68] = mem[_22104 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _22104 + -mem[64] + 100
                        _21459 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21459] = 26
                        mem[_21459 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not arg2 / 100:
                                _22821 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22821] = 30
                                mem[_22821 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _25292 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25292] = 30
                                mem[_25292 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _26701 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_26701 + idx + 68] = mem[_25292 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26701 + 68] = mem[_26701 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _26701 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _34258 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34258] = 30
                                mem[_34258 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _35560 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_35560 + idx + 68] = mem[_34258 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35560 + 68] = mem[_35560 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35560 + -mem[64] + 100
                            require arg2 / 100
                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _23340 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23340] = 30
                            mem[_23340 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                _23983 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23983 + idx + 68] = mem[_23340 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23983 + 68] = mem[_23983 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23983 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _26700 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26700] = 30
                            mem[_26700 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _28232 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_28232 + idx + 68] = mem[_26700 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28232 + 68] = mem[_28232 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _28232 + -mem[64] + 100
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            _35559 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35559] = 30
                            mem[_35559 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _36921 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_36921 + idx + 68] = mem[_35559 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_36921 + 68] = mem[_36921 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36921 + -mem[64] + 100
                        require arg2
                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not arg2 / 100:
                            _23339 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23339] = 30
                            mem[_23339 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100 * 10^18:
                                _23980 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23980 + idx + 68] = mem[_23339 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23980 + 68] = mem[_23980 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23980 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _26699 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26699] = 30
                            mem[_26699 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                _28229 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_28229 + idx + 68] = mem[_26699 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28229 + 68] = mem[_28229 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _28229 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                            _35558 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35558] = 30
                            mem[_35558 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees + (arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100
                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                return 1
                            _36918 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_36918 + idx + 68] = mem[_35558 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_36918 + 68] = mem[_36918 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36918 + -mem[64] + 100
                        require arg2 / 100
                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _23979 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23979] = 30
                        mem[_23979 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                            _24902 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_24902 + idx + 68] = mem[_23979 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24902 + 68] = mem[_24902 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _24902 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _28228 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28228] = 30
                        mem[_28228 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                            _29830 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_29830 + idx + 68] = mem[_28228 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_29830 + 68] = mem[_29830 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _29830 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                        _36917 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_36917] = 30
                        mem[_36917 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            if totalFees + (arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100
                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                            return 1
                        _38115 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_38115 + idx + 68] = mem[_36917 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_38115 + 68] = mem[_38115 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _38115 + -mem[64] + 100
                    _21203 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21203] = 26
                    mem[_21203 + 32] = 'SafeMath: division by zero'
                    if t < stor6 / 100 * 10^18:
                        _21613 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21613] = 26
                        mem[_21613 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                        else:
                            require arg2
                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                if 0 > arg2 * stor6 / 100 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                    else:
                        _21612 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21612] = 26
                        mem[_21612 + 32] = 'SafeMath: division by zero'
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require s
                        if not arg2:
                            if not arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                if arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * t / s
                        else:
                            require arg2
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100
                                if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                if arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * t / s
                else:
                    if stor4[address(msg.sender)]:
                        mem[0] = msg.sender
                        mem[32] = 4
                        if not stor4[address(msg.sender)]:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _21372 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21372] = 26
                                    mem[_21372 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22599 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22599] = 30
                                            mem[_22599 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _24117 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24117] = 30
                                            mem[_24117 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _25201 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_25201 + idx + 68] = mem[_24117 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25201 + 68] = mem[_25201 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _25201 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _30275 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30275] = 30
                                            mem[_30275 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _32088 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32088 + idx + 68] = mem[_30275 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32088 + 68] = mem[_32088 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32088 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _22799 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22799] = 30
                                        mem[_22799 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23259 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23259 + idx + 68] = mem[_22799 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23259 + 68] = mem[_23259 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23259 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25200 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25200] = 30
                                        mem[_25200 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26502 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26502 + idx + 68] = mem[_25200 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26502 + 68] = mem[_26502 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26502 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _32087 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32087] = 30
                                        mem[_32087 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33640 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33640 + idx + 68] = mem[_32087 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33640 + 68] = mem[_33640 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33640 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _22798 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22798] = 30
                                        mem[_22798 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23256 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23256 + idx + 68] = mem[_22798 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23256 + 68] = mem[_23256 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23256 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25199 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25199] = 30
                                        mem[_25199 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _26499 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26499 + idx + 68] = mem[_25199 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26499 + 68] = mem[_26499 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26499 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _32086 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32086] = 30
                                        mem[_32086 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33637 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33637 + idx + 68] = mem[_32086 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33637 + 68] = mem[_33637 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33637 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23255 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23255] = 30
                                    mem[_23255 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _23854 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23854 + idx + 68] = mem[_23255 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23854 + 68] = mem[_23854 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23854 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26498 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26498] = 30
                                    mem[_26498 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27968 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27968 + idx + 68] = mem[_26498 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27968 + 68] = mem[_27968 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27968 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _33636 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33636] = 30
                                    mem[_33636 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34943 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34943 + idx + 68] = mem[_33636 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34943 + 68] = mem[_34943 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34943 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _21421 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21421] = 30
                                    mem[_21421 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _21527 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_21527 + idx + 68] = mem[_21421 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21527 + 68] = mem[_21527 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _21527 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _21908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21908] = 30
                                    mem[_21908 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _22069 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22069 + idx + 68] = mem[_21908 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22069 + 68] = mem[_22069 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22069 + -mem[64] + 100
                                _21452 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21452] = 26
                                mem[_21452 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22800 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22800] = 30
                                        mem[_22800 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25208 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25208] = 30
                                        mem[_25208 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26512 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26512 + idx + 68] = mem[_25208 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26512 + 68] = mem[_26512 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26512 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _32095 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32095] = 30
                                        mem[_32095 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33647 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33647 + idx + 68] = mem[_32095 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33647 + 68] = mem[_33647 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33647 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23263 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23263] = 30
                                    mem[_23263 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23864 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23864 + idx + 68] = mem[_23263 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23864 + 68] = mem[_23864 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23864 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26511 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26511] = 30
                                    mem[_26511 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _27984 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27984 + idx + 68] = mem[_26511 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27984 + 68] = mem[_27984 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27984 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _33646 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33646] = 30
                                    mem[_33646 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34955 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34955 + idx + 68] = mem[_33646 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34955 + 68] = mem[_34955 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34955 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _23262 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23262] = 30
                                    mem[_23262 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23861 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23861 + idx + 68] = mem[_23262 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23861 + 68] = mem[_23861 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23861 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26510 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26510] = 30
                                    mem[_26510 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _27981 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_27981 + idx + 68] = mem[_26510 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27981 + 68] = mem[_27981 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _27981 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _33645 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33645] = 30
                                    mem[_33645 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _34952 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_34952 + idx + 68] = mem[_33645 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34952 + 68] = mem[_34952 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _34952 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23860 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23860] = 30
                                mem[_23860 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _24727 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24727 + idx + 68] = mem[_23860 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24727 + 68] = mem[_24727 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24727 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _27980 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27980] = 30
                                mem[_27980 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _29555 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_29555 + idx + 68] = mem[_27980 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29555 + 68] = mem[_29555 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29555 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _34951 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34951] = 30
                                mem[_34951 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _36260 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_36260 + idx + 68] = mem[_34951 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36260 + 68] = mem[_36260 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36260 + -mem[64] + 100
                            _21168 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21168] = 26
                            mem[_21168 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100 * 10^18:
                                _21599 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21599] = 26
                                mem[_21599 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                _21598 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21598] = 26
                                mem[_21598 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                        else:
                            mem[0] = arg1
                            mem[32] = 4
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not stor4[address(arg1)]:
                                idx = 0
                                s = 100 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _21375 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21375] = 26
                                        mem[_21375 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100:
                                                _22600 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22600] = 30
                                                mem[_22600 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _24122 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24122] = 30
                                                mem[_24122 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _25213 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_25213 + idx + 68] = mem[_24122 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_25213 + 68] = mem[_25213 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _25213 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _30289 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_30289] = 30
                                                mem[_30289 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _32109 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32109 + idx + 68] = mem[_30289 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32109 + 68] = mem[_32109 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32109 + -mem[64] + 100
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _22802 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22802] = 30
                                            mem[_22802 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                _23270 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23270 + idx + 68] = mem[_22802 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23270 + 68] = mem[_23270 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23270 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25212 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25212] = 30
                                            mem[_25212 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _26529 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26529 + idx + 68] = mem[_25212 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26529 + 68] = mem[_26529 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26529 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            _32108 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32108] = 30
                                            mem[_32108 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33664 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33664 + idx + 68] = mem[_32108 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33664 + 68] = mem[_33664 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33664 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            _22801 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22801] = 30
                                            mem[_22801 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                _23267 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23267 + idx + 68] = mem[_22801 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23267 + 68] = mem[_23267 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23267 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25211 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25211] = 30
                                            mem[_25211 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                _26526 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26526 + idx + 68] = mem[_25211 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26526 + 68] = mem[_26526 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26526 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            _32107 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32107] = 30
                                            mem[_32107 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33661 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33661 + idx + 68] = mem[_32107 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33661 + 68] = mem[_33661 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33661 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23266 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23266] = 30
                                        mem[_23266 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            _23871 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23871 + idx + 68] = mem[_23266 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23871 + 68] = mem[_23871 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23871 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26525 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26525] = 30
                                        mem[_26525 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _28004 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_28004 + idx + 68] = mem[_26525 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28004 + 68] = mem[_28004 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _28004 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        _33660 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33660] = 30
                                        mem[_33660 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _34971 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_34971 + idx + 68] = mem[_33660 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34971 + 68] = mem[_34971 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34971 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _21422 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21422] = 30
                                        mem[_21422 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _21530 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_21530 + idx + 68] = mem[_21422 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21530 + 68] = mem[_21530 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _21530 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _21910 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21910] = 30
                                        mem[_21910 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _22074 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22074 + idx + 68] = mem[_21910 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22074 + 68] = mem[_22074 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22074 + -mem[64] + 100
                                    _21453 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21453] = 26
                                    mem[_21453 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22803 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22803] = 30
                                            mem[_22803 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25220 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25220] = 30
                                            mem[_25220 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _26539 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26539 + idx + 68] = mem[_25220 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26539 + 68] = mem[_26539 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26539 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _32116 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32116] = 30
                                            mem[_32116 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33671 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33671 + idx + 68] = mem[_32116 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33671 + 68] = mem[_33671 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33671 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23274 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23274] = 30
                                        mem[_23274 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23881 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23881 + idx + 68] = mem[_23274 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23881 + 68] = mem[_23881 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23881 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26538 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26538] = 30
                                        mem[_26538 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _28020 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_28020 + idx + 68] = mem[_26538 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28020 + 68] = mem[_28020 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _28020 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _33670 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33670] = 30
                                        mem[_33670 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _34983 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_34983 + idx + 68] = mem[_33670 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34983 + 68] = mem[_34983 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34983 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _23273 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23273] = 30
                                        mem[_23273 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23878 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23878 + idx + 68] = mem[_23273 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23878 + 68] = mem[_23878 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23878 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26537 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26537] = 30
                                        mem[_26537 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _28017 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_28017 + idx + 68] = mem[_26537 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28017 + 68] = mem[_28017 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _28017 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _33669 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33669] = 30
                                        mem[_33669 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _34980 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_34980 + idx + 68] = mem[_33669 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34980 + 68] = mem[_34980 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _34980 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23877 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23877] = 30
                                    mem[_23877 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _24752 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24752 + idx + 68] = mem[_23877 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24752 + 68] = mem[_24752 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24752 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _28016 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28016] = 30
                                    mem[_28016 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _29596 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_29596 + idx + 68] = mem[_28016 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29596 + 68] = mem[_29596 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _29596 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _34979 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34979] = 30
                                    mem[_34979 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _36293 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36293 + idx + 68] = mem[_34979 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36293 + 68] = mem[_36293 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36293 + -mem[64] + 100
                                _21173 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21173] = 26
                                mem[_21173 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 100 * 10^18:
                                    _21601 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21601] = 26
                                    mem[_21601 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    _21600 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21600] = 26
                                    mem[_21600 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                            else:
                                idx = 0
                                s = 100 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _21378 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21378] = 26
                                        mem[_21378 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100:
                                                _22601 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22601] = 30
                                                mem[_22601 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _24127 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24127] = 30
                                                mem[_24127 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _25225 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_25225 + idx + 68] = mem[_24127 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_25225 + 68] = mem[_25225 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _25225 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _27083 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_27083] = 30
                                                mem[_27083 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _28577 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_28577 + idx + 68] = mem[_27083 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_28577 + 68] = mem[_28577 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _28577 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _36321 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36321] = 30
                                                mem[_36321 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _37612 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_37612 + idx + 68] = mem[_36321 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37612 + 68] = mem[_37612 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37612 + -mem[64] + 100
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _22805 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22805] = 30
                                            mem[_22805 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                _23281 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23281 + idx + 68] = mem[_22805 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23281 + 68] = mem[_23281 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23281 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _25224 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25224] = 30
                                            mem[_25224 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _26556 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26556 + idx + 68] = mem[_25224 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26556 + 68] = mem[_26556 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26556 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _28574 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28574] = 30
                                            mem[_28574 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _30307 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_30307 + idx + 68] = mem[_28574 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30307 + 68] = mem[_30307 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _30307 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            _37611 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37611] = 30
                                            mem[_37611 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _38750 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38750 + idx + 68] = mem[_37611 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38750 + 68] = mem[_38750 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38750 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            _22804 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22804] = 30
                                            mem[_22804 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                _23278 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23278 + idx + 68] = mem[_22804 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23278 + 68] = mem[_23278 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23278 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _25223 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25223] = 30
                                            mem[_25223 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _26553 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26553 + idx + 68] = mem[_25223 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26553 + 68] = mem[_26553 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26553 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _28571 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28571] = 30
                                            mem[_28571 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                _30304 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_30304 + idx + 68] = mem[_28571 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30304 + 68] = mem[_30304 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _30304 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            _37610 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37610] = 30
                                            mem[_37610 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _38747 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38747 + idx + 68] = mem[_37610 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38747 + 68] = mem[_38747 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38747 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23277 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23277] = 30
                                        mem[_23277 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            _23888 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23888 + idx + 68] = mem[_23277 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23888 + 68] = mem[_23888 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23888 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _26552 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26552] = 30
                                        mem[_26552 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _28040 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_28040 + idx + 68] = mem[_26552 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28040 + 68] = mem[_28040 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _28040 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _30301 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30301] = 30
                                        mem[_30301 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _32135 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32135 + idx + 68] = mem[_30301 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32135 + 68] = mem[_32135 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32135 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        _38746 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38746] = 30
                                        mem[_38746 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _39570 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39570 + idx + 68] = mem[_38746 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39570 + 68] = mem[_39570 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39570 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _21423 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21423] = 30
                                        mem[_21423 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _21533 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_21533 + idx + 68] = mem[_21423 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21533 + 68] = mem[_21533 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _21533 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _21912 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21912] = 30
                                        mem[_21912 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _22079 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22079 + idx + 68] = mem[_21912 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22079 + 68] = mem[_22079 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22079 + -mem[64] + 100
                                    _21454 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21454] = 26
                                    mem[_21454 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22806 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22806] = 30
                                            mem[_22806 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _25232 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25232] = 30
                                            mem[_25232 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _26566 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26566 + idx + 68] = mem[_25232 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26566 + 68] = mem[_26566 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26566 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _28580 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28580] = 30
                                            mem[_28580 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _30319 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_30319 + idx + 68] = mem[_28580 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30319 + 68] = mem[_30319 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _30319 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _37617 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37617] = 30
                                            mem[_37617 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _38757 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38757 + idx + 68] = mem[_37617 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38757 + 68] = mem[_38757 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38757 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23285 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23285] = 30
                                        mem[_23285 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23898 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23898 + idx + 68] = mem[_23285 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23898 + 68] = mem[_23898 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23898 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _26565 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26565] = 30
                                        mem[_26565 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _28054 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_28054 + idx + 68] = mem[_26565 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28054 + 68] = mem[_28054 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _28054 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _30316 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30316] = 30
                                        mem[_30316 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _32153 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32153 + idx + 68] = mem[_30316 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32153 + 68] = mem[_32153 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32153 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _38756 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38756] = 30
                                        mem[_38756 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _39582 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39582 + idx + 68] = mem[_38756 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39582 + 68] = mem[_39582 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39582 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _23284 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23284] = 30
                                        mem[_23284 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23895 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23895 + idx + 68] = mem[_23284 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23895 + 68] = mem[_23895 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23895 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _26564 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26564] = 30
                                        mem[_26564 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _28051 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_28051 + idx + 68] = mem[_26564 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28051 + 68] = mem[_28051 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _28051 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _30313 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30313] = 30
                                        mem[_30313 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _32150 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32150 + idx + 68] = mem[_30313 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32150 + 68] = mem[_32150 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32150 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _38755 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38755] = 30
                                        mem[_38755 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _39579 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39579 + idx + 68] = mem[_38755 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39579 + 68] = mem[_39579 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39579 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23894 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23894] = 30
                                    mem[_23894 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _24777 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24777 + idx + 68] = mem[_23894 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24777 + 68] = mem[_24777 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24777 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _28050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28050] = 30
                                    mem[_28050 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _29633 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_29633 + idx + 68] = mem[_28050 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29633 + 68] = mem[_29633 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _29633 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _32147 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32147] = 30
                                    mem[_32147 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _33707 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33707 + idx + 68] = mem[_32147 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33707 + 68] = mem[_33707 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33707 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _39578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39578] = 30
                                    mem[_39578 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _40165 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_40165 + idx + 68] = mem[_39578 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40165 + 68] = mem[_40165 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40165 + -mem[64] + 100
                                _21178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21178] = 26
                                mem[_21178 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 100 * 10^18:
                                    _21603 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21603] = 26
                                    mem[_21603 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    _21602 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21602] = 26
                                    mem[_21602 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        if not stor4[address(arg1)]:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _21390 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21390] = 26
                                    mem[_21390 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22605 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22605] = 30
                                            mem[_22605 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _24147 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24147] = 30
                                            mem[_24147 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _25273 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_25273 + idx + 68] = mem[_24147 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25273 + 68] = mem[_25273 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _25273 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _30385 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30385] = 30
                                            mem[_30385 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _32256 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32256 + idx + 68] = mem[_30385 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32256 + 68] = mem[_32256 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32256 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _22817 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22817] = 30
                                        mem[_22817 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23325 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23325 + idx + 68] = mem[_22817 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23325 + 68] = mem[_23325 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23325 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25272 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25272] = 30
                                        mem[_25272 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26664 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26664 + idx + 68] = mem[_25272 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26664 + 68] = mem[_26664 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26664 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _32255 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32255] = 30
                                        mem[_32255 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33826 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33826 + idx + 68] = mem[_32255 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33826 + 68] = mem[_33826 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33826 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _22816 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22816] = 30
                                        mem[_22816 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23322 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23322 + idx + 68] = mem[_22816 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23322 + 68] = mem[_23322 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23322 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25271 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25271] = 30
                                        mem[_25271 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _26661 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26661 + idx + 68] = mem[_25271 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26661 + 68] = mem[_26661 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26661 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _32254 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32254] = 30
                                        mem[_32254 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33823 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33823 + idx + 68] = mem[_32254 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33823 + 68] = mem[_33823 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33823 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23321 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23321] = 30
                                    mem[_23321 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _23956 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23956 + idx + 68] = mem[_23321 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23956 + 68] = mem[_23956 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23956 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26660 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26660] = 30
                                    mem[_26660 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _28180 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_28180 + idx + 68] = mem[_26660 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28180 + 68] = mem[_28180 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _28180 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _33822 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33822] = 30
                                    mem[_33822 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _35129 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35129 + idx + 68] = mem[_33822 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35129 + 68] = mem[_35129 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35129 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _21427 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21427] = 30
                                    mem[_21427 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _21545 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_21545 + idx + 68] = mem[_21427 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21545 + 68] = mem[_21545 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _21545 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _21920 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21920] = 30
                                    mem[_21920 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _22099 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22099 + idx + 68] = mem[_21920 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22099 + 68] = mem[_22099 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22099 + -mem[64] + 100
                                _21458 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21458] = 26
                                mem[_21458 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        _22818 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22818] = 30
                                        mem[_22818 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _25280 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25280] = 30
                                        mem[_25280 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _26674 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_26674 + idx + 68] = mem[_25280 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26674 + 68] = mem[_26674 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _26674 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _32263 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32263] = 30
                                        mem[_32263 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _33833 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33833 + idx + 68] = mem[_32263 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33833 + 68] = mem[_33833 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33833 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23329 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23329] = 30
                                    mem[_23329 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                        _23966 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23966 + idx + 68] = mem[_23329 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23966 + 68] = mem[_23966 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23966 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26673 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26673] = 30
                                    mem[_26673 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _28196 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_28196 + idx + 68] = mem[_26673 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28196 + 68] = mem[_28196 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _28196 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    _33832 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33832] = 30
                                    mem[_33832 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _35141 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35141 + idx + 68] = mem[_33832 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35141 + 68] = mem[_35141 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35141 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100:
                                    _23328 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23328] = 30
                                    mem[_23328 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100 * 10^18:
                                        _23963 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23963 + idx + 68] = mem[_23328 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23963 + 68] = mem[_23963 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23963 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _26672 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26672] = 30
                                    mem[_26672 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _28193 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_28193 + idx + 68] = mem[_26672 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28193 + 68] = mem[_28193 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _28193 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                    _33831 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33831] = 30
                                    mem[_33831 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _35138 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35138 + idx + 68] = mem[_33831 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35138 + 68] = mem[_35138 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35138 + -mem[64] + 100
                                require arg2 / 100
                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _23962 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23962] = 30
                                mem[_23962 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                    _24877 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24877 + idx + 68] = mem[_23962 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24877 + 68] = mem[_24877 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24877 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _28192 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28192] = 30
                                mem[_28192 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                    _29789 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_29789 + idx + 68] = mem[_28192 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29789 + 68] = mem[_29789 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _29789 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                _35137 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35137] = 30
                                mem[_35137 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    if totalFees + (arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _36442 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_36442 + idx + 68] = mem[_35137 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36442 + 68] = mem[_36442 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36442 + -mem[64] + 100
                            _21198 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21198] = 26
                            mem[_21198 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100 * 10^18:
                                _21611 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21611] = 26
                                mem[_21611 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                            else:
                                _21610 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21610] = 26
                                mem[_21610 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                        if arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * t / s
                        else:
                            mem[0] = msg.sender
                            mem[32] = 4
                            if not stor4[address(msg.sender)]:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 100 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _21381 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21381] = 26
                                        mem[_21381 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100:
                                                _22602 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22602] = 30
                                                mem[_22602 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _24132 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24132] = 30
                                                mem[_24132 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _25237 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_25237 + idx + 68] = mem[_24132 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_25237 + 68] = mem[_25237 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _25237 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _30330 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_30330] = 30
                                                mem[_30330 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _32172 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32172 + idx + 68] = mem[_30330 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32172 + 68] = mem[_32172 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32172 + -mem[64] + 100
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _22808 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22808] = 30
                                            mem[_22808 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                _23292 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23292 + idx + 68] = mem[_22808 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23292 + 68] = mem[_23292 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23292 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25236 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25236] = 30
                                            mem[_25236 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _26583 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26583 + idx + 68] = mem[_25236 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26583 + 68] = mem[_26583 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26583 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            _32171 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32171] = 30
                                            mem[_32171 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33733 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33733 + idx + 68] = mem[_32171 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33733 + 68] = mem[_33733 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33733 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            _22807 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22807] = 30
                                            mem[_22807 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                _23289 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23289 + idx + 68] = mem[_22807 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23289 + 68] = mem[_23289 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23289 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25235 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25235] = 30
                                            mem[_25235 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                _26580 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26580 + idx + 68] = mem[_25235 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26580 + 68] = mem[_26580 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26580 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            _32170 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32170] = 30
                                            mem[_32170 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33730 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33730 + idx + 68] = mem[_32170 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33730 + 68] = mem[_33730 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33730 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23288 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23288] = 30
                                        mem[_23288 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            _23905 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23905 + idx + 68] = mem[_23288 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23905 + 68] = mem[_23905 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23905 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26579 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26579] = 30
                                        mem[_26579 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _28074 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_28074 + idx + 68] = mem[_26579 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28074 + 68] = mem[_28074 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _28074 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        _33729 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33729] = 30
                                        mem[_33729 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _35036 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35036 + idx + 68] = mem[_33729 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35036 + 68] = mem[_35036 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35036 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _21424 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21424] = 30
                                        mem[_21424 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _21536 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_21536 + idx + 68] = mem[_21424 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21536 + 68] = mem[_21536 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _21536 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _21914 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21914] = 30
                                        mem[_21914 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _22084 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22084 + idx + 68] = mem[_21914 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22084 + 68] = mem[_22084 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22084 + -mem[64] + 100
                                    _21455 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21455] = 26
                                    mem[_21455 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            _22809 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22809] = 30
                                            mem[_22809 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _25244 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25244] = 30
                                            mem[_25244 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _26593 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_26593 + idx + 68] = mem[_25244 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_26593 + 68] = mem[_26593 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _26593 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _32179 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32179] = 30
                                            mem[_32179 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _33740 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33740 + idx + 68] = mem[_32179 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33740 + 68] = mem[_33740 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33740 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23296 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23296] = 30
                                        mem[_23296 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                            _23915 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23915 + idx + 68] = mem[_23296 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23915 + 68] = mem[_23915 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23915 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26592 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26592] = 30
                                        mem[_26592 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _28090 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_28090 + idx + 68] = mem[_26592 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28090 + 68] = mem[_28090 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _28090 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        _33739 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33739] = 30
                                        mem[_33739 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _35048 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35048 + idx + 68] = mem[_33739 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35048 + 68] = mem[_35048 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35048 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100:
                                        _23295 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23295] = 30
                                        mem[_23295 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100 * 10^18:
                                            _23912 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23912 + idx + 68] = mem[_23295 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23912 + 68] = mem[_23912 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23912 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _26591 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26591] = 30
                                        mem[_26591 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _28087 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_28087 + idx + 68] = mem[_26591 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28087 + 68] = mem[_28087 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _28087 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                        _33738 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33738] = 30
                                        mem[_33738 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _35045 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35045 + idx + 68] = mem[_33738 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35045 + 68] = mem[_35045 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35045 + -mem[64] + 100
                                    require arg2 / 100
                                    if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _23911 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23911] = 30
                                    mem[_23911 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                        _24802 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24802 + idx + 68] = mem[_23911 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24802 + 68] = mem[_24802 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24802 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _28086 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28086] = 30
                                    mem[_28086 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                        _29672 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_29672 + idx + 68] = mem[_28086 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29672 + 68] = mem[_29672 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _29672 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                    _35044 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35044] = 30
                                    mem[_35044 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        if totalFees + (arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _36351 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36351 + idx + 68] = mem[_35044 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36351 + 68] = mem[_36351 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36351 + -mem[64] + 100
                                _21183 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21183] = 26
                                mem[_21183 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 100 * 10^18:
                                    _21605 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21605] = 26
                                    mem[_21605 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                            if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                else:
                                    _21604 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21604] = 26
                                    mem[_21604 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100
                                            if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                            if arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * t / s
                            else:
                                mem[0] = arg1
                                mem[32] = 4
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not stor4[address(arg1)]:
                                    idx = 0
                                    s = 100 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _21384 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21384] = 26
                                            mem[_21384 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100:
                                                    _22603 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22603] = 30
                                                    mem[_22603 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _24137 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24137] = 30
                                                    mem[_24137 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _25249 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_25249 + idx + 68] = mem[_24137 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_25249 + 68] = mem[_25249 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _25249 + -mem[64] + 100
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _30344 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_30344] = 30
                                                    mem[_30344 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100
                                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                        return 1
                                                    _32193 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_32193 + idx + 68] = mem[_30344 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_32193 + 68] = mem[_32193 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _32193 + -mem[64] + 100
                                                require arg2 / 100
                                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _22811 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22811] = 30
                                                mem[_22811 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                    _23303 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_23303 + idx + 68] = mem[_22811 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_23303 + 68] = mem[_23303 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _23303 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _25248 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25248] = 30
                                                mem[_25248 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _26610 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_26610 + idx + 68] = mem[_25248 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_26610 + 68] = mem[_26610 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _26610 + -mem[64] + 100
                                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                _32192 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32192] = 30
                                                mem[_32192 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _33757 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_33757 + idx + 68] = mem[_32192 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33757 + 68] = mem[_33757 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33757 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100:
                                                _22810 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22810] = 30
                                                mem[_22810 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 100 * 10^18:
                                                    _23300 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_23300 + idx + 68] = mem[_22810 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_23300 + 68] = mem[_23300 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _23300 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _25247 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25247] = 30
                                                mem[_25247 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                    _26607 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_26607 + idx + 68] = mem[_25247 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_26607 + 68] = mem[_26607 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _26607 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                                _32191 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32191] = 30
                                                mem[_32191 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _33754 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_33754 + idx + 68] = mem[_32191 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33754 + 68] = mem[_33754 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33754 + -mem[64] + 100
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _23299 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23299] = 30
                                            mem[_23299 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                                _23922 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23922 + idx + 68] = mem[_23299 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23922 + 68] = mem[_23922 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23922 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _26606 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26606] = 30
                                            mem[_26606 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                _28110 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_28110 + idx + 68] = mem[_26606 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_28110 + 68] = mem[_28110 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _28110 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                            _33753 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33753] = 30
                                            mem[_33753 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _35064 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35064 + idx + 68] = mem[_33753 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35064 + 68] = mem[_35064 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35064 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _21425 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21425] = 30
                                            mem[_21425 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _21539 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_21539 + idx + 68] = mem[_21425 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_21539 + 68] = mem[_21539 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _21539 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _21916 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21916] = 30
                                            mem[_21916 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _22089 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_22089 + idx + 68] = mem[_21916 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22089 + 68] = mem[_22089 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _22089 + -mem[64] + 100
                                        _21456 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21456] = 26
                                        mem[_21456 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100:
                                                _22812 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22812] = 30
                                                mem[_22812 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _25256 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25256] = 30
                                                mem[_25256 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _26620 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_26620 + idx + 68] = mem[_25256 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_26620 + 68] = mem[_26620 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _26620 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _32200 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32200] = 30
                                                mem[_32200 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _33764 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_33764 + idx + 68] = mem[_32200 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33764 + 68] = mem[_33764 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33764 + -mem[64] + 100
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _23307 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23307] = 30
                                            mem[_23307 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                _23932 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23932 + idx + 68] = mem[_23307 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23932 + 68] = mem[_23932 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23932 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _26619 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26619] = 30
                                            mem[_26619 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _28126 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_28126 + idx + 68] = mem[_26619 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_28126 + 68] = mem[_28126 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _28126 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            _33763 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33763] = 30
                                            mem[_33763 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _35076 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35076 + idx + 68] = mem[_33763 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35076 + 68] = mem[_35076 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35076 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            _23306 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23306] = 30
                                            mem[_23306 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                _23929 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23929 + idx + 68] = mem[_23306 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23929 + 68] = mem[_23929 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23929 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _26618 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26618] = 30
                                            mem[_26618 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                _28123 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_28123 + idx + 68] = mem[_26618 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_28123 + 68] = mem[_28123 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _28123 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            _33762 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33762] = 30
                                            mem[_33762 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _35073 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35073 + idx + 68] = mem[_33762 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35073 + 68] = mem[_35073 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35073 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23928 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23928] = 30
                                        mem[_23928 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            _24827 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_24827 + idx + 68] = mem[_23928 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24827 + 68] = mem[_24827 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _24827 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _28122 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28122] = 30
                                        mem[_28122 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _29713 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_29713 + idx + 68] = mem[_28122 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29713 + 68] = mem[_29713 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _29713 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        _35072 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35072] = 30
                                        mem[_35072 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _36384 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36384 + idx + 68] = mem[_35072 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36384 + 68] = mem[_36384 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36384 + -mem[64] + 100
                                    _21188 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21188] = 26
                                    mem[_21188 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 100 * 10^18:
                                        _21607 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21607] = 26
                                        mem[_21607 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100
                                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100:
                                                if 0 > arg2 * stor6 / 100 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100
                                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                                if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    else:
                                        _21606 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21606] = 26
                                        mem[_21606 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if not arg2 / 100:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100
                                                if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * t / s > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                                if arg2 / 100 * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * t / s
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100:
                                                if 0 > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * t / s
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100
                                                if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * t / s > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                                if arg2 / 100 * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * t / s
                                else:
                                    idx = 0
                                    s = 100 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _21387 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21387] = 26
                                            mem[_21387 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100:
                                                    _22604 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22604] = 30
                                                    mem[_22604 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 2
                                                    _24142 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24142] = 30
                                                    mem[_24142 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        _25261 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_25261 + idx + 68] = mem[_24142 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_25261 + 68] = mem[_25261 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _25261 + -mem[64] + 100
                                                    stor2[address(msg.sender)] -= arg2
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _27126 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_27126] = 30
                                                    mem[_27126 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _28615 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_28615 + idx + 68] = mem[_27126 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_28615 + 68] = mem[_28615 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _28615 + -mem[64] + 100
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _36412 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_36412] = 30
                                                    mem[_36412 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100
                                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                        return 1
                                                    _37693 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_37693 + idx + 68] = mem[_36412 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_37693 + 68] = mem[_37693 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _37693 + -mem[64] + 100
                                                require arg2 / 100
                                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _22814 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22814] = 30
                                                mem[_22814 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                    _23314 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_23314 + idx + 68] = mem[_22814 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_23314 + 68] = mem[_23314 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _23314 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _25260 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25260] = 30
                                                mem[_25260 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _26637 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_26637 + idx + 68] = mem[_25260 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_26637 + 68] = mem[_26637 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _26637 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _28612 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_28612] = 30
                                                mem[_28612 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _30362 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_30362 + idx + 68] = mem[_28612 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_30362 + 68] = mem[_30362 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _30362 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                _37692 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37692] = 30
                                                mem[_37692 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _38824 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38824 + idx + 68] = mem[_37692 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38824 + 68] = mem[_38824 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38824 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100:
                                                _22813 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22813] = 30
                                                mem[_22813 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 100 * 10^18:
                                                    _23311 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_23311 + idx + 68] = mem[_22813 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_23311 + 68] = mem[_23311 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _23311 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _25259 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25259] = 30
                                                mem[_25259 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _26634 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_26634 + idx + 68] = mem[_25259 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_26634 + 68] = mem[_26634 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _26634 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _28609 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_28609] = 30
                                                mem[_28609 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                    _30359 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_30359 + idx + 68] = mem[_28609 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_30359 + 68] = mem[_30359 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _30359 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                                _37691 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37691] = 30
                                                mem[_37691 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _38821 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38821 + idx + 68] = mem[_37691 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38821 + 68] = mem[_38821 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38821 + -mem[64] + 100
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _23310 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23310] = 30
                                            mem[_23310 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                                _23939 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23939 + idx + 68] = mem[_23310 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23939 + 68] = mem[_23939 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23939 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _26633 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26633] = 30
                                            mem[_26633 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _28146 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_28146 + idx + 68] = mem[_26633 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_28146 + 68] = mem[_28146 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _28146 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _30356 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30356] = 30
                                            mem[_30356 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                _32219 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32219 + idx + 68] = mem[_30356 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32219 + 68] = mem[_32219 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32219 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                            _38820 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38820] = 30
                                            mem[_38820 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _39630 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39630 + idx + 68] = mem[_38820 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39630 + 68] = mem[_39630 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39630 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _21426 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21426] = 30
                                            mem[_21426 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _21542 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_21542 + idx + 68] = mem[_21426 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_21542 + 68] = mem[_21542 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _21542 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _21918 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21918] = 30
                                            mem[_21918 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _22094 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_22094 + idx + 68] = mem[_21918 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22094 + 68] = mem[_22094 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _22094 + -mem[64] + 100
                                        _21457 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21457] = 26
                                        mem[_21457 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100:
                                                _22815 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22815] = 30
                                                mem[_22815 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _25268 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25268] = 30
                                                mem[_25268 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _26647 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_26647 + idx + 68] = mem[_25268 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_26647 + 68] = mem[_26647 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _26647 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _28618 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_28618] = 30
                                                mem[_28618 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _30374 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_30374 + idx + 68] = mem[_28618 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_30374 + 68] = mem[_30374 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _30374 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _37698 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37698] = 30
                                                mem[_37698 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _38831 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38831 + idx + 68] = mem[_37698 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38831 + 68] = mem[_38831 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38831 + -mem[64] + 100
                                            require arg2 / 100
                                            if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _23318 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23318] = 30
                                            mem[_23318 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                _23949 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23949 + idx + 68] = mem[_23318 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23949 + 68] = mem[_23949 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23949 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _26646 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26646] = 30
                                            mem[_26646 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _28160 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_28160 + idx + 68] = mem[_26646 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_28160 + 68] = mem[_28160 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _28160 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _30371 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30371] = 30
                                            mem[_30371 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _32237 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32237 + idx + 68] = mem[_30371 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32237 + 68] = mem[_32237 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32237 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            _38830 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38830] = 30
                                            mem[_38830 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _39642 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39642 + idx + 68] = mem[_38830 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39642 + 68] = mem[_39642 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39642 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100:
                                            _23317 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23317] = 30
                                            mem[_23317 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100 * 10^18:
                                                _23946 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_23946 + idx + 68] = mem[_23317 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23946 + 68] = mem[_23946 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _23946 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _26645 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26645] = 30
                                            mem[_26645 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _28157 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_28157 + idx + 68] = mem[_26645 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_28157 + 68] = mem[_28157 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _28157 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _30368 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30368] = 30
                                            mem[_30368 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                _32234 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32234 + idx + 68] = mem[_30368 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32234 + 68] = mem[_32234 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32234 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                            _38829 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38829] = 30
                                            mem[_38829 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _39639 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39639 + idx + 68] = mem[_38829 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39639 + 68] = mem[_39639 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39639 + -mem[64] + 100
                                        require arg2 / 100
                                        if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _23945 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23945] = 30
                                        mem[_23945 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                            _24852 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_24852 + idx + 68] = mem[_23945 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24852 + 68] = mem[_24852 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _24852 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _28156 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28156] = 30
                                        mem[_28156 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _29750 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_29750 + idx + 68] = mem[_28156 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29750 + 68] = mem[_29750 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _29750 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _32231 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32231] = 30
                                        mem[_32231 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                            _33800 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33800 + idx + 68] = mem[_32231 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33800 + 68] = mem[_33800 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33800 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                        _39638 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39638] = 30
                                        mem[_39638 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * stor6 / 100 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                            if totalFees + (arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _40206 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_40206 + idx + 68] = mem[_39638 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40206 + 68] = mem[_40206 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40206 + -mem[64] + 100
                                    _21193 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21193] = 26
                                    mem[_21193 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 100 * 10^18:
                                        _21609 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21609] = 26
                                        mem[_21609 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100:
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100
                                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * stor6 / 100 * 10^18 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                                if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 100 * 10^18 / arg2 != stor6 / 100 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100:
                                                if 0 > arg2 * stor6 / 100 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * stor6 / 100 * 10^18
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100
                                                if arg2 / 100 * stor6 / 100 * 10^18 / arg2 / 100 != stor6 / 100 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * stor6 / 100 * 10^18 > arg2 * stor6 / 100 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * stor6 / 100 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100 * 10^18) - (arg2 / 100 * stor6 / 100 * 10^18)
                                                if arg2 / 100 * stor6 / 100 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * stor6 / 100 * 10^18
                                    else:
                                        _21608 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21608] = 26
                                        mem[_21608 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if not arg2 / 100:
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100
                                                if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * t / s > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * t / s
                                                if arg2 / 100 * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * t / s
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100:
                                                if 0 > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * t / s
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100
                                                if arg2 / 100 * t / s / arg2 / 100 != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * t / s > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100)
                                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * t / s)
                                                if arg2 / 100 * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * t / s
    if totalFees + (arg2 / 100) < totalFees:
        revert with 0, 'SafeMath: addition overflow'
    totalFees += arg2 / 100
    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
    return 1
}



}
