contract main {




// =====================  Runtime code  =====================


#
#  - updateStateOnFlashLoan(address arg1, uint256 arg2, uint256 arg3, uint256 arg4)
#  - updateStateOnBorrow(address arg1, address arg2, uint256 arg3, uint256 arg4, uint8 arg5)
#  - updateStateOnLiquidation(address arg1, address arg2, address arg3, uint256 arg4, uint256 arg5, uint256 arg6, uint256 arg7, uint256 arg8, bool arg9)
#  - updateStateOnRepay(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, bool arg6)
#  - updateStateOnSwapRate(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint8 arg6)
#
const CORE_REVISION = 4


uint256 stor0;
uint8 stor1;
address sub_915254d0Address;
uint256 stor52;
address addressesProvider;
mapping of struct sub_3af361d5;
mapping of struct userLastUpdate;
array of struct reservesList;
array of address stor25430867293060105608850039578765632174687360837401588464629353882804403134873;

function getReserveIsActive(address arg1) {
    require calldata.size - 4 >= 32
    return bool(sub_3af361d5[address(arg1)].field_3808)
}

function isReserveUsageAsCollateralEnabled(address arg1) {
    require calldata.size - 4 >= 32
    return bool(sub_3af361d5[address(arg1)].field_3792)
}

function sub_3af361d5(?) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_3328
}

function getReserveCurrentAverageStableBorrowRate(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_1536
}

function getReserveIsFreezed(address arg1) {
    require calldata.size - 4 >= 32
    return bool(sub_3af361d5[address(arg1)].field_3816)
}

function getReserveLastUpdate(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_3744
}

function reservesList(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 < reservesList.length
    return reservesList[arg1].field_0
}

function isReserveBorrowingEnabled(address arg1) {
    require calldata.size - 4 >= 32
    return bool(sub_3af361d5[address(arg1)].field_3784)
}

function getReserveConfiguration(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_2816, 
           sub_3af361d5[address(arg1)].field_2048,
           sub_3af361d5[address(arg1)].field_2304,
           bool(sub_3af361d5[address(arg1)].field_3792)
}

function getUserLastUpdate(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    return userLastUpdate[address(arg2)][address(arg1)].field_1024
}

function sub_682b6665(?) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_3072
}

function getReserveInterestRateStrategyAddress(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_3584
}

function getUserCurrentStableBorrowRate(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    return userLastUpdate[address(arg2)][address(arg1)].field_768
}

function getReserveTotalBorrowsStable(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_512
}

function sub_915254d0(?) {
    return address(sub_915254d0Address)
}

function getReserveTotalBorrowsVariable(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_768
}

function isUserUseReserveAsCollateralEnabled(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    return bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
}

function getReserveIsStableBorrowRateEnabled(address arg1) {
    require calldata.size - 4 >= 32
    return bool(sub_3af361d5[address(arg1)].field_3800)
}

function getReserveDecimals(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_2816
}

function getReserveVariableBorrowsCumulativeIndex(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_1792
}

function getReserveLiquidityCumulativeIndex(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_0
}

function getReserveCurrentLiquidityRate(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_256
}

function addressesProvider() {
    return addressesProvider
}

function getReserveLiquidationBonus(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_2560
}

function getReserveLiquidationThreshold(address arg1) {
    require calldata.size - 4 >= 32
    return sub_3af361d5[address(arg1)].field_2304
}

function getUserVariableBorrowCumulativeIndex(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    return userLastUpdate[address(arg2)][address(arg1)].field_256
}

function getUserOriginationFee(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    return userLastUpdate[address(arg2)][address(arg1)].field_512
}

function getUserCurrentBorrowRateMode(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    if not userLastUpdate[address(arg2)][address(arg1)].field_0:
        return 0
    if userLastUpdate[address(arg2)][address(arg1)].field_768 > 0:
        return 1
    return 2
}

function getReserveTotalBorrows(address arg1) {
    require calldata.size - 4 >= 32
    if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
        revert with 0, 'SafeMath: addition overflow'
    return (sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512)
}

function getUserUnderlyingAssetBalance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require ext_code.size(sub_3af361d5[address(arg1)].field_3328)
    staticcall sub_3af361d5[address(arg1)].field_3328.0x70a08231 with:
            gas gas_remaining wei
           args arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getReserveAvailableLiquidity(address arg1) {
    require calldata.size - 4 >= 32
    if arg1 == 0x1111111111111111111111111111111111111111:
        return eth.balance(this.address)
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function setUserUseReserveAsCollateral(address arg1, address arg2, bool arg3) {
    require calldata.size - 4 >= 96
    if address(sub_915254d0Address) != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0x685468652063616c6c6572206d7573742062652061206d656e736120636f6e74726163,
                    mem[199 len 29]
    userLastUpdate[address(arg2)][address(arg1)].field_1064 = Mask(216, 0, arg3)
}

function getReserveCurrentVariableBorrowRate(address arg1) {
    require calldata.size - 4 >= 32
    if sub_3af361d5[address(arg1)].field_1024:
        return sub_3af361d5[address(arg1)].field_1024
    require ext_code.size(sub_3af361d5[address(arg1)].field_3584)
    staticcall sub_3af361d5[address(arg1)].field_3584.getBaseVariableBorrowRate() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function freezeReserve(address arg1) {
    require calldata.size - 4 >= 32
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    sub_3af361d5[address(arg1)].field_3816 = 1
}

function unfreezeReserve(address arg1) {
    require calldata.size - 4 >= 32
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    sub_3af361d5[address(arg1)].field_3816 = 0
}

function deactivateReserve(address arg1) {
    require calldata.size - 4 >= 32
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    sub_3af361d5[address(arg1)].field_3808 = 0
}

function enableReserveStableBorrowRate(address arg1) {
    require calldata.size - 4 >= 32
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    sub_3af361d5[address(arg1)].field_3800 = 1
}

function disableReserveStableBorrowRate(address arg1) {
    require calldata.size - 4 >= 32
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    sub_3af361d5[address(arg1)].field_3800 = 0
}

function setReserveDecimals(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    sub_3af361d5[address(arg1)].field_2816 = arg2
}

function _fallback() payable {
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(msg.sender):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    47,
                    0x644f6e6c7920636f6e7472616374732063616e2073656e6420657468657220746f20746865206d656e736120636f72,
                    mem[211 len 17]
    if not ext_code.hash(msg.sender):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    47,
                    0x644f6e6c7920636f6e7472616374732063616e2073656e6420657468657220746f20746865206d656e736120636f72,
                    mem[211 len 17]
}

function setReserveLiquidationBonus(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    sub_3af361d5[address(arg1)].field_2560 = arg2
}

function setReserveBaseLTVasCollateral(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    sub_3af361d5[address(arg1)].field_2048 = arg2
}

function setReserveLiquidationThreshold(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    sub_3af361d5[address(arg1)].field_2304 = arg2
}

function setReserveInterestRateStrategyAddress(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    sub_3af361d5[address(arg1)].field_3584 = arg2
}

function isUserAllowedToBorrowAtStable(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    if not sub_3af361d5[address(arg1)].field_3800:
        return 0
    if not userLastUpdate[address(arg2)][address(arg1)].field_1064:
        return not bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
    if not sub_3af361d5[address(arg1)].field_3792:
        return not bool(sub_3af361d5[address(arg1)].field_3792)
    require ext_code.size(sub_3af361d5[address(arg1)].field_3328)
    staticcall sub_3af361d5[address(arg1)].field_3328.0x70a08231 with:
            gas gas_remaining wei
           args arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return (arg3 > ext_call.return_data[0])
}

function getReserveCurrentStableBorrowRate(address arg1) {
    require calldata.size - 4 >= 32
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x9964fdb6 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if sub_3af361d5[address(arg1)].field_1280:
        return sub_3af361d5[address(arg1)].field_1280
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getMarketBorrowRate(address arg1) with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function initialize(address arg1) {
    require calldata.size - 4 >= 32
    if not stor1:
        if ext_code.size(this.address):
            if 4 <= stor0:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            46,
                            0x77436f6e747261637420696e7374616e63652068617320616c7265616479206265656e20696e697469616c697a65,
                            mem[210 len 18]
        if not stor1:
            stor1 = 1
            stor0 = 4
    addressesProvider = arg1
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0xef57ac50 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    uint256(stor52) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor52))
    if not stor1:
        stor1 = 0
}

function refreshConfiguration() {
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0xef57ac50 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    uint256(stor52) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor52))
}

function getReserves() {
    if not reservesList.length:
        mem[(32 * reservesList.length) + 128] = 32
        mem[(32 * reservesList.length) + 160] = reservesList.length
        mem[(32 * reservesList.length) + 192 len floor32(reservesList.length)] = mem[128 len floor32(reservesList.length)]
        return memory
          from (32 * reservesList.length) + 128
           len (96 * reservesList.length) + 64
    mem[128] = address(reservesList.field_0)
    idx = 128
    s = 0
    while (32 * reservesList.length) + 96 > idx:
        mem[idx + 32] = reservesList[s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * reservesList.length) + 192 len floor32(reservesList.length)] = mem[128 len floor32(reservesList.length)]
    return Array(len=reservesList.length, data=mem[128 len floor32(reservesList.length)], mem[(32 * reservesList.length) + floor32(reservesList.length) + 192 len (32 * reservesList.length) - floor32(reservesList.length)]), 
}

function disableBorrowingOnReserve(address arg1) {
    require calldata.size - 4 >= 32
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    require ext_code.size(0xd1ac5d8c456bdb3acde416ab39c028d18cd0936c)
    delegate 0xd1ac5d8c456bdb3acde416ab39c028d18cd0936c.0xe5df56a6 with:
         gas gas_remaining wei
        args sha3(address(arg1), 54)
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
}

function disableReserveAsCollateral(address arg1) {
    require calldata.size - 4 >= 32
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    require ext_code.size(0xd1ac5d8c456bdb3acde416ab39c028d18cd0936c)
    delegate 0xd1ac5d8c456bdb3acde416ab39c028d18cd0936c.0x83c165a0 with:
         gas gas_remaining wei
        args sha3(address(arg1), 54)
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
}

function enableBorrowingOnReserve(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    require ext_code.size(0xd1ac5d8c456bdb3acde416ab39c028d18cd0936c)
    delegate 0xd1ac5d8c456bdb3acde416ab39c028d18cd0936c.0xf63babbe with:
         gas gas_remaining wei
        args sha3(address(arg1), 54), arg2
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
}

function enableReserveAsCollateral(address arg1, uint256 arg2, uint256 arg3, uint256 arg4) {
    require calldata.size - 4 >= 128
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    require ext_code.size(0xd1ac5d8c456bdb3acde416ab39c028d18cd0936c)
    delegate 0xd1ac5d8c456bdb3acde416ab39c028d18cd0936c.0x24ddc4e6 with:
         gas gas_remaining wei
        args 0, uint32(sha3(address(arg1), 54)), arg2, arg3, arg4
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
}

function getReserveTotalLiquidity(address arg1) {
    require calldata.size - 4 >= 32
    if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
        revert with 0, 'SafeMath: addition overflow'
    if arg1 == 0x1111111111111111111111111111111111111111:
        if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address) < eth.balance(this.address):
            revert with 0, 'SafeMath: addition overflow'
        return (sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address))
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0, 'SafeMath: addition overflow'
    return (sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0])
}

function activateReserve(address arg1) {
    require calldata.size - 4 >= 32
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    if not sub_3af361d5[address(arg1)].field_0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x645265736572766520686173206e6f74206265656e20696e697469616c697a6564207965,
                    mem[200 len 28]
    if sub_3af361d5[address(arg1)].field_1792 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x645265736572766520686173206e6f74206265656e20696e697469616c697a6564207965,
                    mem[200 len 28]
    sub_3af361d5[address(arg1)].field_3808 = 1
}

function initReserve(address arg1, address arg2, uint256 arg3, address arg4) {
    require calldata.size - 4 >= 128
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    require ext_code.size(0xd1ac5d8c456bdb3acde416ab39c028d18cd0936c)
    delegate 0xd1ac5d8c456bdb3acde416ab39c028d18cd0936c.0x13769cd4 with:
         gas gas_remaining wei
        args 0, uint32(sha3(address(arg1), 54)), address(arg2), arg3, arg4
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    idx = 0
    s = 0
    while idx < reservesList.length:
        mem[0] = 56
        if reservesList[idx].field_0 != arg1:
            idx = idx + 1
            s = s
            continue 
        idx = idx + 1
        s = 1
        continue 
    if not s:
        reservesList.length++
        stor3839[stor56.length] = arg1
}

function transferToUser(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    if address(sub_915254d0Address) != msg.sender:
        require ext_code.size(addressesProvider)
        staticcall addressesProvider.0x159bab6e with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        41,
                        0x645468652063616c6c6572206d7573742062652061206d656e736120737461666620636f6e74726163,
                        mem[205 len 23]
    if arg1 == 0x1111111111111111111111111111111111111111:
        call arg2 with:
           value arg3 wei
             gas 50000 wei
        if not ext_call.success:
            revert with 0, 'Transfer of ETH failed'
    else:
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
            revert with 0, 'SafeERC20: call to non-contract'
        if not ext_code.hash(arg1):
            revert with 0, 'SafeERC20: call to non-contract'
        mem[196 len 64] = unknown_0xa9059cbb(?????), address(arg2) << 64, 0, Mask(224, 32, arg3) >> 32
        call arg1 with:
             gas gas_remaining wei
            args Mask(224, 32, arg3) << 224, mem[260 len 4]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'SafeERC20: low-level call failed'
            if not unknown_0xa9059cbb(?????), address(arg2) << 64:
                revert with 0, 32, 42, 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[306 len 22]
        else:
            mem[228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[228]:
                    revert with 0, 
                                32,
                                42,
                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 307 len 22]
}

function removeLastAddedReserve(address arg1) {
    require calldata.size - 4 >= 32
    require ext_code.size(addressesProvider)
    staticcall addressesProvider.0x295c2263 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6e5468652063616c6c6572206d7573742062652061206d656e736120636f6e666967757261746f7220636f6e74726163,
                    mem[212 len 16]
    require reservesList.length - 1 < reservesList.length
    if reservesList[reservesList.length].field_0 != arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    61,
                    0x7452657365727665206265696e672072656d6f76656420697320646966666572656e74207468616e207468652072657365727665207265717565737465,
                    mem[225 len 3]
    if sub_3af361d5[stor56[stor56.length].field_0].field_768 + sub_3af361d5[stor56[stor56.length].field_0].field_512 < sub_3af361d5[stor56[stor56.length].field_0].field_512:
        revert with 0, 'SafeMath: addition overflow'
    if sub_3af361d5[stor56[stor56.length].field_0].field_768 + sub_3af361d5[stor56[stor56.length].field_0].field_512:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x7443616e6e6f742072656d6f7665206120726573657276652077697468206c6971756964697479206465706f73697465,
                    mem[212 len 16]
    sub_3af361d5[stor56[stor56.length].field_0].field_3328 = 0
    sub_3af361d5[stor56[stor56.length].field_0].field_2816 = 0
    sub_3af361d5[stor56[stor56.length].field_0].field_0 = 0
    sub_3af361d5[stor56[stor56.length].field_0].field_1792 = 0
    sub_3af361d5[stor56[stor56.length].field_0].field_2048 = 0
    sub_3af361d5[stor56[stor56.length].field_0].field_2304 = 0
    sub_3af361d5[stor56[stor56.length].field_0].field_2560 = 0
    sub_3af361d5[stor56[stor56.length].field_0].field_3584 = 0xffffff00ff0000ffffffffff0000000000000000000000000000000000000000 and sub_3af361d5[stor56[stor56.length].field_0].field_3584
    require reservesList.length
    reservesList[reservesList.length].field_0 = 0
    reservesList.length--
}

function liquidateFee(address arg1, uint256 arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    if address(sub_915254d0Address) != msg.sender:
        require ext_code.size(addressesProvider)
        staticcall addressesProvider.0x159bab6e with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        41,
                        0x645468652063616c6c6572206d7573742062652061206d656e736120737461666620636f6e74726163,
                        mem[205 len 23]
    if msg.value:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    54,
                    0xfe466565206c69717569646174696f6e20646f6573206e6f74207265717569726520616e79207472616e73666572206f662076616c75,
                    mem[218 len 10]
    if arg1 == 0x1111111111111111111111111111111111111111:
        call arg3 with:
           value arg2 wei
             gas 50000 wei
        if not ext_call.success:
            revert with 0, 'Transfer of ETH failed'
    else:
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
            revert with 0, 'SafeERC20: call to non-contract'
        if not ext_code.hash(arg1):
            revert with 0, 'SafeERC20: call to non-contract'
        mem[196 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, Mask(224, 32, arg2) >> 32
        call arg1 with:
             gas gas_remaining wei
            args Mask(224, 32, arg2) << 224, mem[260 len 4]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'SafeERC20: low-level call failed'
            if not unknown_0xa9059cbb(?????), address(arg3) << 64:
                revert with 0, 32, 42, 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[306 len 22]
        else:
            mem[228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[228]:
                    revert with 0, 
                                32,
                                42,
                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 307 len 22]
}

function transferToFeeCollectionAddress(address arg1, address arg2, uint256 arg3, address arg4) payable {
    require calldata.size - 4 >= 128
    if address(sub_915254d0Address) != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0x685468652063616c6c6572206d7573742062652061206d656e736120636f6e74726163,
                    mem[199 len 29]
    if arg1 == 0x1111111111111111111111111111111111111111:
        if msg.value < arg3:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        53,
                        0x7454686520616d6f756e7420616e64207468652076616c75652073656e7420746f206465706f73697420646f206e6f74206d617463,
                        mem[217 len 11]
        call arg4 with:
           value arg3 wei
             gas 50000 wei
        if not ext_call.success:
            revert with 0, 'Transfer of ETH failed'
    else:
        if msg.value:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        95,
                        0x2e557365722069732073656e64696e672045544820616c6f6e67207769746820746865204552433230207472616e736665722e20436865636b207468652076616c756520617474726962757465206f6620746865207472616e73616374696f,
                        mem[259 len 1]
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
            revert with 0, 'SafeERC20: call to non-contract'
        if not ext_code.hash(arg1):
            revert with 0, 'SafeERC20: call to non-contract'
        mem[228 len 96] = unknown_0x23b872dd(?????), address(arg2) << 64, 0, address(arg4), Mask(224, 32, arg3) >> 32
        mem[352 len 4] = uint32(arg3)
        call arg1 with:
             gas gas_remaining wei
            args Mask(224, 32, arg3) << 480, mem[324 len 4]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'SafeERC20: low-level call failed'
            if not unknown_0x23b872dd(?????), address(arg2) << 64:
                revert with 0, 
                            32,
                            42,
                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[338 len 14],
                            uint32(arg3),
                            mem[356 len 4]
        else:
            mem[260 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[260]:
                    revert with 0, 
                                32,
                                42,
                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 339 len 22]
}

function transferToReserve(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if address(sub_915254d0Address) != msg.sender:
        require ext_code.size(addressesProvider)
        staticcall addressesProvider.0x159bab6e with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        41,
                        0x645468652063616c6c6572206d7573742062652061206d656e736120737461666620636f6e74726163,
                        mem[205 len 23]
    if arg1 == 0x1111111111111111111111111111111111111111:
        if msg.value < arg3:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        53,
                        0x7454686520616d6f756e7420616e64207468652076616c75652073656e7420746f206465706f73697420646f206e6f74206d617463,
                        mem[217 len 11]
        if msg.value > arg3:
            if arg3 > msg.value:
                revert with 0, 'SafeMath: subtraction overflow'
            call arg2 with:
               value msg.value - arg3 wei
                 gas 50000 wei
            if not ext_call.success:
                revert with 0, 'Transfer of ETH failed'
    else:
        if msg.value:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        50,
                        0x74557365722069732073656e64696e672045544820616c6f6e67207769746820746865204552433230207472616e73666572,
                        mem[214 len 14]
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
            revert with 0, 'SafeERC20: call to non-contract'
        if not ext_code.hash(arg1):
            revert with 0, 'SafeERC20: call to non-contract'
        mem[228 len 96] = unknown_0x23b872dd(?????), address(arg2) << 64, 0, address(this.address), Mask(224, 32, arg3) >> 32
        mem[352 len 4] = uint32(arg3)
        call arg1 with:
             gas gas_remaining wei
            args Mask(224, 32, arg3) << 480, mem[324 len 4]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'SafeERC20: low-level call failed'
            if not unknown_0x23b872dd(?????), address(arg2) << 64:
                revert with 0, 
                            32,
                            42,
                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[338 len 14],
                            uint32(arg3),
                            mem[356 len 4]
        else:
            mem[260 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[260]:
                    revert with 0, 
                                32,
                                42,
                                0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 339 len 22]
}

function getReserveUtilizationRate(address arg1) {
    require calldata.size - 4 >= 32
    if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
        revert with 0, 'SafeMath: addition overflow'
    if not sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512:
        return 0
    if arg1 == 0x1111111111111111111111111111111111111111:
        if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address) < eth.balance(this.address):
            revert with 0, 'SafeMath: addition overflow'
        if not sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512:
            if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address) / 2 < sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address) / 2:
                revert with 0, 'SafeMath: addition overflow'
            if not sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address):
                revert with 0, 'SafeMath: division by zero'
            return (sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address) / 2 / sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address))
        if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_768) + (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_512) / sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 != 1000000000 * 10^18:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_768) + (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_512) + (sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address) / 2) < sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address) / 2:
            revert with 0, 'SafeMath: addition overflow'
        if not sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address):
            revert with 0, 'SafeMath: division by zero'
        return ((1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_768) + (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_512) + (sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address) / 2) / sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + eth.balance(this.address))
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0, 'SafeMath: addition overflow'
    if not sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512:
        if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0] / 2 < sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0] / 2:
            revert with 0, 'SafeMath: addition overflow'
        if not sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        return (sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0] / 2 / sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0])
    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_768) + (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_512) / sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 != 1000000000 * 10^18:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_768) + (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_512) + (sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0] / 2) < sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0] / 2:
        revert with 0, 'SafeMath: addition overflow'
    if not sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero'
    return ((1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_768) + (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_512) + (sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0] / 2) / sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 + ext_call.return_data[0])
}

function getReserveNormalizedIncome(address arg1) {
    require calldata.size - 4 >= 32
    if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.timestamp - sub_3af361d5[address(arg1)].field_3744:
        if sub_3af361d5[address(arg1)].field_256:
            if 0 / sub_3af361d5[address(arg1)].field_256:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
            revert with 0, 'SafeMath: addition overflow'
        return ((1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18)
    if (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744) / block.timestamp - sub_3af361d5[address(arg1)].field_3744 != 10^9:
        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
    if not (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744):
        if sub_3af361d5[address(arg1)].field_256:
            if 0 / sub_3af361d5[address(arg1)].field_256:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
            revert with 0, 'SafeMath: addition overflow'
        return ((1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18)
    if (1000000000000000000 * 10^18 * block.timestamp) - (1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) / (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744) != 1000000000 * 10^18:
        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
    if (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) < 438 * 10^10 * 24 * 3600:
        revert with 0, 'SafeMath: addition overflow'
    if not sub_3af361d5[address(arg1)].field_256:
        if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
            revert with 0, 'SafeMath: addition overflow'
        return ((1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18)
    if (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256 / sub_3af361d5[address(arg1)].field_256 != (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600:
        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if ((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 < 500000000 * 10^18:
        revert with 0, 'SafeMath: addition overflow'
    if (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18 < ((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18:
        revert with 0, 'SafeMath: addition overflow'
    if not (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18:
        return 0
    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) / (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
        revert with 0, 'SafeMath: addition overflow'
    return ((1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18)
}

function getUserBasicReserveData(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    mem[0] = arg1
    mem[32] = 54
    require ext_code.size(sub_3af361d5[address(arg1)].field_3328)
    staticcall sub_3af361d5[address(arg1)].field_3328.0x70a08231 with:
            gas gas_remaining wei
           args arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not userLastUpdate[address(arg2)][address(arg1)].field_0:
        return ext_call.return_data[0], 0, 0, bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 / userLastUpdate[address(arg2)][address(arg1)].field_0 != 10^9:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if userLastUpdate[address(arg2)][address(arg1)].field_768:
        if userLastUpdate[address(arg2)][address(arg1)].field_1024 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        mem[64] = 224
        mem[192] = 'SafeMath: division by zero' << 48
        if (userLastUpdate[address(arg2)][address(arg1)].field_768 / 8760 * 24 * 3600) + 1000000000 * 10^18 < userLastUpdate[address(arg2)][address(arg1)].field_768 / 8760 * 24 * 3600:
            revert with 0, 'SafeMath: addition overflow'
        if bool(block.timestamp - userLastUpdate[address(arg2)][address(arg1)].field_1024):
            s = (userLastUpdate[address(arg2)][address(arg1)].field_768 / 8760 * 24 * 3600) + 1000000000 * 10^18
            idx = block.timestamp - userLastUpdate[address(arg2)][address(arg1)].field_1024 / 2
            t = (userLastUpdate[address(arg2)][address(arg1)].field_768 / 8760 * 24 * 3600) + 1000000000 * 10^18
            while idx:
                if not t:
                    _392 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_392] = 26
                    mem[_392 + 32] = 'SafeMath: division by zero' << 48
                    if not bool(idx):
                        s = s
                        idx = idx / 2
                        t = 0
                        continue 
                    if not s:
                        _458 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_458] = 26
                        mem[_458 + 32] = 'SafeMath: division by zero' << 48
                    else:
                        if 0 / s:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _473 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_473] = 26
                        mem[_473 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = 0
                    continue 
                if t * t / t != t:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _400 = mem[64]
                mem[64] = mem[64] + 64
                mem[_400] = 26
                mem[_400 + 32] = 'SafeMath: division by zero' << 48
                if not bool(idx):
                    s = s
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if not s:
                    _472 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_472] = 26
                    mem[_472 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _480 = mem[64]
                mem[64] = mem[64] + 64
                mem[_480] = 26
                mem[_480 + 32] = 'SafeMath: division by zero' << 48
                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                idx = idx / 2
                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                continue 
        else:
            s = 1000000000 * 10^18
            idx = block.timestamp - userLastUpdate[address(arg2)][address(arg1)].field_1024 / 2
            t = (userLastUpdate[address(arg2)][address(arg1)].field_768 / 8760 * 24 * 3600) + 1000000000 * 10^18
            while idx:
                if not t:
                    _393 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_393] = 26
                    mem[_393 + 32] = 'SafeMath: division by zero' << 48
                    if not bool(idx):
                        s = s
                        idx = idx / 2
                        t = 0
                        continue 
                    if not s:
                        _461 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_461] = 26
                        mem[_461 + 32] = 'SafeMath: division by zero' << 48
                    else:
                        if 0 / s:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _475 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_475] = 26
                        mem[_475 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = 0
                    continue 
                if t * t / t != t:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _401 = mem[64]
                mem[64] = mem[64] + 64
                mem[_401] = 26
                mem[_401 + 32] = 'SafeMath: division by zero' << 48
                if not bool(idx):
                    s = s
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if not s:
                    _474 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_474] = 26
                    mem[_474 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _481 = mem[64]
                mem[64] = mem[64] + 64
                mem[_481] = 26
                mem[_481 + 32] = 'SafeMath: division by zero' << 48
                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                idx = idx / 2
                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                continue 
        if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
            if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                return ext_call.return_data[0], 
                       0,
                       userLastUpdate[address(arg2)][address(arg1)].field_512,
                       bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
            if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                return ext_call.return_data[0], 
                       0,
                       userLastUpdate[address(arg2)][address(arg1)].field_512,
                       bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
        else:
            if 10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != s:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if (10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                revert with 0, 'SafeMath: addition overflow'
            if ((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                revert with 0, 'SafeMath: addition overflow'
            if ((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                return ext_call.return_data[0], 
                       ((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                       userLastUpdate[address(arg2)][address(arg1)].field_512,
                       bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
            if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                return ext_call.return_data[0], 
                       ((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                       userLastUpdate[address(arg2)][address(arg1)].field_512,
                       bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
    else:
        if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        mem[64] = 224
        mem[192] = 'SafeMath: division by zero' << 48
        if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
            revert with 0, 'SafeMath: addition overflow'
        if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
            s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
            while idx:
                if not t:
                    _390 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_390] = 26
                    mem[_390 + 32] = 'SafeMath: division by zero' << 48
                    if not bool(idx):
                        s = s
                        idx = idx / 2
                        t = 0
                        continue 
                    if not s:
                        _450 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_450] = 26
                        mem[_450 + 32] = 'SafeMath: division by zero' << 48
                    else:
                        if 0 / s:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _466 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_466] = 26
                        mem[_466 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = 0
                    continue 
                if t * t / t != t:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _396 = mem[64]
                mem[64] = mem[64] + 64
                mem[_396] = 26
                mem[_396 + 32] = 'SafeMath: division by zero' << 48
                if not bool(idx):
                    s = s
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if not s:
                    _465 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_465] = 26
                    mem[_465 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _477 = mem[64]
                mem[64] = mem[64] + 64
                mem[_477] = 26
                mem[_477 + 32] = 'SafeMath: division by zero' << 48
                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                idx = idx / 2
                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                continue 
            if not s:
                _402 = mem[64]
                mem[64] = mem[64] + 64
                mem[_402] = 26
                mem[_402 + 32] = 'SafeMath: division by zero' << 48
                if userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                    revert with 0, 'SafeMath: addition overflow'
                _464 = mem[64]
                mem[64] = mem[64] + 64
                mem[_464] = 26
                mem[_464 + 32] = 'SafeMath: division by zero' << 48
                if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                    revert with 0, 'SafeMath: division by zero'
                if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                    if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                        return ext_call.return_data[0], 
                               0,
                               userLastUpdate[address(arg2)][address(arg1)].field_512,
                               bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                    if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                        return ext_call.return_data[0], 
                               0,
                               userLastUpdate[address(arg2)][address(arg1)].field_512,
                               bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                else:
                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, 'SafeMath: addition overflow'
                    if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                        return ext_call.return_data[0], 
                               ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                               userLastUpdate[address(arg2)][address(arg1)].field_512,
                               bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                    if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                        return ext_call.return_data[0], 
                               ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                               userLastUpdate[address(arg2)][address(arg1)].field_512,
                               bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
            else:
                if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _408 = mem[64]
                mem[64] = mem[64] + 64
                mem[_408] = 26
                mem[_408 + 32] = 'SafeMath: division by zero' << 48
                if not (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18:
                    if userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                        revert with 0, 'SafeMath: addition overflow'
                    _476 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_476] = 26
                    mem[_476 + 32] = 'SafeMath: division by zero' << 48
                    if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 'SafeMath: division by zero'
                    if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                            return ext_call.return_data[0], 
                                   0,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            return ext_call.return_data[0], 
                                   0,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                    else:
                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                            return ext_call.return_data[0], 
                                   ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            return ext_call.return_data[0], 
                                   ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                else:
                    if 1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18 / (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                        revert with 0, 'SafeMath: addition overflow'
                    _482 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_482] = 26
                    mem[_482 + 32] = 'SafeMath: division by zero' << 48
                    if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 'SafeMath: division by zero'
                    if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                            return ext_call.return_data[0], 
                                   0,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            return ext_call.return_data[0], 
                                   0,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                    else:
                        if 10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                            return ext_call.return_data[0], 
                                   ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            return ext_call.return_data[0], 
                                   ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
        else:
            s = 1000000000 * 10^18
            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
            while idx:
                if not t:
                    _391 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_391] = 26
                    mem[_391 + 32] = 'SafeMath: division by zero' << 48
                    if not bool(idx):
                        s = s
                        idx = idx / 2
                        t = 0
                        continue 
                    if not s:
                        _455 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_455] = 26
                        mem[_455 + 32] = 'SafeMath: division by zero' << 48
                    else:
                        if 0 / s:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _471 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_471] = 26
                        mem[_471 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = 0
                    continue 
                if t * t / t != t:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _399 = mem[64]
                mem[64] = mem[64] + 64
                mem[_399] = 26
                mem[_399 + 32] = 'SafeMath: division by zero' << 48
                if not bool(idx):
                    s = s
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if not s:
                    _470 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_470] = 26
                    mem[_470 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _479 = mem[64]
                mem[64] = mem[64] + 64
                mem[_479] = 26
                mem[_479 + 32] = 'SafeMath: division by zero' << 48
                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                idx = idx / 2
                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                continue 
            if not s:
                _403 = mem[64]
                mem[64] = mem[64] + 64
                mem[_403] = 26
                mem[_403 + 32] = 'SafeMath: division by zero' << 48
                if userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                    revert with 0, 'SafeMath: addition overflow'
                _469 = mem[64]
                mem[64] = mem[64] + 64
                mem[_469] = 26
                mem[_469 + 32] = 'SafeMath: division by zero' << 48
                if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                    revert with 0, 'SafeMath: division by zero'
                if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                    if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                        return ext_call.return_data[0], 
                               0,
                               userLastUpdate[address(arg2)][address(arg1)].field_512,
                               bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                    if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                        return ext_call.return_data[0], 
                               0,
                               userLastUpdate[address(arg2)][address(arg1)].field_512,
                               bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                else:
                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, 'SafeMath: addition overflow'
                    if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                        return ext_call.return_data[0], 
                               ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                               userLastUpdate[address(arg2)][address(arg1)].field_512,
                               bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                    if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                        return ext_call.return_data[0], 
                               ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                               userLastUpdate[address(arg2)][address(arg1)].field_512,
                               bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
            else:
                if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _409 = mem[64]
                mem[64] = mem[64] + 64
                mem[_409] = 26
                mem[_409 + 32] = 'SafeMath: division by zero' << 48
                if not (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18:
                    if userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                        revert with 0, 'SafeMath: addition overflow'
                    _478 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_478] = 26
                    mem[_478 + 32] = 'SafeMath: division by zero' << 48
                    if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 'SafeMath: division by zero'
                    if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                            return ext_call.return_data[0], 
                                   0,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            return ext_call.return_data[0], 
                                   0,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                    else:
                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                            return ext_call.return_data[0], 
                                   ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            return ext_call.return_data[0], 
                                   ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                else:
                    if 1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18 / (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                        revert with 0, 'SafeMath: addition overflow'
                    _486 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_486] = 26
                    mem[_486 + 32] = 'SafeMath: division by zero' << 48
                    if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 'SafeMath: division by zero'
                    if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                            return ext_call.return_data[0], 
                                   0,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            return ext_call.return_data[0], 
                                   0,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                    else:
                        if 10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                            return ext_call.return_data[0], 
                                   ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            return ext_call.return_data[0], 
                                   ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   userLastUpdate[address(arg2)][address(arg1)].field_512,
                                   bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
    ('iszero', ('eq', 'timestamp', ('field', 1024, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'userLastUpdate', 55)))))))
    if userLastUpdate[address(arg2)][address(arg1)].field_0 + 1 < userLastUpdate[address(arg2)][address(arg1)].field_0:
        revert with 0, 'SafeMath: addition overflow'
    return ext_call.return_data[0], 
           userLastUpdate[address(arg2)][address(arg1)].field_0 + 1,
           userLastUpdate[address(arg2)][address(arg1)].field_512,
           bool(userLastUpdate[address(arg2)][address(arg1)].field_1064)
}

function getUserBorrowBalances(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    if not userLastUpdate[address(arg2)][address(arg1)].field_0:
        return 0
    mem[0] = arg1
    mem[32] = 54
    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 / userLastUpdate[address(arg2)][address(arg1)].field_0 != 10^9:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if userLastUpdate[address(arg2)][address(arg1)].field_768:
        if userLastUpdate[address(arg2)][address(arg1)].field_1024 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        mem[64] = 224
        mem[192] = 'SafeMath: division by zero' << 48
        if (userLastUpdate[address(arg2)][address(arg1)].field_768 / 8760 * 24 * 3600) + 1000000000 * 10^18 < userLastUpdate[address(arg2)][address(arg1)].field_768 / 8760 * 24 * 3600:
            revert with 0, 'SafeMath: addition overflow'
        if bool(block.timestamp - userLastUpdate[address(arg2)][address(arg1)].field_1024):
            s = (userLastUpdate[address(arg2)][address(arg1)].field_768 / 8760 * 24 * 3600) + 1000000000 * 10^18
            idx = block.timestamp - userLastUpdate[address(arg2)][address(arg1)].field_1024 / 2
            t = (userLastUpdate[address(arg2)][address(arg1)].field_768 / 8760 * 24 * 3600) + 1000000000 * 10^18
            while idx:
                if not t:
                    _723 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_723] = 26
                    mem[_723 + 32] = 'SafeMath: division by zero' << 48
                    if not bool(idx):
                        s = s
                        idx = idx / 2
                        t = 0
                        continue 
                    if not s:
                        _789 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_789] = 26
                        mem[_789 + 32] = 'SafeMath: division by zero' << 48
                    else:
                        if 0 / s:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _804 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_804] = 26
                        mem[_804 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = 0
                    continue 
                if t * t / t != t:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _731 = mem[64]
                mem[64] = mem[64] + 64
                mem[_731] = 26
                mem[_731 + 32] = 'SafeMath: division by zero' << 48
                if not bool(idx):
                    s = s
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if not s:
                    _803 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_803] = 26
                    mem[_803 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _811 = mem[64]
                mem[64] = mem[64] + 64
                mem[_811] = 26
                mem[_811 + 32] = 'SafeMath: division by zero' << 48
                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                idx = idx / 2
                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                continue 
        else:
            s = 1000000000 * 10^18
            idx = block.timestamp - userLastUpdate[address(arg2)][address(arg1)].field_1024 / 2
            t = (userLastUpdate[address(arg2)][address(arg1)].field_768 / 8760 * 24 * 3600) + 1000000000 * 10^18
            while idx:
                if not t:
                    _724 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_724] = 26
                    mem[_724 + 32] = 'SafeMath: division by zero' << 48
                    if not bool(idx):
                        s = s
                        idx = idx / 2
                        t = 0
                        continue 
                    if not s:
                        _792 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_792] = 26
                        mem[_792 + 32] = 'SafeMath: division by zero' << 48
                    else:
                        if 0 / s:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _806 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_806] = 26
                        mem[_806 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = 0
                    continue 
                if t * t / t != t:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _732 = mem[64]
                mem[64] = mem[64] + 64
                mem[_732] = 26
                mem[_732 + 32] = 'SafeMath: division by zero' << 48
                if not bool(idx):
                    s = s
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if not s:
                    _805 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_805] = 26
                    mem[_805 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _812 = mem[64]
                mem[64] = mem[64] + 64
                mem[_812] = 26
                mem[_812 + 32] = 'SafeMath: division by zero' << 48
                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                idx = idx / 2
                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                continue 
        if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
            if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
            if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
        else:
            if 10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != s:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if (10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                revert with 0, 'SafeMath: addition overflow'
            if ((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                revert with 0, 'SafeMath: addition overflow'
            if ((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                    revert with 0, 'SafeMath: subtraction overflow'
                return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                       ((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                       (((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
            if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                    revert with 0, 'SafeMath: subtraction overflow'
                return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                       ((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                       (((10^9 * s * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
    else:
        if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        mem[64] = 224
        mem[192] = 'SafeMath: division by zero' << 48
        if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
            revert with 0, 'SafeMath: addition overflow'
        if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
            s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
            while idx:
                if not t:
                    _721 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_721] = 26
                    mem[_721 + 32] = 'SafeMath: division by zero' << 48
                    if not bool(idx):
                        s = s
                        idx = idx / 2
                        t = 0
                        continue 
                    if not s:
                        _781 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_781] = 26
                        mem[_781 + 32] = 'SafeMath: division by zero' << 48
                    else:
                        if 0 / s:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _797 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_797] = 26
                        mem[_797 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = 0
                    continue 
                if t * t / t != t:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _727 = mem[64]
                mem[64] = mem[64] + 64
                mem[_727] = 26
                mem[_727 + 32] = 'SafeMath: division by zero' << 48
                if not bool(idx):
                    s = s
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if not s:
                    _796 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_796] = 26
                    mem[_796 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _808 = mem[64]
                mem[64] = mem[64] + 64
                mem[_808] = 26
                mem[_808 + 32] = 'SafeMath: division by zero' << 48
                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                idx = idx / 2
                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                continue 
            if not s:
                _733 = mem[64]
                mem[64] = mem[64] + 64
                mem[_733] = 26
                mem[_733 + 32] = 'SafeMath: division by zero' << 48
                if userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                    revert with 0, 'SafeMath: addition overflow'
                _795 = mem[64]
                mem[64] = mem[64] + 64
                mem[_795] = 26
                mem[_795 + 32] = 'SafeMath: division by zero' << 48
                if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                    revert with 0, 'SafeMath: division by zero'
                if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                    if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                    if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                else:
                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, 'SafeMath: addition overflow'
                    if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                               ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                               (((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
                    if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                               ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                               (((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
            else:
                if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _739 = mem[64]
                mem[64] = mem[64] + 64
                mem[_739] = 26
                mem[_739 + 32] = 'SafeMath: division by zero' << 48
                if not (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18:
                    if userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                        revert with 0, 'SafeMath: addition overflow'
                    _807 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_807] = 26
                    mem[_807 + 32] = 'SafeMath: division by zero' << 48
                    if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 'SafeMath: division by zero'
                    if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                    else:
                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                                   ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   (((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                                   ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   (((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
                else:
                    if 1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18 / (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                        revert with 0, 'SafeMath: addition overflow'
                    _813 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_813] = 26
                    mem[_813 + 32] = 'SafeMath: division by zero' << 48
                    if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 'SafeMath: division by zero'
                    if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                    else:
                        if 10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                                   ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   (((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                                   ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   (((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
        else:
            s = 1000000000 * 10^18
            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
            while idx:
                if not t:
                    _722 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_722] = 26
                    mem[_722 + 32] = 'SafeMath: division by zero' << 48
                    if not bool(idx):
                        s = s
                        idx = idx / 2
                        t = 0
                        continue 
                    if not s:
                        _786 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_786] = 26
                        mem[_786 + 32] = 'SafeMath: division by zero' << 48
                    else:
                        if 0 / s:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _802 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_802] = 26
                        mem[_802 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = 0
                    continue 
                if t * t / t != t:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _730 = mem[64]
                mem[64] = mem[64] + 64
                mem[_730] = 26
                mem[_730 + 32] = 'SafeMath: division by zero' << 48
                if not bool(idx):
                    s = s
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if not s:
                    _801 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_801] = 26
                    mem[_801 + 32] = 'SafeMath: division by zero' << 48
                    s = 0
                    idx = idx / 2
                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                    continue 
                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _810 = mem[64]
                mem[64] = mem[64] + 64
                mem[_810] = 26
                mem[_810 + 32] = 'SafeMath: division by zero' << 48
                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                idx = idx / 2
                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                continue 
            if not s:
                _734 = mem[64]
                mem[64] = mem[64] + 64
                mem[_734] = 26
                mem[_734 + 32] = 'SafeMath: division by zero' << 48
                if userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                    revert with 0, 'SafeMath: addition overflow'
                _800 = mem[64]
                mem[64] = mem[64] + 64
                mem[_800] = 26
                mem[_800 + 32] = 'SafeMath: division by zero' << 48
                if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                    revert with 0, 'SafeMath: division by zero'
                if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                    if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                    if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                else:
                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                        revert with 0, 'SafeMath: addition overflow'
                    if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                               ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                               (((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
                    if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                               ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                               (((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
            else:
                if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                _740 = mem[64]
                mem[64] = mem[64] + 64
                mem[_740] = 26
                mem[_740 + 32] = 'SafeMath: division by zero' << 48
                if not (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18:
                    if userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                        revert with 0, 'SafeMath: addition overflow'
                    _809 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_809] = 26
                    mem[_809 + 32] = 'SafeMath: division by zero' << 48
                    if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 'SafeMath: division by zero'
                    if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                    else:
                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                                   ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   (((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                                   ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   (((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
                else:
                    if 1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18 / (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 < userLastUpdate[address(arg2)][address(arg1)].field_257:
                        revert with 0, 'SafeMath: addition overflow'
                    _817 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_817] = 26
                    mem[_817 + 32] = 'SafeMath: division by zero' << 48
                    if not userLastUpdate[address(arg2)][address(arg1)].field_256:
                        revert with 0, 'SafeMath: division by zero'
                    if not 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0:
                        if userLastUpdate[address(arg2)][address(arg1)].field_0 != 0:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 0, -userLastUpdate[address(arg2)][address(arg1)].field_0
                    else:
                        if 10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0 / 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_0 != (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 < 500 * 10^6:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9 != userLastUpdate[address(arg2)][address(arg1)].field_0:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                                   ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   (((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
                        if block.timestamp == userLastUpdate[address(arg2)][address(arg1)].field_1024:
                            if userLastUpdate[address(arg2)][address(arg1)].field_0 > ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return userLastUpdate[address(arg2)][address(arg1)].field_0, 
                                   ((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9,
                                   (((10^9 * (1000000000 * 10^18 * (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18) + userLastUpdate[address(arg2)][address(arg1)].field_257 / userLastUpdate[address(arg2)][address(arg1)].field_256 * userLastUpdate[address(arg2)][address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18) + 500 * 10^6 / 10^9) - userLastUpdate[address(arg2)][address(arg1)].field_0
    ('iszero', ('eq', 'timestamp', ('field', 1024, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'userLastUpdate', 55)))))))
    if userLastUpdate[address(arg2)][address(arg1)].field_0 + 1 < userLastUpdate[address(arg2)][address(arg1)].field_0:
        revert with 0, 'SafeMath: addition overflow'
    if userLastUpdate[address(arg2)][address(arg1)].field_0 > userLastUpdate[address(arg2)][address(arg1)].field_0 + 1:
        revert with 0, 'SafeMath: subtraction overflow'
    return userLastUpdate[address(arg2)][address(arg1)].field_0, userLastUpdate[address(arg2)][address(arg1)].field_0 + 1, 1
}

function updateStateOnRedeem(address arg1, address arg2, uint256 arg3, bool arg4) {
    require calldata.size - 4 >= 128
    if address(sub_915254d0Address) != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0x685468652063616c6c6572206d7573742062652061206d656e736120636f6e74726163,
                    mem[199 len 29]
    if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
        revert with 0, 'SafeMath: addition overflow'
    if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512:
        if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.timestamp - sub_3af361d5[address(arg1)].field_3744:
            mem[192] = 'SafeMath: division by zero' << 48
            if not sub_3af361d5[address(arg1)].field_256:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero' << 48
                if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero' << 48
                sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[64] = 480
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero' << 48
                if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                    revert with 0, 'SafeMath: addition overflow'
                if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                    s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _1634 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1634] = 26
                            mem[_1634 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _1882 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1882] = 26
                                mem[_1882 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1926 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1926] = 26
                                mem[_1926 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1674 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1674] = 26
                        mem[_1674 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _1925 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1925] = 26
                            mem[_1925 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1968 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1968] = 26
                        mem[_1968 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
                else:
                    s = 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _1635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1635] = 26
                            mem[_1635 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _1887 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1887] = 26
                                mem[_1887 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1929 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1929] = 26
                                mem[_1929 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1677 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1677] = 26
                        mem[_1677 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _1928 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1928] = 26
                            mem[_1928 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1971 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1971] = 26
                        mem[_1971 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
            else:
                if 0 / sub_3af361d5[address(arg1)].field_256:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero' << 48
                if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero' << 48
                sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[64] = 480
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero' << 48
                if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                    revert with 0, 'SafeMath: addition overflow'
                if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                    s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _1632 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1632] = 26
                            mem[_1632 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _1872 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1872] = 26
                                mem[_1872 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1920 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1920] = 26
                                mem[_1920 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1668 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1668] = 26
                        mem[_1668 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _1919 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1919] = 26
                            mem[_1919 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1962 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1962] = 26
                        mem[_1962 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
                else:
                    s = 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _1633 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1633] = 26
                            mem[_1633 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _1877 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1877] = 26
                                mem[_1877 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1923 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1923] = 26
                                mem[_1923 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1671 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1671] = 26
                        mem[_1671 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _1922 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1922] = 26
                            mem[_1922 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1965 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1965] = 26
                        mem[_1965 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
        else:
            if (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744) / block.timestamp - sub_3af361d5[address(arg1)].field_3744 != 10^9:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744):
                mem[192] = 'SafeMath: division by zero' << 48
                if not sub_3af361d5[address(arg1)].field_256:
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero' << 48
                    sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[64] = 480
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero' << 48
                    if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                        revert with 0, 'SafeMath: addition overflow'
                    if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                        s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1630 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1630] = 26
                                mem[_1630 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1862 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1862] = 26
                                    mem[_1862 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1914 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1914] = 26
                                    mem[_1914 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1662] = 26
                            mem[_1662 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1913 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1913] = 26
                                mem[_1913 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1956 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1956] = 26
                            mem[_1956 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                    else:
                        s = 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1631 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1631] = 26
                                mem[_1631 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1867 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1867] = 26
                                    mem[_1867 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1917 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1917] = 26
                                    mem[_1917 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1665 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1665] = 26
                            mem[_1665 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1916 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1916] = 26
                                mem[_1916 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1959 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1959] = 26
                            mem[_1959 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                else:
                    if 0 / sub_3af361d5[address(arg1)].field_256:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero' << 48
                    sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[64] = 480
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero' << 48
                    if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                        revert with 0, 'SafeMath: addition overflow'
                    if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                        s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1628 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1628] = 26
                                mem[_1628 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1852 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1852] = 26
                                    mem[_1852 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1908] = 26
                                    mem[_1908 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1656 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1656] = 26
                            mem[_1656 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1907 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1907] = 26
                                mem[_1907 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1950 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1950] = 26
                            mem[_1950 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                    else:
                        s = 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1629 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1629] = 26
                                mem[_1629 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1857 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1857] = 26
                                    mem[_1857 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1911 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1911] = 26
                                    mem[_1911 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1659] = 26
                            mem[_1659 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1910 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1910] = 26
                                mem[_1910 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1953 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1953] = 26
                            mem[_1953 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
            else:
                if (1000000000000000000 * 10^18 * block.timestamp) - (1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) / (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744) != 1000000000 * 10^18:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) < 438 * 10^10 * 24 * 3600:
                    revert with 0, 'SafeMath: addition overflow'
                mem[192] = 'SafeMath: division by zero' << 48
                if not sub_3af361d5[address(arg1)].field_256:
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero' << 48
                    sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[64] = 480
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero' << 48
                    if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                        revert with 0, 'SafeMath: addition overflow'
                    if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                        s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1626 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1626] = 26
                                mem[_1626 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1842 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1842] = 26
                                    mem[_1842 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1902 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1902] = 26
                                    mem[_1902 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1650] = 26
                            mem[_1650 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1901 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1901] = 26
                                mem[_1901 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1944 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1944] = 26
                            mem[_1944 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                    else:
                        s = 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1627 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1627] = 26
                                mem[_1627 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1847 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1847] = 26
                                    mem[_1847 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1905 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1905] = 26
                                    mem[_1905 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1653] = 26
                            mem[_1653 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1904 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1904] = 26
                                mem[_1904 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1947 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1947] = 26
                            mem[_1947 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                else:
                    if (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256 / sub_3af361d5[address(arg1)].field_256 != (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if ((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18 < ((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18:
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_0 = 0
                        mem[352] = 30
                        mem[384] = 'SafeMath: subtraction overflow'
                        if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[64] = 480
                        mem[416] = 26
                        mem[448] = 'SafeMath: division by zero' << 48
                        if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                            revert with 0, 'SafeMath: addition overflow'
                        if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                            s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _1624 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1624] = 26
                                    mem[_1624 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _1832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1832] = 26
                                        mem[_1832 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _1896 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1896] = 26
                                        mem[_1896 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1644 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1644] = 26
                                mem[_1644 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _1895 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1895] = 26
                                    mem[_1895 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1938 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1938] = 26
                                mem[_1938 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                        else:
                            s = 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _1625 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1625] = 26
                                    mem[_1625 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _1837 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1837] = 26
                                        mem[_1837 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _1899 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1899] = 26
                                        mem[_1899 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1647 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1647] = 26
                                mem[_1647 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _1898 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1898] = 26
                                    mem[_1898 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1941 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1941] = 26
                                mem[_1941 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                    else:
                        if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) / (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                        mem[352] = 30
                        mem[384] = 'SafeMath: subtraction overflow'
                        if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[64] = 480
                        mem[416] = 26
                        mem[448] = 'SafeMath: division by zero' << 48
                        if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                            revert with 0, 'SafeMath: addition overflow'
                        if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                            s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _1622 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1622] = 26
                                    mem[_1622 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _1822 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1822] = 26
                                        mem[_1822 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _1890 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1890] = 26
                                        mem[_1890 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1638 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1638] = 26
                                mem[_1638 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _1889 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1889] = 26
                                    mem[_1889 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1932 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1932] = 26
                                mem[_1932 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                        else:
                            s = 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _1623 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1623] = 26
                                    mem[_1623 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _1827 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1827] = 26
                                        mem[_1827 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _1893 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1893] = 26
                                        mem[_1893 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1641 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1641] = 26
                                mem[_1641 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _1892 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1892] = 26
                                    mem[_1892 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1935 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1935] = 26
                                mem[_1935 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
        if not s:
            sub_3af361d5[address(arg1)].field_1792 = 0
        else:
            if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                revert with 0, 'SafeMath: addition overflow'
            sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
    if arg1 == 0x1111111111111111111111111111111111111111:
        if eth.balance(this.address) < eth.balance(this.address):
            revert with 0, 'SafeMath: addition overflow'
        if arg3 > eth.balance(this.address):
            revert with 0, 'SafeMath: subtraction overflow'
        require ext_code.size(sub_3af361d5[address(arg1)].field_3584)
        staticcall sub_3af361d5[address(arg1)].field_3584.calculateInterestRates(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5) with:
                gas gas_remaining wei
               args address(arg1), eth.balance(this.address) - arg3, sub_3af361d5[address(arg1)].field_512, sub_3af361d5[address(arg1)].field_768, sub_3af361d5[address(arg1)].field_1536
    else:
        require ext_code.size(arg1)
        staticcall arg1.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if arg3 > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        require ext_code.size(sub_3af361d5[address(arg1)].field_3584)
        staticcall sub_3af361d5[address(arg1)].field_3584.calculateInterestRates(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5) with:
                gas gas_remaining wei
               args address(arg1), ext_call.return_data[0] - arg3, sub_3af361d5[address(arg1)].field_512, sub_3af361d5[address(arg1)].field_768, sub_3af361d5[address(arg1)].field_1536
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    sub_3af361d5[address(arg1)].field_256 = ext_call.return_data[0]
    sub_3af361d5[address(arg1)].field_1280 = ext_call.return_data[32]
    sub_3af361d5[address(arg1)].field_1024 = ext_call.return_data[64]
    sub_3af361d5[address(arg1)].field_3744 = block.timestamp % 1099511627776
    emit ReserveUpdated(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], sub_3af361d5[address(arg1)].field_0, sub_3af361d5[address(arg1)].field_1792, arg1);
    if arg4:
        if address(sub_915254d0Address) != msg.sender:
            revert with 0, 
                        32,
                        35,
                        0x685468652063616c6c6572206d7573742062652061206d656e736120636f6e74726163,
                        sub_3af361d5[address(arg1)].field_0,
                        sub_3af361d5[address(arg1)].field_2016
        userLastUpdate[address(arg2)][address(arg1)].field_1064 = 0
}

function updateStateOnDeposit(address arg1, address arg2, uint256 arg3, bool arg4) {
    require calldata.size - 4 >= 128
    if address(sub_915254d0Address) != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0x685468652063616c6c6572206d7573742062652061206d656e736120636f6e74726163,
                    mem[199 len 29]
    if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
        revert with 0, 'SafeMath: addition overflow'
    if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512:
        if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.timestamp - sub_3af361d5[address(arg1)].field_3744:
            mem[192] = 'SafeMath: division by zero' << 48
            if not sub_3af361d5[address(arg1)].field_256:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero' << 48
                if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero' << 48
                sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[64] = 480
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero' << 48
                if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                    revert with 0, 'SafeMath: addition overflow'
                if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                    s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _1634 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1634] = 26
                            mem[_1634 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _1882 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1882] = 26
                                mem[_1882 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1926 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1926] = 26
                                mem[_1926 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1674 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1674] = 26
                        mem[_1674 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _1925 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1925] = 26
                            mem[_1925 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1968 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1968] = 26
                        mem[_1968 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
                else:
                    s = 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _1635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1635] = 26
                            mem[_1635 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _1887 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1887] = 26
                                mem[_1887 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1929 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1929] = 26
                                mem[_1929 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1677 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1677] = 26
                        mem[_1677 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _1928 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1928] = 26
                            mem[_1928 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1971 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1971] = 26
                        mem[_1971 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
            else:
                if 0 / sub_3af361d5[address(arg1)].field_256:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero' << 48
                if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero' << 48
                sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[64] = 480
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero' << 48
                if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                    revert with 0, 'SafeMath: addition overflow'
                if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                    s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _1632 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1632] = 26
                            mem[_1632 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _1872 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1872] = 26
                                mem[_1872 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1920 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1920] = 26
                                mem[_1920 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1668 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1668] = 26
                        mem[_1668 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _1919 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1919] = 26
                            mem[_1919 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1962 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1962] = 26
                        mem[_1962 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
                else:
                    s = 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _1633 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1633] = 26
                            mem[_1633 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _1877 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1877] = 26
                                mem[_1877 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1923 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1923] = 26
                                mem[_1923 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1671 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1671] = 26
                        mem[_1671 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _1922 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1922] = 26
                            mem[_1922 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _1965 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1965] = 26
                        mem[_1965 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
        else:
            if (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744) / block.timestamp - sub_3af361d5[address(arg1)].field_3744 != 10^9:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744):
                mem[192] = 'SafeMath: division by zero' << 48
                if not sub_3af361d5[address(arg1)].field_256:
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero' << 48
                    sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[64] = 480
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero' << 48
                    if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                        revert with 0, 'SafeMath: addition overflow'
                    if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                        s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1630 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1630] = 26
                                mem[_1630 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1862 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1862] = 26
                                    mem[_1862 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1914 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1914] = 26
                                    mem[_1914 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1662] = 26
                            mem[_1662 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1913 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1913] = 26
                                mem[_1913 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1956 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1956] = 26
                            mem[_1956 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                    else:
                        s = 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1631 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1631] = 26
                                mem[_1631 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1867 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1867] = 26
                                    mem[_1867 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1917 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1917] = 26
                                    mem[_1917 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1665 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1665] = 26
                            mem[_1665 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1916 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1916] = 26
                                mem[_1916 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1959 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1959] = 26
                            mem[_1959 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                else:
                    if 0 / sub_3af361d5[address(arg1)].field_256:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero' << 48
                    sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[64] = 480
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero' << 48
                    if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                        revert with 0, 'SafeMath: addition overflow'
                    if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                        s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1628 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1628] = 26
                                mem[_1628 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1852 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1852] = 26
                                    mem[_1852 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1908] = 26
                                    mem[_1908 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1656 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1656] = 26
                            mem[_1656 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1907 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1907] = 26
                                mem[_1907 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1950 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1950] = 26
                            mem[_1950 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                    else:
                        s = 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1629 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1629] = 26
                                mem[_1629 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1857 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1857] = 26
                                    mem[_1857 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1911 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1911] = 26
                                    mem[_1911 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1659] = 26
                            mem[_1659 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1910 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1910] = 26
                                mem[_1910 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1953 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1953] = 26
                            mem[_1953 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
            else:
                if (1000000000000000000 * 10^18 * block.timestamp) - (1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) / (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744) != 1000000000 * 10^18:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) < 438 * 10^10 * 24 * 3600:
                    revert with 0, 'SafeMath: addition overflow'
                mem[192] = 'SafeMath: division by zero' << 48
                if not sub_3af361d5[address(arg1)].field_256:
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero' << 48
                    sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[64] = 480
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero' << 48
                    if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                        revert with 0, 'SafeMath: addition overflow'
                    if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                        s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1626 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1626] = 26
                                mem[_1626 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1842 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1842] = 26
                                    mem[_1842 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1902 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1902] = 26
                                    mem[_1902 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1650] = 26
                            mem[_1650 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1901 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1901] = 26
                                mem[_1901 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1944 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1944] = 26
                            mem[_1944 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                    else:
                        s = 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _1627 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1627] = 26
                                mem[_1627 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _1847 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1847] = 26
                                    mem[_1847 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1905 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1905] = 26
                                    mem[_1905 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1653] = 26
                            mem[_1653 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _1904 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1904] = 26
                                mem[_1904 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _1947 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1947] = 26
                            mem[_1947 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                else:
                    if (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256 / sub_3af361d5[address(arg1)].field_256 != (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if ((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18 < ((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18:
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_0 = 0
                        mem[352] = 30
                        mem[384] = 'SafeMath: subtraction overflow'
                        if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[64] = 480
                        mem[416] = 26
                        mem[448] = 'SafeMath: division by zero' << 48
                        if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                            revert with 0, 'SafeMath: addition overflow'
                        if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                            s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _1624 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1624] = 26
                                    mem[_1624 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _1832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1832] = 26
                                        mem[_1832 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _1896 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1896] = 26
                                        mem[_1896 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1644 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1644] = 26
                                mem[_1644 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _1895 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1895] = 26
                                    mem[_1895 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1938 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1938] = 26
                                mem[_1938 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                        else:
                            s = 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _1625 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1625] = 26
                                    mem[_1625 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _1837 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1837] = 26
                                        mem[_1837 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _1899 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1899] = 26
                                        mem[_1899 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1647 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1647] = 26
                                mem[_1647 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _1898 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1898] = 26
                                    mem[_1898 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1941 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1941] = 26
                                mem[_1941 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                    else:
                        if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) / (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                        mem[352] = 30
                        mem[384] = 'SafeMath: subtraction overflow'
                        if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[64] = 480
                        mem[416] = 26
                        mem[448] = 'SafeMath: division by zero' << 48
                        if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                            revert with 0, 'SafeMath: addition overflow'
                        if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                            s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _1622 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1622] = 26
                                    mem[_1622 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _1822 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1822] = 26
                                        mem[_1822 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _1890 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1890] = 26
                                        mem[_1890 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1638 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1638] = 26
                                mem[_1638 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _1889 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1889] = 26
                                    mem[_1889 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1932 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1932] = 26
                                mem[_1932 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                        else:
                            s = 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _1623 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1623] = 26
                                    mem[_1623 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _1827 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1827] = 26
                                        mem[_1827 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _1893 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1893] = 26
                                        mem[_1893 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1641 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1641] = 26
                                mem[_1641 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _1892 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1892] = 26
                                    mem[_1892 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _1935 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1935] = 26
                                mem[_1935 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
        if not s:
            sub_3af361d5[address(arg1)].field_1792 = 0
        else:
            if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                revert with 0, 'SafeMath: addition overflow'
            sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
    if arg1 == 0x1111111111111111111111111111111111111111:
        if arg3 + eth.balance(this.address) < eth.balance(this.address):
            revert with 0, 'SafeMath: addition overflow'
        if 0 > arg3 + eth.balance(this.address):
            revert with 0, 'SafeMath: subtraction overflow'
        require ext_code.size(sub_3af361d5[address(arg1)].field_3584)
        staticcall sub_3af361d5[address(arg1)].field_3584.calculateInterestRates(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5) with:
                gas gas_remaining wei
               args address(arg1), arg3 + eth.balance(this.address), sub_3af361d5[address(arg1)].field_512, sub_3af361d5[address(arg1)].field_768, sub_3af361d5[address(arg1)].field_1536
    else:
        require ext_code.size(arg1)
        staticcall arg1.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg3 + ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if 0 > arg3 + ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        require ext_code.size(sub_3af361d5[address(arg1)].field_3584)
        staticcall sub_3af361d5[address(arg1)].field_3584.calculateInterestRates(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5) with:
                gas gas_remaining wei
               args address(arg1), arg3 + ext_call.return_data[0], sub_3af361d5[address(arg1)].field_512, sub_3af361d5[address(arg1)].field_768, sub_3af361d5[address(arg1)].field_1536
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    sub_3af361d5[address(arg1)].field_256 = ext_call.return_data[0]
    sub_3af361d5[address(arg1)].field_1280 = ext_call.return_data[32]
    sub_3af361d5[address(arg1)].field_1024 = ext_call.return_data[64]
    sub_3af361d5[address(arg1)].field_3744 = block.timestamp % 1099511627776
    emit ReserveUpdated(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], sub_3af361d5[address(arg1)].field_0, sub_3af361d5[address(arg1)].field_1792, arg1);
    if arg4:
        if address(sub_915254d0Address) != msg.sender:
            revert with 0, 
                        32,
                        35,
                        0x685468652063616c6c6572206d7573742062652061206d656e736120636f6e74726163,
                        sub_3af361d5[address(arg1)].field_0,
                        sub_3af361d5[address(arg1)].field_2016
        userLastUpdate[address(arg2)][address(arg1)].field_1064 = 1
}

function updateStateOnRebalance(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    if address(sub_915254d0Address) != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0x685468652063616c6c6572206d7573742062652061206d656e736120636f6e74726163,
                    mem[199 len 29]
    mem[0] = arg1
    mem[32] = sha3(address(arg2), 55)
    if sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
        revert with 0, 'SafeMath: addition overflow'
    if not sub_3af361d5[address(arg1)].field_768 + sub_3af361d5[address(arg1)].field_512:
        if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
            revert with 0, 'SafeMath: addition overflow'
        sub_3af361d5[address(arg1)].field_512 += arg3
        if not arg3:
            if not sub_3af361d5[address(arg1)].field_512:
                if not sub_3af361d5[address(arg1)].field_512:
                    revert with 0, 'SafeMath: division by zero'
                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                    revert with 0, 'SafeMath: addition overflow'
                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                    revert with 0, 'SafeMath: division by zero'
                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
            else:
                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                    if not sub_3af361d5[address(arg1)].field_512:
                        revert with 0, 'SafeMath: division by zero'
                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                        revert with 0, 'SafeMath: addition overflow'
                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                        revert with 0, 'SafeMath: division by zero'
                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                else:
                    if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    if not sub_3af361d5[address(arg1)].field_512:
                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        revert with 0, 'SafeMath: division by zero'
                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                            revert with 0, 'SafeMath: addition overflow'
                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: division by zero'
                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                            revert with 0, 'SafeMath: addition overflow'
                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: division by zero'
                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
        else:
            if 10^9 * arg3 / arg3 != 10^9:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if not 10^9 * arg3:
                if not sub_3af361d5[address(arg1)].field_512:
                    if not sub_3af361d5[address(arg1)].field_512:
                        revert with 0, 'SafeMath: division by zero'
                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                        revert with 0, 'SafeMath: addition overflow'
                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                        revert with 0, 'SafeMath: division by zero'
                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                else:
                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                        if not sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: division by zero'
                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                            revert with 0, 'SafeMath: addition overflow'
                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: division by zero'
                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if not sub_3af361d5[address(arg1)].field_512:
                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            revert with 0, 'SafeMath: division by zero'
                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                revert with 0, 'SafeMath: addition overflow'
                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: division by zero'
                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                revert with 0, 'SafeMath: addition overflow'
                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: division by zero'
                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
            else:
                if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                if not sub_3af361d5[address(arg1)].field_512:
                    if not sub_3af361d5[address(arg1)].field_512:
                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        revert with 0, 'SafeMath: division by zero'
                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                            revert with 0, 'SafeMath: addition overflow'
                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: division by zero'
                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                            revert with 0, 'SafeMath: addition overflow'
                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: division by zero'
                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                else:
                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                        if not sub_3af361d5[address(arg1)].field_512:
                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            revert with 0, 'SafeMath: division by zero'
                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                revert with 0, 'SafeMath: addition overflow'
                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: division by zero'
                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                revert with 0, 'SafeMath: addition overflow'
                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: division by zero'
                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if not sub_3af361d5[address(arg1)].field_512:
                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            revert with 0, 'SafeMath: division by zero'
                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                revert with 0, 'SafeMath: addition overflow'
                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: division by zero'
                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                revert with 0, 'SafeMath: addition overflow'
                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: division by zero'
                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
    else:
        if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.timestamp - sub_3af361d5[address(arg1)].field_3744:
            mem[192] = 'SafeMath: division by zero' << 48
            if not sub_3af361d5[address(arg1)].field_256:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero' << 48
                if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero' << 48
                sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[64] = 480
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero' << 48
                if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                    revert with 0, 'SafeMath: addition overflow'
                if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                    s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _10434 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10434] = 26
                            mem[_10434 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _10656 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10656] = 26
                                mem[_10656 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _10685 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10685] = 26
                                mem[_10685 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10474 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10474] = 26
                        mem[_10474 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _10684 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10684] = 26
                            mem[_10684 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10700] = 26
                        mem[_10700 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
                    if not s:
                        _10490 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10490] = 26
                        mem[_10490 + 32] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_1792 = 0
                        if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_3af361d5[address(arg1)].field_512 += arg3
                        if not arg3:
                            _10852 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10852] = 26
                            mem[_10852 + 32] = 'SafeMath: division by zero' << 48
                            if not sub_3af361d5[address(arg1)].field_512:
                                _11326 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11326] = 26
                                mem[_11326 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    _11422 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11422] = 26
                                    mem[_11422 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _11546 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11546] = 26
                                    mem[_11546 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if 10^9 * arg3 / arg3 != 10^9:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 10^9 * arg3:
                                _10907 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10907] = 26
                                mem[_10907 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11421 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11421] = 26
                                    mem[_11421 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11545 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11545] = 26
                                        mem[_11545 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11646 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11646] = 26
                                        mem[_11646 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10937 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10937] = 26
                                mem[_10937 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11544 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11544] = 26
                                    mem[_11544 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11645 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11645] = 26
                                        mem[_11645 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11692 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11692] = 26
                                        mem[_11692 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10504 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10504] = 26
                        mem[_10504 + 32] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_3af361d5[address(arg1)].field_512 += arg3
                        if not arg3:
                            _10906 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10906] = 26
                            mem[_10906 + 32] = 'SafeMath: division by zero' << 48
                            if not sub_3af361d5[address(arg1)].field_512:
                                _11418 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11418] = 26
                                mem[_11418 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    _11541 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11541] = 26
                                    mem[_11541 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _11644 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11644] = 26
                                    mem[_11644 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if 10^9 * arg3 / arg3 != 10^9:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 10^9 * arg3:
                                _10936 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10936] = 26
                                mem[_10936 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11540 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11540] = 26
                                    mem[_11540 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11643 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11643] = 26
                                        mem[_11643 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11691 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11691] = 26
                                        mem[_11691 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10952 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10952] = 26
                                mem[_10952 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11642 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11642] = 26
                                    mem[_11642 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11690 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11690] = 26
                                        mem[_11690 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11708 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11708] = 26
                                        mem[_11708 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                else:
                    s = 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _10435 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10435] = 26
                            mem[_10435 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _10659 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10659] = 26
                                mem[_10659 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _10687 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10687] = 26
                                mem[_10687 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10477 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10477] = 26
                        mem[_10477 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _10686 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10686] = 26
                            mem[_10686 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10701 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10701] = 26
                        mem[_10701 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
                    if not s:
                        _10491 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10491] = 26
                        mem[_10491 + 32] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_1792 = 0
                        if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_3af361d5[address(arg1)].field_512 += arg3
                        if not arg3:
                            _10855 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10855] = 26
                            mem[_10855 + 32] = 'SafeMath: division by zero' << 48
                            if not sub_3af361d5[address(arg1)].field_512:
                                _11331 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11331] = 26
                                mem[_11331 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    _11429 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11429] = 26
                                    mem[_11429 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _11555 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11555] = 26
                                    mem[_11555 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if 10^9 * arg3 / arg3 != 10^9:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 10^9 * arg3:
                                _10911 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10911] = 26
                                mem[_10911 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11428 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11428] = 26
                                    mem[_11428 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11554 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11554] = 26
                                        mem[_11554 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11653 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11653] = 26
                                        mem[_11653 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10939 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10939] = 26
                                mem[_10939 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11553 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11553] = 26
                                    mem[_11553 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11652 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11652] = 26
                                        mem[_11652 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11695 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11695] = 26
                                        mem[_11695 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10505 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10505] = 26
                        mem[_10505 + 32] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_3af361d5[address(arg1)].field_512 += arg3
                        if not arg3:
                            _10910 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10910] = 26
                            mem[_10910 + 32] = 'SafeMath: division by zero' << 48
                            if not sub_3af361d5[address(arg1)].field_512:
                                _11425 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11425] = 26
                                mem[_11425 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    _11550 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11550] = 26
                                    mem[_11550 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _11651 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11651] = 26
                                    mem[_11651 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if 10^9 * arg3 / arg3 != 10^9:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 10^9 * arg3:
                                _10938 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10938] = 26
                                mem[_10938 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11549 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11549] = 26
                                    mem[_11549 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11650 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11650] = 26
                                        mem[_11650 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11694 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11694] = 26
                                        mem[_11694 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10953 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10953] = 26
                                mem[_10953 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11649 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11649] = 26
                                    mem[_11649 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11693 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11693] = 26
                                        mem[_11693 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11709 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11709] = 26
                                        mem[_11709 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
            else:
                if 0 / sub_3af361d5[address(arg1)].field_256:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero' << 48
                if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero' << 48
                sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[64] = 480
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero' << 48
                if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                    revert with 0, 'SafeMath: addition overflow'
                if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                    s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _10432 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10432] = 26
                            mem[_10432 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _10650 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10650] = 26
                                mem[_10650 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _10681 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10681] = 26
                                mem[_10681 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10468 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10468] = 26
                        mem[_10468 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _10680 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10680] = 26
                            mem[_10680 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10698 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10698] = 26
                        mem[_10698 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
                    if not s:
                        _10488 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10488] = 26
                        mem[_10488 + 32] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_1792 = 0
                        if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_3af361d5[address(arg1)].field_512 += arg3
                        if not arg3:
                            _10846 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10846] = 26
                            mem[_10846 + 32] = 'SafeMath: division by zero' << 48
                            if not sub_3af361d5[address(arg1)].field_512:
                                _11316 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11316] = 26
                                mem[_11316 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    _11408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11408] = 26
                                    mem[_11408 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _11528 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11528] = 26
                                    mem[_11528 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if 10^9 * arg3 / arg3 != 10^9:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 10^9 * arg3:
                                _10899 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10899] = 26
                                mem[_10899 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11407 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11407] = 26
                                    mem[_11407 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11527 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11527] = 26
                                        mem[_11527 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11632 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11632] = 26
                                        mem[_11632 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10933 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10933] = 26
                                mem[_10933 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11526 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11526] = 26
                                    mem[_11526 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11631 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11631] = 26
                                        mem[_11631 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11686 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11686] = 26
                                        mem[_11686 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10502 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10502] = 26
                        mem[_10502 + 32] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_3af361d5[address(arg1)].field_512 += arg3
                        if not arg3:
                            _10898 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10898] = 26
                            mem[_10898 + 32] = 'SafeMath: division by zero' << 48
                            if not sub_3af361d5[address(arg1)].field_512:
                                _11404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11404] = 26
                                mem[_11404 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    _11523 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11523] = 26
                                    mem[_11523 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _11630 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11630] = 26
                                    mem[_11630 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if 10^9 * arg3 / arg3 != 10^9:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 10^9 * arg3:
                                _10932 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10932] = 26
                                mem[_10932 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11522 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11522] = 26
                                    mem[_11522 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11629 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11629] = 26
                                        mem[_11629 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11685 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11685] = 26
                                        mem[_11685 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10950 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10950] = 26
                                mem[_10950 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11628 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11628] = 26
                                    mem[_11628 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11684 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11684] = 26
                                        mem[_11684 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11706 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11706] = 26
                                        mem[_11706 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                else:
                    s = 1000000000 * 10^18
                    idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                    t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                    while idx:
                        if not t:
                            _10433 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10433] = 26
                            mem[_10433 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = 0
                                continue 
                            if not s:
                                _10653 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10653] = 26
                                mem[_10653 + 32] = 'SafeMath: division by zero' << 48
                            else:
                                if 0 / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _10683 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10683] = 26
                                mem[_10683 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = 0
                            continue 
                        if t * t / t != t:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10471 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10471] = 26
                        mem[_10471 + 32] = 'SafeMath: division by zero' << 48
                        if not bool(idx):
                            s = s
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _10682 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10682] = 26
                            mem[_10682 + 32] = 'SafeMath: division by zero' << 48
                            s = 0
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10699] = 26
                        mem[_10699 + 32] = 'SafeMath: division by zero' << 48
                        s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        idx = idx / 2
                        t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                        continue 
                    if not s:
                        _10489 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10489] = 26
                        mem[_10489 + 32] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_1792 = 0
                        if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_3af361d5[address(arg1)].field_512 += arg3
                        if not arg3:
                            _10849 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10849] = 26
                            mem[_10849 + 32] = 'SafeMath: division by zero' << 48
                            if not sub_3af361d5[address(arg1)].field_512:
                                _11321 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11321] = 26
                                mem[_11321 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    _11415 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11415] = 26
                                    mem[_11415 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _11537 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11537] = 26
                                    mem[_11537 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if 10^9 * arg3 / arg3 != 10^9:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 10^9 * arg3:
                                _10903 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10903] = 26
                                mem[_10903 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11414 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11414] = 26
                                    mem[_11414 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11536 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11536] = 26
                                        mem[_11536 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11639 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11639] = 26
                                        mem[_11639 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10935 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10935] = 26
                                mem[_10935 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11535 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11535] = 26
                                    mem[_11535 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11638 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11638] = 26
                                        mem[_11638 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11689 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11689] = 26
                                        mem[_11689 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        _10503 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10503] = 26
                        mem[_10503 + 32] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                        if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        sub_3af361d5[address(arg1)].field_512 += arg3
                        if not arg3:
                            _10902 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10902] = 26
                            mem[_10902 + 32] = 'SafeMath: division by zero' << 48
                            if not sub_3af361d5[address(arg1)].field_512:
                                _11411 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11411] = 26
                                mem[_11411 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: division by zero'
                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                    _11532 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11532] = 26
                                    mem[_11532 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _11637 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11637] = 26
                                    mem[_11637 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if 10^9 * arg3 / arg3 != 10^9:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 10^9 * arg3:
                                _10934 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10934] = 26
                                mem[_10934 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11531 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11531] = 26
                                    mem[_11531 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11636 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11636] = 26
                                        mem[_11636 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11688 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11688] = 26
                                        mem[_11688 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10951 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10951] = 26
                                mem[_10951 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11635 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11635] = 26
                                    mem[_11635 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11687 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11687] = 26
                                        mem[_11687 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11707 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11707] = 26
                                        mem[_11707 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
        else:
            if (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744) / block.timestamp - sub_3af361d5[address(arg1)].field_3744 != 10^9:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744):
                mem[192] = 'SafeMath: division by zero' << 48
                if not sub_3af361d5[address(arg1)].field_256:
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero' << 48
                    sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[64] = 480
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero' << 48
                    if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                        revert with 0, 'SafeMath: addition overflow'
                    if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                        s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _10430 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10430] = 26
                                mem[_10430 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _10644 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10644] = 26
                                    mem[_10644 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _10677 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10677] = 26
                                    mem[_10677 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10462 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10462] = 26
                            mem[_10462 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _10676 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10676] = 26
                                mem[_10676 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10696 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10696] = 26
                            mem[_10696 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _10486 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10486] = 26
                            mem[_10486 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = 0
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10840 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10840] = 26
                                mem[_10840 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11306 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11306] = 26
                                    mem[_11306 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11394 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11394] = 26
                                        mem[_11394 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11510 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11510] = 26
                                        mem[_11510 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10891 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10891] = 26
                                    mem[_10891 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11393 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11393] = 26
                                        mem[_11393 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11509 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11509] = 26
                                            mem[_11509 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11618 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11618] = 26
                                            mem[_11618 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10929 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10929] = 26
                                    mem[_10929 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11508 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11508] = 26
                                        mem[_11508 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11617 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11617] = 26
                                            mem[_11617 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11680 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11680] = 26
                                            mem[_11680 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10500 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10500] = 26
                            mem[_10500 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10890 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10890] = 26
                                mem[_10890 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11390 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11390] = 26
                                    mem[_11390 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11505 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11505] = 26
                                        mem[_11505 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11616 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11616] = 26
                                        mem[_11616 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10928 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10928] = 26
                                    mem[_10928 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11504 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11504] = 26
                                        mem[_11504 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11615 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11615] = 26
                                            mem[_11615 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11679 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11679] = 26
                                            mem[_11679 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10948 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10948] = 26
                                    mem[_10948 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11614 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11614] = 26
                                        mem[_11614 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11678 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11678] = 26
                                            mem[_11678 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11704 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11704] = 26
                                            mem[_11704 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        s = 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _10431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10431] = 26
                                mem[_10431 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _10647 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10647] = 26
                                    mem[_10647 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _10679 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10679] = 26
                                    mem[_10679 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10465 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10465] = 26
                            mem[_10465 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _10678 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10678] = 26
                                mem[_10678 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10697 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10697] = 26
                            mem[_10697 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _10487 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10487] = 26
                            mem[_10487 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = 0
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10843 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10843] = 26
                                mem[_10843 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11311 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11311] = 26
                                    mem[_11311 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11401 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11401] = 26
                                        mem[_11401 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11519 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11519] = 26
                                        mem[_11519 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10895 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10895] = 26
                                    mem[_10895 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11400 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11400] = 26
                                        mem[_11400 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11518 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11518] = 26
                                            mem[_11518 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11625 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11625] = 26
                                            mem[_11625 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10931 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10931] = 26
                                    mem[_10931 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11517 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11517] = 26
                                        mem[_11517 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11624 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11624] = 26
                                            mem[_11624 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11683 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11683] = 26
                                            mem[_11683 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10501 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10501] = 26
                            mem[_10501 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10894 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10894] = 26
                                mem[_10894 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11397 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11397] = 26
                                    mem[_11397 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11514 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11514] = 26
                                        mem[_11514 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11623 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11623] = 26
                                        mem[_11623 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10930 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10930] = 26
                                    mem[_10930 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11513 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11513] = 26
                                        mem[_11513 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11622 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11622] = 26
                                            mem[_11622 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11682 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11682] = 26
                                            mem[_11682 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10949 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10949] = 26
                                    mem[_10949 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11621 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11621] = 26
                                        mem[_11621 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11681 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11681] = 26
                                            mem[_11681 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11705 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11705] = 26
                                            mem[_11705 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                else:
                    if 0 / sub_3af361d5[address(arg1)].field_256:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero' << 48
                    sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[64] = 480
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero' << 48
                    if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                        revert with 0, 'SafeMath: addition overflow'
                    if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                        s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _10428 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10428] = 26
                                mem[_10428 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _10638 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10638] = 26
                                    mem[_10638 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _10673 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10673] = 26
                                    mem[_10673 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10456 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10456] = 26
                            mem[_10456 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _10672 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10672] = 26
                                mem[_10672 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10694 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10694] = 26
                            mem[_10694 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _10484 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10484] = 26
                            mem[_10484 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = 0
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10834 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10834] = 26
                                mem[_10834 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11296 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11296] = 26
                                    mem[_11296 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11380 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11380] = 26
                                        mem[_11380 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11492 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11492] = 26
                                        mem[_11492 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10883 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10883] = 26
                                    mem[_10883 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11379] = 26
                                        mem[_11379 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11491 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11491] = 26
                                            mem[_11491 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11604 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11604] = 26
                                            mem[_11604 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10925 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10925] = 26
                                    mem[_10925 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11490 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11490] = 26
                                        mem[_11490 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11603 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11603] = 26
                                            mem[_11603 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11674 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11674] = 26
                                            mem[_11674 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10498 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10498] = 26
                            mem[_10498 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10882 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10882] = 26
                                mem[_10882 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11376 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11376] = 26
                                    mem[_11376 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11487 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11487] = 26
                                        mem[_11487 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11602 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11602] = 26
                                        mem[_11602 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10924 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10924] = 26
                                    mem[_10924 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11486 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11486] = 26
                                        mem[_11486 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11601 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11601] = 26
                                            mem[_11601 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11673 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11673] = 26
                                            mem[_11673 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10946 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10946] = 26
                                    mem[_10946 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11600 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11600] = 26
                                        mem[_11600 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11672 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11672] = 26
                                            mem[_11672 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11702 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11702] = 26
                                            mem[_11702 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        s = 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _10429 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10429] = 26
                                mem[_10429 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _10641 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10641] = 26
                                    mem[_10641 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _10675 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10675] = 26
                                    mem[_10675 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10459 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10459] = 26
                            mem[_10459 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _10674 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10674] = 26
                                mem[_10674 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10695 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10695] = 26
                            mem[_10695 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _10485 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10485] = 26
                            mem[_10485 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = 0
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10837 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10837] = 26
                                mem[_10837 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11301] = 26
                                    mem[_11301 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11387 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11387] = 26
                                        mem[_11387 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11501 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11501] = 26
                                        mem[_11501 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10887 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10887] = 26
                                    mem[_10887 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11386 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11386] = 26
                                        mem[_11386 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11500 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11500] = 26
                                            mem[_11500 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11611 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11611] = 26
                                            mem[_11611 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10927 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10927] = 26
                                    mem[_10927 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11499 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11499] = 26
                                        mem[_11499 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11610 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11610] = 26
                                            mem[_11610 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11677 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11677] = 26
                                            mem[_11677 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10499 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10499] = 26
                            mem[_10499 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10886 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10886] = 26
                                mem[_10886 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11383 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11383] = 26
                                    mem[_11383 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11496 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11496] = 26
                                        mem[_11496 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11609 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11609] = 26
                                        mem[_11609 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10926 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10926] = 26
                                    mem[_10926 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11495 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11495] = 26
                                        mem[_11495 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11608 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11608] = 26
                                            mem[_11608 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11676 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11676] = 26
                                            mem[_11676 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10947 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10947] = 26
                                    mem[_10947 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11607 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11607] = 26
                                        mem[_11607 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11675 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11675] = 26
                                            mem[_11675 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11703 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11703] = 26
                                            mem[_11703 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
            else:
                if (1000000000000000000 * 10^18 * block.timestamp) - (1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) / (10^9 * block.timestamp) - (10^9 * sub_3af361d5[address(arg1)].field_3744) != 1000000000 * 10^18:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) < 438 * 10^10 * 24 * 3600:
                    revert with 0, 'SafeMath: addition overflow'
                mem[192] = 'SafeMath: division by zero' << 48
                if not sub_3af361d5[address(arg1)].field_256:
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0 / 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero' << 48
                    sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[64] = 480
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero' << 48
                    if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                        revert with 0, 'SafeMath: addition overflow'
                    if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                        s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _10426 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10426] = 26
                                mem[_10426 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _10632 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10632] = 26
                                    mem[_10632 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _10669 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10669] = 26
                                    mem[_10669 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10450 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10450] = 26
                            mem[_10450 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _10668 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10668] = 26
                                mem[_10668 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10692 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10692] = 26
                            mem[_10692 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _10482 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10482] = 26
                            mem[_10482 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = 0
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10828 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10828] = 26
                                mem[_10828 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11286 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11286] = 26
                                    mem[_11286 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11366 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11366] = 26
                                        mem[_11366 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11474 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11474] = 26
                                        mem[_11474 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10875 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10875] = 26
                                    mem[_10875 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11365 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11365] = 26
                                        mem[_11365 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11473 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11473] = 26
                                            mem[_11473 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11590 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11590] = 26
                                            mem[_11590 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10921 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10921] = 26
                                    mem[_10921 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11472 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11472] = 26
                                        mem[_11472 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11589 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11589] = 26
                                            mem[_11589 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11668 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11668] = 26
                                            mem[_11668 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10496 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10496] = 26
                            mem[_10496 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10874 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10874] = 26
                                mem[_10874 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11362 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11362] = 26
                                    mem[_11362 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11469 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11469] = 26
                                        mem[_11469 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11588 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11588] = 26
                                        mem[_11588 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10920 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10920] = 26
                                    mem[_10920 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11468 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11468] = 26
                                        mem[_11468 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11587 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11587] = 26
                                            mem[_11587 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11667 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11667] = 26
                                            mem[_11667 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10944 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10944] = 26
                                    mem[_10944 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11586 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11586] = 26
                                        mem[_11586 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11666 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11666] = 26
                                            mem[_11666 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11700 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11700] = 26
                                            mem[_11700 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        s = 1000000000 * 10^18
                        idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                        t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                        while idx:
                            if not t:
                                _10427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10427] = 26
                                mem[_10427 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if not s:
                                    _10635 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10635] = 26
                                    mem[_10635 + 32] = 'SafeMath: division by zero' << 48
                                else:
                                    if 0 / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _10671 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10671] = 26
                                    mem[_10671 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = 0
                                continue 
                            if t * t / t != t:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10453 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10453] = 26
                            mem[_10453 + 32] = 'SafeMath: division by zero' << 48
                            if not bool(idx):
                                s = s
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _10670 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10670] = 26
                                mem[_10670 + 32] = 'SafeMath: division by zero' << 48
                                s = 0
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10693 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10693] = 26
                            mem[_10693 + 32] = 'SafeMath: division by zero' << 48
                            s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            idx = idx / 2
                            t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                            continue 
                        if not s:
                            _10483 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10483] = 26
                            mem[_10483 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = 0
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10831 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10831] = 26
                                mem[_10831 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11291 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11291] = 26
                                    mem[_11291 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11373 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11373] = 26
                                        mem[_11373 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11483 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11483] = 26
                                        mem[_11483 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10879 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10879] = 26
                                    mem[_10879 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11372 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11372] = 26
                                        mem[_11372 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11482 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11482] = 26
                                            mem[_11482 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11597 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11597] = 26
                                            mem[_11597 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10923 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10923] = 26
                                    mem[_10923 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11481 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11481] = 26
                                        mem[_11481 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11596 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11596] = 26
                                            mem[_11596 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11671 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11671] = 26
                                            mem[_11671 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                revert with 0, 'SafeMath: addition overflow'
                            _10497 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10497] = 26
                            mem[_10497 + 32] = 'SafeMath: division by zero' << 48
                            sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                            if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            sub_3af361d5[address(arg1)].field_512 += arg3
                            if not arg3:
                                _10878 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10878] = 26
                                mem[_10878 + 32] = 'SafeMath: division by zero' << 48
                                if not sub_3af361d5[address(arg1)].field_512:
                                    _11369 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11369] = 26
                                    mem[_11369 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        revert with 0, 'SafeMath: division by zero'
                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                        _11478 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11478] = 26
                                        mem[_11478 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _11595 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11595] = 26
                                        mem[_11595 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if 10^9 * arg3 / arg3 != 10^9:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 10^9 * arg3:
                                    _10922 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10922] = 26
                                    mem[_10922 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11477 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11477] = 26
                                        mem[_11477 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11594 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11594] = 26
                                            mem[_11594 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11670 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11670] = 26
                                            mem[_11670 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    _10945 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10945] = 26
                                    mem[_10945 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11593 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11593] = 26
                                        mem[_11593 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11669 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11669] = 26
                                            mem[_11669 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11701 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11701] = 26
                                            mem[_11701 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                else:
                    if (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256 / sub_3af361d5[address(arg1)].field_256 != (1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if ((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 < 500000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero' << 48
                    if (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18 < ((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18:
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_0 = 0
                        mem[352] = 30
                        mem[384] = 'SafeMath: subtraction overflow'
                        if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[64] = 480
                        mem[416] = 26
                        mem[448] = 'SafeMath: division by zero' << 48
                        if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                            revert with 0, 'SafeMath: addition overflow'
                        if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                            s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _10424 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10424] = 26
                                    mem[_10424 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _10626 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10626] = 26
                                        mem[_10626 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _10665 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10665] = 26
                                        mem[_10665 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10444 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10444] = 26
                                mem[_10444 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _10664 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10664] = 26
                                    mem[_10664 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10690 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10690] = 26
                                mem[_10690 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _10480 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10480] = 26
                                mem[_10480 + 32] = 'SafeMath: division by zero' << 48
                                sub_3af361d5[address(arg1)].field_1792 = 0
                                if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_3af361d5[address(arg1)].field_512 += arg3
                                if not arg3:
                                    _10822 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10822] = 26
                                    mem[_10822 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11276 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11276] = 26
                                        mem[_11276 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11352 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11352] = 26
                                            mem[_11352 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11456 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11456] = 26
                                            mem[_11456 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * arg3 / arg3 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * arg3:
                                        _10867 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10867] = 26
                                        mem[_10867 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11351 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11351] = 26
                                            mem[_11351 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11455 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11455] = 26
                                                mem[_11455 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11576 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11576] = 26
                                                mem[_11576 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _10917 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10917] = 26
                                        mem[_10917 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11454 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11454] = 26
                                            mem[_11454 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11575 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11575] = 26
                                                mem[_11575 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11662 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11662] = 26
                                                mem[_11662 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10494 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10494] = 26
                                mem[_10494 + 32] = 'SafeMath: division by zero' << 48
                                sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_3af361d5[address(arg1)].field_512 += arg3
                                if not arg3:
                                    _10866 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10866] = 26
                                    mem[_10866 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11348 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11348] = 26
                                        mem[_11348 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11451 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11451] = 26
                                            mem[_11451 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11574 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11574] = 26
                                            mem[_11574 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * arg3 / arg3 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * arg3:
                                        _10916 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10916] = 26
                                        mem[_10916 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11450 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11450] = 26
                                            mem[_11450 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11573 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11573] = 26
                                                mem[_11573 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11661 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11661] = 26
                                                mem[_11661 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _10942 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10942] = 26
                                        mem[_10942 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11572 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11572] = 26
                                            mem[_11572 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11660 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11660] = 26
                                                mem[_11660 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11698 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11698] = 26
                                                mem[_11698 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            s = 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _10425 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10425] = 26
                                    mem[_10425 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _10629 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10629] = 26
                                        mem[_10629 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _10667 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10667] = 26
                                        mem[_10667 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10447 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10447] = 26
                                mem[_10447 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _10666 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10666] = 26
                                    mem[_10666 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10691 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10691] = 26
                                mem[_10691 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _10481 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10481] = 26
                                mem[_10481 + 32] = 'SafeMath: division by zero' << 48
                                sub_3af361d5[address(arg1)].field_1792 = 0
                                if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_3af361d5[address(arg1)].field_512 += arg3
                                if not arg3:
                                    _10825 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10825] = 26
                                    mem[_10825 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11281 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11281] = 26
                                        mem[_11281 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11359 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11359] = 26
                                            mem[_11359 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11465 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11465] = 26
                                            mem[_11465 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * arg3 / arg3 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * arg3:
                                        _10871 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10871] = 26
                                        mem[_10871 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11358 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11358] = 26
                                            mem[_11358 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11464 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11464] = 26
                                                mem[_11464 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11583 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11583] = 26
                                                mem[_11583 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _10919 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10919] = 26
                                        mem[_10919 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11463 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11463] = 26
                                            mem[_11463 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11582 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11582] = 26
                                                mem[_11582 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11665 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11665] = 26
                                                mem[_11665 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10495 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10495] = 26
                                mem[_10495 + 32] = 'SafeMath: division by zero' << 48
                                sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_3af361d5[address(arg1)].field_512 += arg3
                                if not arg3:
                                    _10870 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10870] = 26
                                    mem[_10870 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11355 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11355] = 26
                                        mem[_11355 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11460 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11460] = 26
                                            mem[_11460 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11581 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11581] = 26
                                            mem[_11581 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * arg3 / arg3 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * arg3:
                                        _10918 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10918] = 26
                                        mem[_10918 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11459 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11459] = 26
                                            mem[_11459 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11580 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11580] = 26
                                                mem[_11580 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11664 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11664] = 26
                                                mem[_11664 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _10943 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10943] = 26
                                        mem[_10943 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11579 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11579] = 26
                                            mem[_11579 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11663 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11663] = 26
                                                mem[_11663 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11699 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11699] = 26
                                                mem[_11699 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                    else:
                        if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) / (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18) + 1000000000 * 10^18 != sub_3af361d5[address(arg1)].field_0:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 < 500000000 * 10^18:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero' << 48
                        sub_3af361d5[address(arg1)].field_0 = (1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + (((1000000000000000000 * 10^18 * block.timestamp) + (-1000000000000000000 * 10^18 * sub_3af361d5[address(arg1)].field_3744) + (438 * 10^10 * 24 * 3600) / 876 * 10^10 * 24 * 3600 * sub_3af361d5[address(arg1)].field_256) + 500000000 * 10^18 / 1000000000 * 10^18 * sub_3af361d5[address(arg1)].field_0) + 500000000 * 10^18 / 1000000000 * 10^18
                        mem[352] = 30
                        mem[384] = 'SafeMath: subtraction overflow'
                        if sub_3af361d5[address(arg1)].field_3744 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[64] = 480
                        mem[416] = 26
                        mem[448] = 'SafeMath: division by zero' << 48
                        if (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18 < sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600:
                            revert with 0, 'SafeMath: addition overflow'
                        if bool(block.timestamp - sub_3af361d5[address(arg1)].field_3744):
                            s = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _10422 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10422] = 26
                                    mem[_10422 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _10620 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10620] = 26
                                        mem[_10620 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _10661 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10661] = 26
                                        mem[_10661 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10438 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10438] = 26
                                mem[_10438 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _10660 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10660] = 26
                                    mem[_10660 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10688 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10688] = 26
                                mem[_10688 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _10478 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10478] = 26
                                mem[_10478 + 32] = 'SafeMath: division by zero' << 48
                                sub_3af361d5[address(arg1)].field_1792 = 0
                                if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_3af361d5[address(arg1)].field_512 += arg3
                                if not arg3:
                                    _10816 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10816] = 26
                                    mem[_10816 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11266 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11266] = 26
                                        mem[_11266 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11338 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11338] = 26
                                            mem[_11338 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11438 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11438] = 26
                                            mem[_11438 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * arg3 / arg3 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * arg3:
                                        _10859 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10859] = 26
                                        mem[_10859 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11337 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11337] = 26
                                            mem[_11337 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11437 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11437] = 26
                                                mem[_11437 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11562 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11562] = 26
                                                mem[_11562 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _10913 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10913] = 26
                                        mem[_10913 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11436 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11436] = 26
                                            mem[_11436 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11561 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11561] = 26
                                                mem[_11561 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11656 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11656] = 26
                                                mem[_11656 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10492 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10492] = 26
                                mem[_10492 + 32] = 'SafeMath: division by zero' << 48
                                sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_3af361d5[address(arg1)].field_512 += arg3
                                if not arg3:
                                    _10858 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10858] = 26
                                    mem[_10858 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11334 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11334] = 26
                                        mem[_11334 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11433 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11433] = 26
                                            mem[_11433 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11560 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11560] = 26
                                            mem[_11560 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * arg3 / arg3 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * arg3:
                                        _10912 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10912] = 26
                                        mem[_10912 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11432 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11432] = 26
                                            mem[_11432 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11559 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11559] = 26
                                                mem[_11559 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11655 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11655] = 26
                                                mem[_11655 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _10940 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10940] = 26
                                        mem[_10940 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11558 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11558] = 26
                                            mem[_11558 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11654 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11654] = 26
                                                mem[_11654 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11696 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11696] = 26
                                                mem[_11696 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                        else:
                            s = 1000000000 * 10^18
                            idx = block.timestamp - sub_3af361d5[address(arg1)].field_3744 / 2
                            t = (sub_3af361d5[address(arg1)].field_1024 / 8760 * 24 * 3600) + 1000000000 * 10^18
                            while idx:
                                if not t:
                                    _10423 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10423] = 26
                                    mem[_10423 + 32] = 'SafeMath: division by zero' << 48
                                    if not bool(idx):
                                        s = s
                                        idx = idx / 2
                                        t = 0
                                        continue 
                                    if not s:
                                        _10623 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10623] = 26
                                        mem[_10623 + 32] = 'SafeMath: division by zero' << 48
                                    else:
                                        if 0 / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _10663 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10663] = 26
                                        mem[_10663 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = 0
                                    continue 
                                if t * t / t != t:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (t * t) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10441 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10441] = 26
                                mem[_10441 + 32] = 'SafeMath: division by zero' << 48
                                if not bool(idx):
                                    s = s
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if not s:
                                    _10662 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10662] = 26
                                    mem[_10662 + 32] = 'SafeMath: division by zero' << 48
                                    s = 0
                                    idx = idx / 2
                                    t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                    continue 
                                if (t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s / s != (t * t) + 500000000 * 10^18 / 1000000000 * 10^18:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10689 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10689] = 26
                                mem[_10689 + 32] = 'SafeMath: division by zero' << 48
                                s = ((t * t) + 500000000 * 10^18 / 1000000000 * 10^18 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                idx = idx / 2
                                t = (t * t) + 500000000 * 10^18 / 1000000000 * 10^18
                                continue 
                            if not s:
                                _10479 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10479] = 26
                                mem[_10479 + 32] = 'SafeMath: division by zero' << 48
                                sub_3af361d5[address(arg1)].field_1792 = 0
                                if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_3af361d5[address(arg1)].field_512 += arg3
                                if not arg3:
                                    _10819 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10819] = 26
                                    mem[_10819 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11271 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11271] = 26
                                        mem[_11271 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11345 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11345] = 26
                                            mem[_11345 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11447 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11447] = 26
                                            mem[_11447 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * arg3 / arg3 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * arg3:
                                        _10863 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10863] = 26
                                        mem[_10863 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11344 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11344] = 26
                                            mem[_11344 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11446 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11446] = 26
                                                mem[_11446 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11569 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11569] = 26
                                                mem[_11569 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _10915 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10915] = 26
                                        mem[_10915 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11445 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11445] = 26
                                            mem[_11445 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11568 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11568] = 26
                                                mem[_11568 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11659 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11659] = 26
                                                mem[_11659 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                            else:
                                if sub_3af361d5[address(arg1)].field_1792 * s / s != sub_3af361d5[address(arg1)].field_1792:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 < 500000000 * 10^18:
                                    revert with 0, 'SafeMath: addition overflow'
                                _10493 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10493] = 26
                                mem[_10493 + 32] = 'SafeMath: division by zero' << 48
                                sub_3af361d5[address(arg1)].field_1792 = (sub_3af361d5[address(arg1)].field_1792 * s) + 500000000 * 10^18 / 1000000000 * 10^18
                                if arg3 + sub_3af361d5[address(arg1)].field_512 < sub_3af361d5[address(arg1)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                sub_3af361d5[address(arg1)].field_512 += arg3
                                if not arg3:
                                    _10862 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10862] = 26
                                    mem[_10862 + 32] = 'SafeMath: division by zero' << 48
                                    if not sub_3af361d5[address(arg1)].field_512:
                                        _11341 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11341] = 26
                                        mem[_11341 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            revert with 0, 'SafeMath: division by zero'
                                        sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                            _11442 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11442] = 26
                                            mem[_11442 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            _11567 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11567] = 26
                                            mem[_11567 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                else:
                                    if 10^9 * arg3 / arg3 != 10^9:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 10^9 * arg3:
                                        _10914 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10914] = 26
                                        mem[_10914 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11441 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11441] = 26
                                            mem[_11441 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                revert with 0, 'SafeMath: division by zero'
                                            sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11566 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11566] = 26
                                                mem[_11566 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11658 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11658] = 26
                                                mem[_11658 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                    else:
                                        if 10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3 / 10^9 * arg3 != userLastUpdate[address(arg2)][address(arg1)].field_768:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 < 500000000 * 10^18:
                                            revert with 0, 'SafeMath: addition overflow'
                                        _10941 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_10941] = 26
                                        mem[_10941 + 32] = 'SafeMath: division by zero' << 48
                                        if not sub_3af361d5[address(arg1)].field_512:
                                            _11565 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11565] = 26
                                            mem[_11565 + 32] = 'SafeMath: division by zero' << 48
                                            if not sub_3af361d5[address(arg1)].field_512:
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                revert with 0, 'SafeMath: division by zero'
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                    revert with 0, 'SafeMath: division by zero'
                                                sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                        else:
                                            if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                _11657 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11657] = 26
                                                mem[_11657 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if 1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 / (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18 != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
                                            else:
                                                if 10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512 / 10^9 * sub_3af361d5[address(arg1)].field_512 != sub_3af361d5[address(arg1)].field_1536:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 < 500000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                _11697 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11697] = 26
                                                mem[_11697 + 32] = 'SafeMath: division by zero' << 48
                                                if not sub_3af361d5[address(arg1)].field_512:
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                    revert with 0, 'SafeMath: division by zero'
                                                if 10^9 * sub_3af361d5[address(arg1)].field_512 / sub_3af361d5[address(arg1)].field_512 != 10^9:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) < (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18):
                                                    if 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = 10^9 * sub_3af361d5[address(arg1)].field_512 / 2 / 10^9 * sub_3af361d5[address(arg1)].field_512
                                                else:
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) / ((10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + ((10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) != 1000000000 * 10^18:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) < 10^9 * sub_3af361d5[address(arg1)].field_512 / 2:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not 10^9 * sub_3af361d5[address(arg1)].field_512:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    sub_3af361d5[address(arg1)].field_1536 = (1000000000 * 10^18 * (10^9 * sub_3af361d5[address(arg1)].field_1536 * sub_3af361d5[address(arg1)].field_512) + 500000000 * 10^18 / 1000000000 * 10^18) + (1000000000 * 10^18 * (10^9 * userLastUpdate[address(arg2)][address(arg1)].field_768 * arg3) + 500000000 * 10^18 / 1000000000 * 10^18) + (10^9 * sub_3af361d5[address(arg1)].field_512 / 2) / 10^9 * sub_3af361d5[address(arg1)].field_512
    if arg3 + userLastUpdate[address(arg2)][address(arg1)].field_0 < userLastUpdate[address(arg2)][address(arg1)].field_0:
        revert with 0, 'SafeMath: addition overflow'
    userLastUpdate[address(arg2)][address(arg1)].field_0 += arg3
    userLastUpdate[address(arg2)][address(arg1)].field_768 = sub_3af361d5[address(arg1)].field_1280
    userLastUpdate[address(arg2)][address(arg1)].field_1024 = block.timestamp % 1099511627776
    if arg1 == 0x1111111111111111111111111111111111111111:
        if eth.balance(this.address) < eth.balance(this.address):
            revert with 0, 'SafeMath: addition overflow'
        if 0 > eth.balance(this.address):
            revert with 0, 'SafeMath: subtraction overflow'
        require ext_code.size(sub_3af361d5[address(arg1)].field_3584)
        staticcall sub_3af361d5[address(arg1)].field_3584.calculateInterestRates(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5) with:
                gas gas_remaining wei
               args address(arg1), eth.balance(this.address), sub_3af361d5[address(arg1)].field_512, sub_3af361d5[address(arg1)].field_768, sub_3af361d5[address(arg1)].field_1536
    else:
        require ext_code.size(arg1)
        staticcall arg1.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if 0 > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        require ext_code.size(sub_3af361d5[address(arg1)].field_3584)
        staticcall sub_3af361d5[address(arg1)].field_3584.calculateInterestRates(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5) with:
                gas gas_remaining wei
               args address(arg1), ext_call.return_data[0], sub_3af361d5[address(arg1)].field_512, sub_3af361d5[address(arg1)].field_768, sub_3af361d5[address(arg1)].field_1536
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    sub_3af361d5[address(arg1)].field_256 = ext_call.return_data[0]
    sub_3af361d5[address(arg1)].field_1280 = ext_call.return_data[32]
    sub_3af361d5[address(arg1)].field_1024 = ext_call.return_data[64]
    sub_3af361d5[address(arg1)].field_3744 = block.timestamp % 1099511627776
    emit ReserveUpdated(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], sub_3af361d5[address(arg1)].field_0, sub_3af361d5[address(arg1)].field_1792, arg1);
    return userLastUpdate[address(arg2)][address(arg1)].field_768
}



}
