contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#
const totalSupply = 1000 * 10^18


address owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
array of address stor5;
uint256 stor6;
uint256 totalFees;
array of uint256 name;
array of uint256 symbol;
uint8 decimals;
uint8 reflectFees; offset 8

function name() payable {
    return name[0 len name.length]
}

function reflectFees() payable {
    return reflectFees
}

function totalFees() payable {
    return totalFees
}

function decimals() payable {
    return decimals
}

function owner() payable {
    return owner
}

function symbol() payable {
    return symbol[0 len symbol.length]
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor4[address(arg1)])
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return allowance[address(arg1)][address(arg2)]
}

function _fallback() payable {
    revert
}

function setFeeRate() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    reflectFees = 2
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x734f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        if stor5[idx] != arg1:
            idx = idx + 1
            continue 
        require stor5.length - 1 < stor5.length
        require idx < stor5.length
        stor5[idx] = stor5[stor5.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        require stor5.length
        stor5[stor5.length] = 0
        stor5.length--
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 > allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 
                    32,
                    37,
                    0x6e45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572,
                    mem[165 len 27],
                    mem[219 len 5]
    if not msg.sender:
        revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[296 len 28]
    if not arg1:
        revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[294 len 30]
    allowance[address(msg.sender)][address(arg1)] -= arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if allowance[address(msg.sender)][address(arg1)] + arg2 < allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] += arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor6:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                    mem[206 len 22]
    idx = 0
    s = 1000 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _77 = mem[64]
            mem[64] = mem[64] + 64
            mem[_77] = 26
            mem[_77 + 32] = 'SafeMath: division by zero'
            _95 = mem[64]
            mem[64] = mem[64] + 64
            mem[_95] = 26
            mem[_95 + 32] = 'SafeMath: division by zero'
            if stor6 / 1000 * 10^18 > 0:
                require stor6 / 1000 * 10^18
                return (arg1 / stor6 / 1000 * 10^18)
            _101 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_101 + idx + 68] = mem[_95 + idx + 32]
                idx = idx + 32
                continue 
            mem[_101 + 68] = mem[_101 + 74 len 26]
            revert with memory
              from mem[64]
               len _101 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _81 = mem[64]
            mem[64] = mem[64] + 64
            mem[_81] = 26
            mem[_81 + 32] = 'SafeMath: division by zero'
            _107 = mem[64]
            mem[64] = mem[64] + 64
            mem[_107] = 26
            mem[_107 + 32] = 'SafeMath: division by zero'
            if stor6 / 1000 * 10^18 > 0:
                require stor6 / 1000 * 10^18
                return (arg1 / stor6 / 1000 * 10^18)
            _113 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_113 + idx + 68] = mem[_107 + idx + 32]
                idx = idx + 32
                continue 
            mem[_113 + 68] = mem[_113 + 74 len 26]
            revert with memory
              from mem[64]
               len _113 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 1
        _80 = mem[64]
        mem[64] = mem[64] + 64
        mem[_80] = 30
        mem[_80 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _82 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_82 + idx + 68] = mem[_80 + idx + 32]
                idx = idx + 32
                continue 
            mem[_82 + 68] = mem[_82 + 70 len 30]
            revert with memory
              from mem[64]
               len _82 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        _96 = mem[64]
        mem[64] = mem[64] + 64
        mem[_96] = 30
        mem[_96 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _104 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_104 + idx + 68] = mem[_96 + idx + 32]
            idx = idx + 32
            continue 
        mem[_104 + 68] = mem[_104 + 70 len 30]
        revert with memory
          from mem[64]
           len _104 + -mem[64] + 100
    if t < stor6 / 1000 * 10^18:
        if stor6 / 1000 * 10^18 <= 0:
            revert with 0, 'SafeMath: division by zero'
        if stor6 / 1000 * 10^18:
            return (arg1 / stor6 / 1000 * 10^18)
    else:
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        if s:
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero'
            if t / s:
                return (arg1 / t / s)
    revert
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor6:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                    mem[206 len 22]
    idx = 0
    s = 1000 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _82 = mem[64]
            mem[64] = mem[64] + 64
            mem[_82] = 26
            mem[_82 + 32] = 'SafeMath: division by zero'
            _100 = mem[64]
            mem[64] = mem[64] + 64
            mem[_100] = 26
            mem[_100 + 32] = 'SafeMath: division by zero'
            if stor6 / 1000 * 10^18 > 0:
                require stor6 / 1000 * 10^18
                return (stor1[address(arg1)] / stor6 / 1000 * 10^18)
            _106 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_106 + idx + 68] = mem[_100 + idx + 32]
                idx = idx + 32
                continue 
            mem[_106 + 68] = mem[_106 + 74 len 26]
            revert with memory
              from mem[64]
               len _106 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _86 = mem[64]
            mem[64] = mem[64] + 64
            mem[_86] = 26
            mem[_86 + 32] = 'SafeMath: division by zero'
            _112 = mem[64]
            mem[64] = mem[64] + 64
            mem[_112] = 26
            mem[_112 + 32] = 'SafeMath: division by zero'
            if stor6 / 1000 * 10^18 > 0:
                require stor6 / 1000 * 10^18
                return (stor1[address(arg1)] / stor6 / 1000 * 10^18)
            _118 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_118 + idx + 68] = mem[_112 + idx + 32]
                idx = idx + 32
                continue 
            mem[_118 + 68] = mem[_118 + 74 len 26]
            revert with memory
              from mem[64]
               len _118 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 1
        _85 = mem[64]
        mem[64] = mem[64] + 64
        mem[_85] = 30
        mem[_85 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _87 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_87 + idx + 68] = mem[_85 + idx + 32]
                idx = idx + 32
                continue 
            mem[_87 + 68] = mem[_87 + 70 len 30]
            revert with memory
              from mem[64]
               len _87 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        _101 = mem[64]
        mem[64] = mem[64] + 64
        mem[_101] = 30
        mem[_101 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _109 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_109 + idx + 68] = mem[_101 + idx + 32]
            idx = idx + 32
            continue 
        mem[_109 + 68] = mem[_109 + 70 len 30]
        revert with memory
          from mem[64]
           len _109 + -mem[64] + 100
    if t < stor6 / 1000 * 10^18:
        if stor6 / 1000 * 10^18 <= 0:
            revert with 0, 'SafeMath: division by zero'
        if stor6 / 1000 * 10^18:
            return (stor1[address(arg1)] / stor6 / 1000 * 10^18)
    else:
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        if s:
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero'
            if t / s:
                return (stor1[address(arg1)] / t / s)
    revert
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor1[address(arg1)] > 0:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor6:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        42,
                        0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                        mem[206 len 22]
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _90 = mem[64]
                mem[64] = mem[64] + 64
                mem[_90] = 26
                mem[_90 + 32] = 'SafeMath: division by zero'
                _108 = mem[64]
                mem[64] = mem[64] + 64
                mem[_108] = 26
                mem[_108 + 32] = 'SafeMath: division by zero'
                if stor6 / 1000 * 10^18 > 0:
                    require stor6 / 1000 * 10^18
                    stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 1000 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor5[stor5.length] = arg1
                _114 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_114 + idx + 68] = mem[_108 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_114 + 68] = mem[_114 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _114 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _94 = mem[64]
                mem[64] = mem[64] + 64
                mem[_94] = 26
                mem[_94 + 32] = 'SafeMath: division by zero'
                _120 = mem[64]
                mem[64] = mem[64] + 64
                mem[_120] = 26
                mem[_120 + 32] = 'SafeMath: division by zero'
                if stor6 / 1000 * 10^18 > 0:
                    require stor6 / 1000 * 10^18
                    stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 1000 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor5[stor5.length] = arg1
                _126 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_126 + idx + 68] = mem[_120 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_126 + 68] = mem[_126 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _126 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 1
            _93 = mem[64]
            mem[64] = mem[64] + 64
            mem[_93] = 30
            mem[_93 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _95 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_95 + idx + 68] = mem[_93 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_95 + 68] = mem[_95 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _95 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            _109 = mem[64]
            mem[64] = mem[64] + 64
            mem[_109] = 30
            mem[_109 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _117 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_117 + idx + 68] = mem[_109 + idx + 32]
                idx = idx + 32
                continue 
            mem[_117 + 68] = mem[_117 + 70 len 30]
            revert with memory
              from mem[64]
               len _117 + -mem[64] + 100
        if t < stor6 / 1000 * 10^18:
            if stor6 / 1000 * 10^18 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require stor6 / 1000 * 10^18
            stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 1000 * 10^18
        else:
            if s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require s
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require t / s
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
    stor4[address(arg1)] = 1
    stor5.length++
    stor5[stor5.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    if arg1 > 1000 * 10^18:
        revert with 0, 'Amount must be less than supply'
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if arg2:
        if not arg1 / 100:
            mem[64] = 224
            mem[160] = 30
            mem[192] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            idx = 0
            s = 1000 * 10^18
            t = stor6
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _628 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_628] = 26
                    mem[_628 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    require arg1
                    if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _800 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_800] = 30
                    mem[_800 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 1000 * 10^18:
                        return (arg1 * stor6 / 1000 * 10^18)
                    _832 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_832 + idx + 68] = mem[_800 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_832 + 68] = mem[_832 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _832 + -mem[64] + 100
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] > s:
                    _642 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_642] = 26
                    mem[_642 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    require arg1
                    if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _835 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_835] = 30
                    mem[_835 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 1000 * 10^18:
                        return (arg1 * stor6 / 1000 * 10^18)
                    _880 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_880 + idx + 68] = mem[_835 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_880 + 68] = mem[_880 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _880 + -mem[64] + 100
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 1
                _638 = mem[64]
                mem[64] = mem[64] + 64
                mem[_638] = 30
                mem[_638 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _648 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_648 + idx + 68] = mem[_638 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_648 + 68] = mem[_648 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _648 + -mem[64] + 100
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 2
                _699 = mem[64]
                mem[64] = mem[64] + 64
                mem[_699] = 30
                mem[_699 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _716 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_716 + idx + 68] = mem[_699 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_716 + 68] = mem[_716 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _716 + -mem[64] + 100
            _598 = mem[64]
            mem[64] = mem[64] + 64
            mem[_598] = 26
            mem[_598 + 32] = 'SafeMath: division by zero'
            if t < stor6 / 1000 * 10^18:
                _660 = mem[64]
                mem[64] = mem[64] + 64
                mem[_660] = 26
                mem[_660 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                require arg1
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (arg1 * stor6 / 1000 * 10^18)
            _659 = mem[64]
            mem[64] = mem[64] + 64
            mem[_659] = 26
            mem[_659 + 32] = 'SafeMath: division by zero'
            if s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require s
            if not arg1:
                return 0
            require arg1
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow'
            return (arg1 * t / s)
        require arg1 / 100
        if arg1 / 100 * reflectFees / arg1 / 100 != reflectFees:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if arg1 / 100 * reflectFees > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _625 = mem[64]
                mem[64] = mem[64] + 64
                mem[_625] = 26
                mem[_625 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 / 100 * reflectFees:
                        return 0
                    require arg1 / 100 * reflectFees
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _798 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_798] = 30
                    mem[_798 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 <= 0:
                        return (-1 * arg1 / 100 * reflectFees * stor6 / 1000 * 10^18)
                    _825 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_825 + idx + 68] = mem[_798 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_825 + 68] = mem[_825 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _825 + -mem[64] + 100
                require arg1
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not arg1 / 100 * reflectFees:
                    _797 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_797] = 30
                    mem[_797 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 1000 * 10^18:
                        return (arg1 * stor6 / 1000 * 10^18)
                    _822 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_822 + idx + 68] = mem[_797 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_822 + 68] = mem[_822 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _822 + -mem[64] + 100
                require arg1 / 100 * reflectFees
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _821 = mem[64]
                mem[64] = mem[64] + 64
                mem[_821] = 30
                mem[_821 + 32] = 'SafeMath: subtraction overflow'
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 <= arg1 * stor6 / 1000 * 10^18:
                    return ((arg1 * stor6 / 1000 * 10^18) - (arg1 / 100 * reflectFees * stor6 / 1000 * 10^18))
                _865 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_865 + idx + 68] = mem[_821 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_865 + 68] = mem[_865 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _865 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _641 = mem[64]
                mem[64] = mem[64] + 64
                mem[_641] = 26
                mem[_641 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 / 100 * reflectFees:
                        return 0
                    require arg1 / 100 * reflectFees
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _829 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_829] = 30
                    mem[_829 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 <= 0:
                        return (-1 * arg1 / 100 * reflectFees * stor6 / 1000 * 10^18)
                    _874 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_874 + idx + 68] = mem[_829 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_874 + 68] = mem[_874 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _874 + -mem[64] + 100
                require arg1
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not arg1 / 100 * reflectFees:
                    _828 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_828] = 30
                    mem[_828 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 1000 * 10^18:
                        return (arg1 * stor6 / 1000 * 10^18)
                    _871 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_871 + idx + 68] = mem[_828 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_871 + 68] = mem[_871 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _871 + -mem[64] + 100
                require arg1 / 100 * reflectFees
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _870 = mem[64]
                mem[64] = mem[64] + 64
                mem[_870] = 30
                mem[_870 + 32] = 'SafeMath: subtraction overflow'
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 <= arg1 * stor6 / 1000 * 10^18:
                    return ((arg1 * stor6 / 1000 * 10^18) - (arg1 / 100 * reflectFees * stor6 / 1000 * 10^18))
                _936 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_936 + idx + 68] = mem[_870 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_936 + 68] = mem[_936 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _936 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 1
            _637 = mem[64]
            mem[64] = mem[64] + 64
            mem[_637] = 30
            mem[_637 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _645 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_645 + idx + 68] = mem[_637 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_645 + 68] = mem[_645 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _645 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            _697 = mem[64]
            mem[64] = mem[64] + 64
            mem[_697] = 30
            mem[_697 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _711 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_711 + idx + 68] = mem[_697 + idx + 32]
                idx = idx + 32
                continue 
            mem[_711 + 68] = mem[_711 + 70 len 30]
            revert with memory
              from mem[64]
               len _711 + -mem[64] + 100
        _593 = mem[64]
        mem[64] = mem[64] + 64
        mem[_593] = 26
        mem[_593 + 32] = 'SafeMath: division by zero'
        if t < stor6 / 1000 * 10^18:
            _658 = mem[64]
            mem[64] = mem[64] + 64
            mem[_658] = 26
            mem[_658 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not arg1 / 100 * reflectFees:
                    return 0
                require arg1 / 100 * reflectFees
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (-1 * arg1 / 100 * reflectFees * stor6 / 1000 * 10^18)
            require arg1
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not arg1 / 100 * reflectFees:
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (arg1 * stor6 / 1000 * 10^18)
            require arg1 / 100 * reflectFees
            if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg1 * stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((arg1 * stor6 / 1000 * 10^18) - (arg1 / 100 * reflectFees * stor6 / 1000 * 10^18))
        _657 = mem[64]
        mem[64] = mem[64] + 64
        mem[_657] = 26
        mem[_657 + 32] = 'SafeMath: division by zero'
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        require s
        if not arg1:
            if not arg1 / 100 * reflectFees:
                return 0
            require arg1 / 100 * reflectFees
            if arg1 / 100 * reflectFees * t / s / arg1 / 100 * reflectFees != t / s:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if arg1 / 100 * reflectFees * t / s > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return (-1 * arg1 / 100 * reflectFees * t / s)
        require arg1
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not arg1 / 100 * reflectFees:
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow'
            return (arg1 * t / s)
        require arg1 / 100 * reflectFees
        if arg1 / 100 * reflectFees * t / s / arg1 / 100 * reflectFees != t / s:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if arg1 / 100 * reflectFees * t / s > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((arg1 * t / s) - (arg1 / 100 * reflectFees * t / s))
    if not arg1 / 100:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _634 = mem[64]
                mem[64] = mem[64] + 64
                mem[_634] = 26
                mem[_634 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                require arg1
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _805 = mem[64]
                mem[64] = mem[64] + 64
                mem[_805] = 30
                mem[_805 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 1000 * 10^18:
                    return (arg1 * stor6 / 1000 * 10^18)
                _849 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_849 + idx + 68] = mem[_805 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_849 + 68] = mem[_849 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _849 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _644 = mem[64]
                mem[64] = mem[64] + 64
                mem[_644] = 26
                mem[_644 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                require arg1
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _852 = mem[64]
                mem[64] = mem[64] + 64
                mem[_852] = 30
                mem[_852 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 1000 * 10^18:
                    return (arg1 * stor6 / 1000 * 10^18)
                _902 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_902 + idx + 68] = mem[_852 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_902 + 68] = mem[_902 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _902 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 1
            _640 = mem[64]
            mem[64] = mem[64] + 64
            mem[_640] = 30
            mem[_640 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _654 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_654 + idx + 68] = mem[_640 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_654 + 68] = mem[_654 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _654 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            _703 = mem[64]
            mem[64] = mem[64] + 64
            mem[_703] = 30
            mem[_703 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _726 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_726 + idx + 68] = mem[_703 + idx + 32]
                idx = idx + 32
                continue 
            mem[_726 + 68] = mem[_726 + 70 len 30]
            revert with memory
              from mem[64]
               len _726 + -mem[64] + 100
        _608 = mem[64]
        mem[64] = mem[64] + 64
        mem[_608] = 26
        mem[_608 + 32] = 'SafeMath: division by zero'
        if t < stor6 / 1000 * 10^18:
            _664 = mem[64]
            mem[64] = mem[64] + 64
            mem[_664] = 26
            mem[_664 + 32] = 'SafeMath: division by zero'
            if not arg1:
                return 0
            require arg1
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 0 > arg1 * stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
            return (arg1 * stor6 / 1000 * 10^18)
        _663 = mem[64]
        mem[64] = mem[64] + 64
        mem[_663] = 26
        mem[_663 + 32] = 'SafeMath: division by zero'
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        require s
        if not arg1:
            return 0
        require arg1
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if 0 > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow'
    else:
        require arg1 / 100
        if arg1 / 100 * reflectFees / arg1 / 100 != reflectFees:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if arg1 / 100 * reflectFees > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _631 = mem[64]
                mem[64] = mem[64] + 64
                mem[_631] = 26
                mem[_631 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 / 100 * reflectFees:
                        return 0
                    require arg1 / 100 * reflectFees
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _803 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_803] = 30
                    mem[_803 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 <= 0:
                        return 0
                    _842 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_842 + idx + 68] = mem[_803 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_842 + 68] = mem[_842 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _842 + -mem[64] + 100
                require arg1
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not arg1 / 100 * reflectFees:
                    _802 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_802] = 30
                    mem[_802 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 1000 * 10^18:
                        return (arg1 * stor6 / 1000 * 10^18)
                    _839 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_839 + idx + 68] = mem[_802 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_839 + 68] = mem[_839 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _839 + -mem[64] + 100
                require arg1 / 100 * reflectFees
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _838 = mem[64]
                mem[64] = mem[64] + 64
                mem[_838] = 30
                mem[_838 + 32] = 'SafeMath: subtraction overflow'
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 <= arg1 * stor6 / 1000 * 10^18:
                    return (arg1 * stor6 / 1000 * 10^18)
                _887 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_887 + idx + 68] = mem[_838 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_887 + 68] = mem[_887 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _887 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _643 = mem[64]
                mem[64] = mem[64] + 64
                mem[_643] = 26
                mem[_643 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 / 100 * reflectFees:
                        return 0
                    require arg1 / 100 * reflectFees
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _846 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_846] = 30
                    mem[_846 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 <= 0:
                        return 0
                    _896 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_896 + idx + 68] = mem[_846 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_896 + 68] = mem[_896 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _896 + -mem[64] + 100
                require arg1
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not arg1 / 100 * reflectFees:
                    _845 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_845] = 30
                    mem[_845 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 1000 * 10^18:
                        return (arg1 * stor6 / 1000 * 10^18)
                    _893 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_893 + idx + 68] = mem[_845 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_893 + 68] = mem[_893 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _893 + -mem[64] + 100
                require arg1 / 100 * reflectFees
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _892 = mem[64]
                mem[64] = mem[64] + 64
                mem[_892] = 30
                mem[_892 + 32] = 'SafeMath: subtraction overflow'
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 <= arg1 * stor6 / 1000 * 10^18:
                    return (arg1 * stor6 / 1000 * 10^18)
                _970 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_970 + idx + 68] = mem[_892 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_970 + 68] = mem[_970 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _970 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 1
            _639 = mem[64]
            mem[64] = mem[64] + 64
            mem[_639] = 30
            mem[_639 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _651 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_651 + idx + 68] = mem[_639 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_651 + 68] = mem[_651 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _651 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            _701 = mem[64]
            mem[64] = mem[64] + 64
            mem[_701] = 30
            mem[_701 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _721 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_721 + idx + 68] = mem[_701 + idx + 32]
                idx = idx + 32
                continue 
            mem[_721 + 68] = mem[_721 + 70 len 30]
            revert with memory
              from mem[64]
               len _721 + -mem[64] + 100
        _603 = mem[64]
        mem[64] = mem[64] + 64
        mem[_603] = 26
        mem[_603 + 32] = 'SafeMath: division by zero'
        if t < stor6 / 1000 * 10^18:
            _662 = mem[64]
            mem[64] = mem[64] + 64
            mem[_662] = 26
            mem[_662 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if arg1 / 100 * reflectFees:
                    require arg1 / 100 * reflectFees
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    else:
                        return 0
                else:
                    return 0
            require arg1
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not arg1 / 100 * reflectFees:
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require arg1 / 100 * reflectFees
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
            return (arg1 * stor6 / 1000 * 10^18)
        _661 = mem[64]
        mem[64] = mem[64] + 64
        mem[_661] = 26
        mem[_661 + 32] = 'SafeMath: division by zero'
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        require s
        if not arg1:
            if arg1 / 100 * reflectFees:
                require arg1 / 100 * reflectFees
                if arg1 / 100 * reflectFees * t / s / arg1 / 100 * reflectFees != t / s:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if arg1 / 100 * reflectFees * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                else:
                    return 0
            else:
                return 0
        require arg1
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not arg1 / 100 * reflectFees:
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow'
        else:
            require arg1 / 100 * reflectFees
            if arg1 / 100 * reflectFees * t / s / arg1 / 100 * reflectFees != t / s:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if arg1 / 100 * reflectFees * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow'
    return (arg1 * t / s)
}

function reflect(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[0] = msg.sender
    mem[32] = 4
    if stor4[address(msg.sender)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    44,
                    0x734578636c75646564206164647265737365732063616e6e6f742063616c6c20746869732066756e6374696f,
                    mem[208 len 20]
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if not arg1 / 100:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _750 = mem[64]
                mem[64] = mem[64] + 64
                mem[_750] = 26
                mem[_750 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    _828 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_828] = 30
                    mem[_828 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 1
                    _896 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_896] = 30
                    mem[_896 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _945 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_945 + idx + 68] = mem[_896 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_945 + 68] = mem[_945 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _945 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _1036 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1036] = 30
                    mem[_1036 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1105 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1105 + idx + 68] = mem[_1036 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1105 + 68] = mem[_1105 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1105 + -mem[64] + 100
                require arg1
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _836 = mem[64]
                mem[64] = mem[64] + 64
                mem[_836] = 30
                mem[_836 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    _857 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_857 + idx + 68] = mem[_836 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_857 + 68] = mem[_857 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _857 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _944 = mem[64]
                mem[64] = mem[64] + 64
                mem[_944] = 30
                mem[_944 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                    _1008 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1008 + idx + 68] = mem[_944 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1008 + 68] = mem[_1008 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1008 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                _1102 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1102] = 30
                mem[_1102 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 <= stor6:
                    stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1186 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1186 + idx + 68] = mem[_1102 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1186 + 68] = mem[_1186 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1186 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 1
                _754 = mem[64]
                mem[64] = mem[64] + 64
                mem[_754] = 30
                mem[_754 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _760 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_760 + idx + 68] = mem[_754 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_760 + 68] = mem[_760 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _760 + -mem[64] + 100
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 2
                _785 = mem[64]
                mem[64] = mem[64] + 64
                mem[_785] = 30
                mem[_785 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _796 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_796 + idx + 68] = mem[_785 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_796 + 68] = mem[_796 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _796 + -mem[64] + 100
            _756 = mem[64]
            mem[64] = mem[64] + 64
            mem[_756] = 26
            mem[_756 + 32] = 'SafeMath: division by zero'
            if not arg1:
                _837 = mem[64]
                mem[64] = mem[64] + 64
                mem[_837] = 30
                mem[_837 + 32] = 'SafeMath: subtraction overflow'
                mem[0] = msg.sender
                mem[32] = 1
                _950 = mem[64]
                mem[64] = mem[64] + 64
                mem[_950] = 30
                mem[_950 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _1014 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1014 + idx + 68] = mem[_950 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1014 + 68] = mem[_1014 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1014 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _1108 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1108] = 30
                mem[_1108 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor6:
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1193 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1193 + idx + 68] = mem[_1108 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1193 + 68] = mem[_1193 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1193 + -mem[64] + 100
            require arg1
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _860 = mem[64]
            mem[64] = mem[64] + 64
            mem[_860] = 30
            mem[_860 + 32] = 'SafeMath: subtraction overflow'
            if 0 > arg1 * stor6 / 1000 * 10^18:
                _886 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_886 + idx + 68] = mem[_860 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_886 + 68] = mem[_886 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _886 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            _1013 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1013] = 30
            mem[_1013 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                _1081 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1081 + idx + 68] = mem[_1013 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1081 + 68] = mem[_1081 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1081 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
            _1190 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1190] = 30
            mem[_1190 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 1000 * 10^18 <= stor6:
                stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _1280 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_1280 + idx + 68] = mem[_1190 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1280 + 68] = mem[_1280 + 70 len 30]
            revert with memory
              from mem[64]
               len _1280 + -mem[64] + 100
        _736 = mem[64]
        mem[64] = mem[64] + 64
        mem[_736] = 26
        mem[_736 + 32] = 'SafeMath: division by zero'
        if t < stor6 / 1000 * 10^18:
            _766 = mem[64]
            mem[64] = mem[64] + 64
            mem[_766] = 26
            mem[_766 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require arg1
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                if arg1 * stor6 / 1000 * 10^18 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor6 += -1 * arg1 * stor6 / 1000 * 10^18
        else:
            _765 = mem[64]
            mem[64] = mem[64] + 64
            mem[_765] = 26
            mem[_765 + 32] = 'SafeMath: division by zero'
            if s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require s
            if not arg1:
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require arg1
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow'
                if arg1 * t / s > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor1[address(msg.sender)] += -1 * arg1 * t / s
                if arg1 * t / s > stor6:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor6 += -1 * arg1 * t / s
    else:
        require arg1 / 100
        if arg1 / 100 * reflectFees / arg1 / 100 != reflectFees:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if arg1 / 100 * reflectFees > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _747 = mem[64]
                mem[64] = mem[64] + 64
                mem[_747] = 26
                mem[_747 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 / 100 * reflectFees:
                        _827 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_827] = 30
                        mem[_827 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 1
                        _893 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_893] = 30
                        mem[_893 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _936 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_936 + idx + 68] = mem[_893 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_936 + 68] = mem[_936 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _936 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _1027 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1027] = 30
                        mem[_1027 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if totalFees + arg1 < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg1
                        _1096 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1096 + idx + 68] = mem[_1027 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1096 + 68] = mem[_1096 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1096 + -mem[64] + 100
                    require arg1 / 100 * reflectFees
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _834 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_834] = 30
                    mem[_834 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                        _850 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_850 + idx + 68] = mem[_834 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_850 + 68] = mem[_850 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _850 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _935 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_935] = 30
                    mem[_935 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _990 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_990 + idx + 68] = mem[_935 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_990 + 68] = mem[_990 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _990 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _1093 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1093] = 30
                    mem[_1093 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1167 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1167 + idx + 68] = mem[_1093 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1167 + 68] = mem[_1167 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1167 + -mem[64] + 100
                require arg1
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not arg1 / 100 * reflectFees:
                    _833 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_833] = 30
                    mem[_833 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor6 / 1000 * 10^18:
                        _847 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_847 + idx + 68] = mem[_833 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_847 + 68] = mem[_847 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _847 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _934 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_934] = 30
                    mem[_934 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                        _987 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_987 + idx + 68] = mem[_934 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_987 + 68] = mem[_987 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _987 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                    _1090 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1090] = 30
                    mem[_1090 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor6 / 1000 * 10^18 <= stor6:
                        stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1164 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1164 + idx + 68] = mem[_1090 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1164 + 68] = mem[_1164 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1164 + -mem[64] + 100
                require arg1 / 100 * reflectFees
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _846 = mem[64]
                mem[64] = mem[64] + 64
                mem[_846] = 30
                mem[_846 + 32] = 'SafeMath: subtraction overflow'
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg1 * stor6 / 1000 * 10^18:
                    _869 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_869 + idx + 68] = mem[_846 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_869 + 68] = mem[_869 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _869 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _986 = mem[64]
                mem[64] = mem[64] + 64
                mem[_986] = 30
                mem[_986 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                    _1053 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1053 + idx + 68] = mem[_986 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1053 + 68] = mem[_1053 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1053 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                _1161 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1161] = 30
                mem[_1161 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 <= stor6:
                    stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1246 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1246 + idx + 68] = mem[_1161 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1246 + 68] = mem[_1246 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1246 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 1
                _753 = mem[64]
                mem[64] = mem[64] + 64
                mem[_753] = 30
                mem[_753 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _757 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_757 + idx + 68] = mem[_753 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_757 + 68] = mem[_757 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _757 + -mem[64] + 100
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 2
                _783 = mem[64]
                mem[64] = mem[64] + 64
                mem[_783] = 30
                mem[_783 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _791 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_791 + idx + 68] = mem[_783 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_791 + 68] = mem[_791 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _791 + -mem[64] + 100
            _755 = mem[64]
            mem[64] = mem[64] + 64
            mem[_755] = 26
            mem[_755 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not arg1 / 100 * reflectFees:
                    _835 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_835] = 30
                    mem[_835 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 1
                    _943 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_943] = 30
                    mem[_943 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _999 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_999 + idx + 68] = mem[_943 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_999 + 68] = mem[_999 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _999 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _1099 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1099] = 30
                    mem[_1099 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1177 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1177 + idx + 68] = mem[_1099 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1177 + 68] = mem[_1177 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1177 + -mem[64] + 100
                require arg1 / 100 * reflectFees
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _854 = mem[64]
                mem[64] = mem[64] + 64
                mem[_854] = 30
                mem[_854 + 32] = 'SafeMath: subtraction overflow'
                if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                    _879 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_879 + idx + 68] = mem[_854 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_879 + 68] = mem[_879 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _879 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _998 = mem[64]
                mem[64] = mem[64] + 64
                mem[_998] = 30
                mem[_998 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _1065 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1065 + idx + 68] = mem[_998 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1065 + 68] = mem[_1065 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1065 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _1174 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1174] = 30
                mem[_1174 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor6:
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1260 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1260 + idx + 68] = mem[_1174 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1260 + 68] = mem[_1260 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1260 + -mem[64] + 100
            require arg1
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not arg1 / 100 * reflectFees:
                _853 = mem[64]
                mem[64] = mem[64] + 64
                mem[_853] = 30
                mem[_853 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    _876 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_876 + idx + 68] = mem[_853 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_876 + 68] = mem[_876 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _876 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _997 = mem[64]
                mem[64] = mem[64] + 64
                mem[_997] = 30
                mem[_997 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                    _1062 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1062 + idx + 68] = mem[_997 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1062 + 68] = mem[_1062 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1062 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                _1171 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1171] = 30
                mem[_1171 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 <= stor6:
                    stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1257 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1257 + idx + 68] = mem[_1171 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1257 + 68] = mem[_1257 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1257 + -mem[64] + 100
            require arg1 / 100 * reflectFees
            if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _875 = mem[64]
            mem[64] = mem[64] + 64
            mem[_875] = 30
            mem[_875 + 32] = 'SafeMath: subtraction overflow'
            if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg1 * stor6 / 1000 * 10^18:
                _916 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_916 + idx + 68] = mem[_875 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_916 + 68] = mem[_916 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _916 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            _1061 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1061] = 30
            mem[_1061 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                _1133 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1133 + idx + 68] = mem[_1061 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1133 + 68] = mem[_1133 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1133 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
            _1254 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1254] = 30
            mem[_1254 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 1000 * 10^18 <= stor6:
                stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _1332 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_1332 + idx + 68] = mem[_1254 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1332 + 68] = mem[_1332 + 70 len 30]
            revert with memory
              from mem[64]
               len _1332 + -mem[64] + 100
        _731 = mem[64]
        mem[64] = mem[64] + 64
        mem[_731] = 26
        mem[_731 + 32] = 'SafeMath: division by zero'
        if t < stor6 / 1000 * 10^18:
            _764 = mem[64]
            mem[64] = mem[64] + 64
            mem[_764] = 26
            mem[_764 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if arg1 / 100 * reflectFees:
                    require arg1 / 100 * reflectFees
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require arg1
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not arg1 / 100 * reflectFees:
                    if 0 > arg1 * stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: subtraction overflow'
                else:
                    require arg1 / 100 * reflectFees
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg1 / 100 * reflectFees != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if arg1 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg1 * stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                if arg1 * stor6 / 1000 * 10^18 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor6 += -1 * arg1 * stor6 / 1000 * 10^18
        else:
            _763 = mem[64]
            mem[64] = mem[64] + 64
            mem[_763] = 26
            mem[_763 + 32] = 'SafeMath: division by zero'
            if s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require s
            if not arg1:
                if arg1 / 100 * reflectFees:
                    require arg1 / 100 * reflectFees
                    if arg1 / 100 * reflectFees * t / s / arg1 / 100 * reflectFees != t / s:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if arg1 / 100 * reflectFees * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require arg1
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not arg1 / 100 * reflectFees:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow'
                else:
                    require arg1 / 100 * reflectFees
                    if arg1 / 100 * reflectFees * t / s / arg1 / 100 * reflectFees != t / s:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if arg1 / 100 * reflectFees * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow'
                if arg1 * t / s > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor1[address(msg.sender)] += -1 * arg1 * t / s
                if arg1 * t / s > stor6:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor6 += -1 * arg1 * t / s
    if totalFees + arg1 < totalFees:
        revert with 0, 'SafeMath: addition overflow'
    totalFees += arg1
}

function transfer(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x6f45524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,
                    mem[201 len 27]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,
                    mem[199 len 29]
    if arg2 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    41,
                    0x655472616e7366657220616d6f756e74206d7573742062652067726561746572207468616e207a6572,
                    mem[205 len 23]
    if not stor4[address(msg.sender)]:
        if stor4[address(msg.sender)]:
            if stor4[address(msg.sender)]:
                mem[0] = msg.sender
                mem[32] = 4
                if not stor4[address(msg.sender)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _32145 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32145] = 26
                                mem[_32145 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _34623 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34623] = 30
                                    mem[_34623 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _36551 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36551] = 30
                                    mem[_36551 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _37890 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_37890 + idx + 68] = mem[_36551 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37890 + 68] = mem[_37890 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37890 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _45344 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_45344] = 30
                                    mem[_45344 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _47755 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_47755 + idx + 68] = mem[_45344 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_47755 + 68] = mem[_47755 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _47755 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34811 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34811] = 30
                                mem[_34811 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _35162 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35162 + idx + 68] = mem[_34811 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35162 + 68] = mem[_35162 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35162 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _37889 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37889] = 30
                                mem[_37889 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _39274 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39274 + idx + 68] = mem[_37889 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39274 + 68] = mem[_39274 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39274 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _47754 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_47754] = 30
                                mem[_47754 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _49938 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_49938 + idx + 68] = mem[_47754 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_49938 + 68] = mem[_49938 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _49938 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _32329 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32329] = 30
                                mem[_32329 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _32455 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_32455 + idx + 68] = mem[_32329 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32455 + 68] = mem[_32455 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _32455 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _33260 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33260] = 30
                                mem[_33260 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _33451 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_33451 + idx + 68] = mem[_33260 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33451 + 68] = mem[_33451 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33451 + -mem[64] + 100
                            _32391 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32391] = 26
                            mem[_32391 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _34812 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34812] = 30
                                mem[_34812 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _37895 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37895] = 30
                                mem[_37895 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _39281 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39281 + idx + 68] = mem[_37895 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39281 + 68] = mem[_39281 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39281 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _47759 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_47759] = 30
                                mem[_47759 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _49943 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_49943 + idx + 68] = mem[_47759 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_49943 + 68] = mem[_49943 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _49943 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _35165 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35165] = 30
                            mem[_35165 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _35821 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_35821 + idx + 68] = mem[_35165 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35821 + 68] = mem[_35821 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35821 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _39280 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39280] = 30
                            mem[_39280 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _41262 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_41262 + idx + 68] = mem[_39280 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_41262 + 68] = mem[_41262 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _41262 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            _49942 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_49942] = 30
                            mem[_49942 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _51863 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_51863 + idx + 68] = mem[_49942 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_51863 + 68] = mem[_51863 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _51863 + -mem[64] + 100
                        _31651 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31651] = 26
                        mem[_31651 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 1000 * 10^18:
                            _32641 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32641] = 26
                            mem[_32641 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                        else:
                            _32640 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32640] = 26
                            mem[_32640 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        require arg2 / 100
                        if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * reflectFees > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _32142 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32142] = 26
                                mem[_32142 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        _34622 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34622] = 30
                                        mem[_34622 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _36548 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36548] = 30
                                        mem[_36548 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _37881 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37881 + idx + 68] = mem[_36548 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37881 + 68] = mem[_37881 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37881 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _45333 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45333] = 30
                                        mem[_45333 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _47740 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_47740 + idx + 68] = mem[_45333 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_47740 + 68] = mem[_47740 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _47740 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34809 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34809] = 30
                                    mem[_34809 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        _35155 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35155 + idx + 68] = mem[_34809 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35155 + 68] = mem[_35155 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35155 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _37880 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37880] = 30
                                    mem[_37880 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _39255 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39255 + idx + 68] = mem[_37880 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39255 + 68] = mem[_39255 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39255 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    _47739 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47739] = 30
                                    mem[_47739 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _49924 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_49924 + idx + 68] = mem[_47739 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_49924 + 68] = mem[_49924 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _49924 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    _34808 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34808] = 30
                                    mem[_34808 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35152 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35152 + idx + 68] = mem[_34808 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35152 + 68] = mem[_35152 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35152 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _37879 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37879] = 30
                                    mem[_37879 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _39252 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39252 + idx + 68] = mem[_37879 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39252 + 68] = mem[_39252 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39252 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _47738 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47738] = 30
                                    mem[_47738 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _49921 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_49921 + idx + 68] = mem[_47738 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_49921 + 68] = mem[_49921 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _49921 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35151 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35151] = 30
                                mem[_35151 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _35804 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35804 + idx + 68] = mem[_35151 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35804 + 68] = mem[_35804 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35804 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _39251 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39251] = 30
                                mem[_39251 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _41226 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_41226 + idx + 68] = mem[_39251 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41226 + 68] = mem[_41226 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41226 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                _49920 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_49920] = 30
                                mem[_49920 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _51835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_51835 + idx + 68] = mem[_49920 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_51835 + 68] = mem[_51835 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _51835 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _32328 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32328] = 30
                                mem[_32328 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _32452 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_32452 + idx + 68] = mem[_32328 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32452 + 68] = mem[_32452 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _32452 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _33258 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33258] = 30
                                mem[_33258 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _33446 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_33446 + idx + 68] = mem[_33258 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33446 + 68] = mem[_33446 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33446 + -mem[64] + 100
                            _32390 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32390] = 26
                            mem[_32390 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100 * reflectFees:
                                    _34810 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34810] = 30
                                    mem[_34810 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _37888 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37888] = 30
                                    mem[_37888 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _39265 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39265 + idx + 68] = mem[_37888 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39265 + 68] = mem[_39265 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39265 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _47747 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47747] = 30
                                    mem[_47747 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _49931 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_49931 + idx + 68] = mem[_47747 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_49931 + 68] = mem[_49931 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _49931 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35159] = 30
                                mem[_35159 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                    _35814 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35814 + idx + 68] = mem[_35159 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35814 + 68] = mem[_35814 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35814 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _39264 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39264] = 30
                                mem[_39264 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _41242 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_41242 + idx + 68] = mem[_39264 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41242 + 68] = mem[_41242 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41242 + -mem[64] + 100
                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                _49930 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_49930] = 30
                                mem[_49930 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _51847 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_51847 + idx + 68] = mem[_49930 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_51847 + 68] = mem[_51847 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _51847 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100 * reflectFees:
                                _35158 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35158] = 30
                                mem[_35158 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _35811 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35811 + idx + 68] = mem[_35158 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35811 + 68] = mem[_35811 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35811 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _39263 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39263] = 30
                                mem[_39263 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _41239 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_41239 + idx + 68] = mem[_39263 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41239 + 68] = mem[_41239 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41239 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _49929 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_49929] = 30
                                mem[_49929 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _51844 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_51844 + idx + 68] = mem[_49929 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_51844 + 68] = mem[_51844 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _51844 + -mem[64] + 100
                            require arg2 / 100 * reflectFees
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _35810 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35810] = 30
                            mem[_35810 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                _36811 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_36811 + idx + 68] = mem[_35810 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36811 + 68] = mem[_36811 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36811 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _41238 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_41238] = 30
                            mem[_41238 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _43522 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_43522 + idx + 68] = mem[_41238 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43522 + 68] = mem[_43522 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43522 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                            _51843 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_51843] = 30
                            mem[_51843 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                return 1
                            _53856 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_53856 + idx + 68] = mem[_51843 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_53856 + 68] = mem[_53856 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _53856 + -mem[64] + 100
                        _31646 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31646] = 26
                        mem[_31646 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 1000 * 10^18:
                            _32639 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32639] = 26
                            mem[_32639 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100 * reflectFees:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            else:
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                        else:
                            _32638 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32638] = 26
                            mem[_32638 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not arg2 / 100 * reflectFees:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                    if arg2 / 100 * reflectFees * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                    if arg2 / 100 * reflectFees * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * t / s
                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg2 / 100 * reflectFees
                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not stor4[address(arg1)]:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32151 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32151] = 26
                                    mem[_32151 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34625 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34625] = 30
                                        mem[_34625 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _36559 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36559] = 30
                                        mem[_36559 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _37909 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37909 + idx + 68] = mem[_36559 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37909 + 68] = mem[_37909 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37909 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _45367 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45367] = 30
                                        mem[_45367 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _47788 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_47788 + idx + 68] = mem[_45367 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_47788 + 68] = mem[_47788 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _47788 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34816 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34816] = 30
                                    mem[_34816 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35179 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35179 + idx + 68] = mem[_34816 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35179 + 68] = mem[_35179 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35179 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _37908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37908] = 30
                                    mem[_37908 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _39317 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39317 + idx + 68] = mem[_37908 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39317 + 68] = mem[_39317 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39317 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _47787 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47787] = 30
                                    mem[_47787 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _49974 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_49974 + idx + 68] = mem[_47787 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_49974 + 68] = mem[_49974 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _49974 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32331 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32331] = 30
                                    mem[_32331 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32461 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32461 + idx + 68] = mem[_32331 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32461 + 68] = mem[_32461 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32461 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33264 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33264] = 30
                                    mem[_33264 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33461 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33461 + idx + 68] = mem[_33264 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33461 + 68] = mem[_33461 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33461 + -mem[64] + 100
                                _32393 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32393] = 26
                                mem[_32393 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _34817 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34817] = 30
                                    mem[_34817 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _37914 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37914] = 30
                                    mem[_37914 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _39324 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39324 + idx + 68] = mem[_37914 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39324 + 68] = mem[_39324 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39324 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _47792 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47792] = 30
                                    mem[_47792 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _49979 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_49979 + idx + 68] = mem[_47792 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_49979 + 68] = mem[_49979 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _49979 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35182 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35182] = 30
                                mem[_35182 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _35845 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35845 + idx + 68] = mem[_35182 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35845 + 68] = mem[_35845 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35845 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _39323 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39323] = 30
                                mem[_39323 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _41318 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_41318 + idx + 68] = mem[_39323 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41318 + 68] = mem[_41318 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41318 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _49978 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_49978] = 30
                                mem[_49978 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _51907 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_51907 + idx + 68] = mem[_49978 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_51907 + 68] = mem[_51907 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _51907 + -mem[64] + 100
                            _31661 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31661] = 26
                            mem[_31661 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32645 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32645] = 26
                                mem[_32645 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            else:
                                _32644 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32644] = 26
                                mem[_32644 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32148 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32148] = 26
                                    mem[_32148 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34624 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34624] = 30
                                            mem[_34624 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36556 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36556] = 30
                                            mem[_36556 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _37900 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_37900 + idx + 68] = mem[_36556 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37900 + 68] = mem[_37900 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37900 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45356 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45356] = 30
                                            mem[_45356 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _47773 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_47773 + idx + 68] = mem[_45356 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47773 + 68] = mem[_47773 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47773 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34814 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34814] = 30
                                        mem[_34814 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _35172 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35172 + idx + 68] = mem[_34814 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35172 + 68] = mem[_35172 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35172 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _37899 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37899] = 30
                                        mem[_37899 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39298 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39298 + idx + 68] = mem[_37899 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39298 + 68] = mem[_39298 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39298 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _47772 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47772] = 30
                                        mem[_47772 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _49960 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_49960 + idx + 68] = mem[_47772 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_49960 + 68] = mem[_49960 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _49960 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _34813 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34813] = 30
                                        mem[_34813 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35169 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35169 + idx + 68] = mem[_34813 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35169 + 68] = mem[_35169 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35169 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _37898 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37898] = 30
                                        mem[_37898 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _39295 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39295 + idx + 68] = mem[_37898 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39295 + 68] = mem[_39295 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39295 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _47771 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47771] = 30
                                        mem[_47771 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _49957 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_49957 + idx + 68] = mem[_47771 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_49957 + 68] = mem[_49957 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _49957 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35168 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35168] = 30
                                    mem[_35168 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _35828 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35828 + idx + 68] = mem[_35168 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35828 + 68] = mem[_35828 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35828 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39294 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39294] = 30
                                    mem[_39294 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _41282 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41282 + idx + 68] = mem[_39294 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41282 + 68] = mem[_41282 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41282 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _49956 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49956] = 30
                                    mem[_49956 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _51879 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_51879 + idx + 68] = mem[_49956 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51879 + 68] = mem[_51879 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51879 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32330 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32330] = 30
                                    mem[_32330 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32458 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32458 + idx + 68] = mem[_32330 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32458 + 68] = mem[_32458 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32458 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33262 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33262] = 30
                                    mem[_33262 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33456 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33456 + idx + 68] = mem[_33262 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33456 + 68] = mem[_33456 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33456 + -mem[64] + 100
                                _32392 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32392] = 26
                                mem[_32392 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        _34815 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34815] = 30
                                        mem[_34815 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _37907 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37907] = 30
                                        mem[_37907 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39308 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39308 + idx + 68] = mem[_37907 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39308 + 68] = mem[_39308 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39308 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _47780 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47780] = 30
                                        mem[_47780 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _49967 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_49967 + idx + 68] = mem[_47780 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_49967 + 68] = mem[_49967 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _49967 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35176 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35176] = 30
                                    mem[_35176 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        _35838 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35838 + idx + 68] = mem[_35176 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35838 + 68] = mem[_35838 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35838 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39307] = 30
                                    mem[_39307 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _41298 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41298 + idx + 68] = mem[_39307 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41298 + 68] = mem[_41298 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41298 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    _49966 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49966] = 30
                                    mem[_49966 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _51891 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_51891 + idx + 68] = mem[_49966 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51891 + 68] = mem[_51891 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51891 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    _35175 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35175] = 30
                                    mem[_35175 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35835 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35835 + idx + 68] = mem[_35175 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35835 + 68] = mem[_35835 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35835 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39306 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39306] = 30
                                    mem[_39306 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _41295 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41295 + idx + 68] = mem[_39306 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41295 + 68] = mem[_41295 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41295 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _49965 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49965] = 30
                                    mem[_49965 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _51888 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_51888 + idx + 68] = mem[_49965 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51888 + 68] = mem[_51888 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51888 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35834 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35834] = 30
                                mem[_35834 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _36846 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36846 + idx + 68] = mem[_35834 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36846 + 68] = mem[_36846 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36846 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _41294 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41294] = 30
                                mem[_41294 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _43584 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_43584 + idx + 68] = mem[_41294 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43584 + 68] = mem[_43584 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43584 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                _51887 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51887] = 30
                                mem[_51887 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _53906 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_53906 + idx + 68] = mem[_51887 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53906 + 68] = mem[_53906 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53906 + -mem[64] + 100
                            _31656 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31656] = 26
                            mem[_31656 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32643 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32643] = 26
                                mem[_32643 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            else:
                                _32642 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32642] = 26
                                mem[_32642 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100 * reflectFees
                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                    else:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32157 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32157] = 26
                                    mem[_32157 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34627 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34627] = 30
                                        mem[_34627 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _36567 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36567] = 30
                                        mem[_36567 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _37928 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37928 + idx + 68] = mem[_36567 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37928 + 68] = mem[_37928 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37928 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40633 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40633] = 30
                                        mem[_40633 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _42963 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42963 + idx + 68] = mem[_40633 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42963 + 68] = mem[_42963 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42963 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _53963 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_53963] = 30
                                        mem[_53963 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _55976 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_55976 + idx + 68] = mem[_53963 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_55976 + 68] = mem[_55976 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _55976 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34821 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34821] = 30
                                    mem[_34821 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35196 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35196 + idx + 68] = mem[_34821 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35196 + 68] = mem[_35196 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35196 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _37927 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37927] = 30
                                    mem[_37927 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _39360 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39360 + idx + 68] = mem[_37927 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39360 + 68] = mem[_39360 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39360 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _42960 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42960] = 30
                                    mem[_42960 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _45404 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_45404 + idx + 68] = mem[_42960 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45404 + 68] = mem[_45404 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45404 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _55975 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_55975] = 30
                                    mem[_55975 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _57702 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_57702 + idx + 68] = mem[_55975 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_57702 + 68] = mem[_57702 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _57702 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32333 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32333] = 30
                                    mem[_32333 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32467 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32467 + idx + 68] = mem[_32333 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32467 + 68] = mem[_32467 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32467 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33268 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33268] = 30
                                    mem[_33268 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33471 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33471 + idx + 68] = mem[_33268 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33471 + 68] = mem[_33471 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33471 + -mem[64] + 100
                                _32395 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32395] = 26
                                mem[_32395 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _34822 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34822] = 30
                                    mem[_34822 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _37933 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37933] = 30
                                    mem[_37933 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _39367 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39367 + idx + 68] = mem[_37933 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39367 + 68] = mem[_39367 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39367 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _42966 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42966] = 30
                                    mem[_42966 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _45413 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_45413 + idx + 68] = mem[_42966 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45413 + 68] = mem[_45413 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45413 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _55980 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_55980] = 30
                                    mem[_55980 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _57707 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_57707 + idx + 68] = mem[_55980 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_57707 + 68] = mem[_57707 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _57707 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35199 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35199] = 30
                                mem[_35199 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _35869 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35869 + idx + 68] = mem[_35199 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35869 + 68] = mem[_35869 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35869 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 2
                                _39366 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39366] = 30
                                mem[_39366 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _41370 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_41370 + idx + 68] = mem[_39366 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41370 + 68] = mem[_41370 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41370 + -mem[64] + 100
                                stor2[address(msg.sender)] -= arg2
                                mem[0] = msg.sender
                                mem[32] = 1
                                _45410 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_45410] = 30
                                mem[_45410 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _47853 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_47853 + idx + 68] = mem[_45410 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_47853 + 68] = mem[_47853 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _47853 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _57706 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_57706] = 30
                                mem[_57706 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _59046 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_59046 + idx + 68] = mem[_57706 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_59046 + 68] = mem[_59046 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _59046 + -mem[64] + 100
                            _31671 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31671] = 26
                            mem[_31671 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32649 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32649] = 26
                                mem[_32649 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            else:
                                _32648 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32648] = 26
                                mem[_32648 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor2[address(msg.sender)] -= arg2
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32154 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32154] = 26
                                    mem[_32154 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34626 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34626] = 30
                                            mem[_34626 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _36564 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36564] = 30
                                            mem[_36564 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _37919 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_37919 + idx + 68] = mem[_36564 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37919 + 68] = mem[_37919 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37919 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40624 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40624] = 30
                                            mem[_40624 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _42954 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42954 + idx + 68] = mem[_40624 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42954 + 68] = mem[_42954 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42954 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _53951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_53951] = 30
                                            mem[_53951 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _55967 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_55967 + idx + 68] = mem[_53951 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_55967 + 68] = mem[_55967 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _55967 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34819 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34819] = 30
                                        mem[_34819 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _35189 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35189 + idx + 68] = mem[_34819 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35189 + 68] = mem[_35189 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35189 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _37918 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37918] = 30
                                        mem[_37918 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _39341 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39341 + idx + 68] = mem[_37918 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39341 + 68] = mem[_39341 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39341 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _42951 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42951] = 30
                                        mem[_42951 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _45383 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_45383 + idx + 68] = mem[_42951 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45383 + 68] = mem[_45383 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45383 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _55966 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_55966] = 30
                                        mem[_55966 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _57688 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_57688 + idx + 68] = mem[_55966 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_57688 + 68] = mem[_57688 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _57688 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _34818 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34818] = 30
                                        mem[_34818 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35186 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35186 + idx + 68] = mem[_34818 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35186 + 68] = mem[_35186 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35186 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _37917 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37917] = 30
                                        mem[_37917 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _39338 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39338 + idx + 68] = mem[_37917 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39338 + 68] = mem[_39338 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39338 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _42948 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42948] = 30
                                        mem[_42948 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _45380 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_45380 + idx + 68] = mem[_42948 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45380 + 68] = mem[_45380 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45380 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _55965 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_55965] = 30
                                        mem[_55965 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _57685 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_57685 + idx + 68] = mem[_55965 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_57685 + 68] = mem[_57685 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _57685 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35185 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35185] = 30
                                    mem[_35185 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _35852 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35852 + idx + 68] = mem[_35185 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35852 + 68] = mem[_35852 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35852 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _39337 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39337] = 30
                                    mem[_39337 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _41338 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41338 + idx + 68] = mem[_39337 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41338 + 68] = mem[_41338 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41338 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _45377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_45377] = 30
                                    mem[_45377 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _47811 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_47811 + idx + 68] = mem[_45377 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_47811 + 68] = mem[_47811 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _47811 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _57684 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_57684] = 30
                                    mem[_57684 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _59018 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_59018 + idx + 68] = mem[_57684 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59018 + 68] = mem[_59018 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59018 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32332 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32332] = 30
                                    mem[_32332 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32464 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32464 + idx + 68] = mem[_32332 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32464 + 68] = mem[_32464 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32464 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33266 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33266] = 30
                                    mem[_33266 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33466 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33466 + idx + 68] = mem[_33266 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33466 + 68] = mem[_33466 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33466 + -mem[64] + 100
                                _32394 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32394] = 26
                                mem[_32394 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        _34820 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34820] = 30
                                        mem[_34820 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _37926 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37926] = 30
                                        mem[_37926 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _39351 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39351 + idx + 68] = mem[_37926 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39351 + 68] = mem[_39351 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39351 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _42957 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42957] = 30
                                        mem[_42957 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _45395 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_45395 + idx + 68] = mem[_42957 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45395 + 68] = mem[_45395 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45395 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _55972 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_55972] = 30
                                        mem[_55972 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _57695 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_57695 + idx + 68] = mem[_55972 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_57695 + 68] = mem[_57695 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _57695 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35193 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35193] = 30
                                    mem[_35193 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        _35862 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35862 + idx + 68] = mem[_35193 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35862 + 68] = mem[_35862 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35862 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _39350 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39350] = 30
                                    mem[_39350 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _41352 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41352 + idx + 68] = mem[_39350 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41352 + 68] = mem[_41352 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41352 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _45392 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_45392] = 30
                                    mem[_45392 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _47829 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_47829 + idx + 68] = mem[_45392 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_47829 + 68] = mem[_47829 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _47829 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    _57694 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_57694] = 30
                                    mem[_57694 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _59030 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_59030 + idx + 68] = mem[_57694 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59030 + 68] = mem[_59030 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59030 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    _35192 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35192] = 30
                                    mem[_35192 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35859 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35859 + idx + 68] = mem[_35192 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35859 + 68] = mem[_35859 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35859 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _39349 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39349] = 30
                                    mem[_39349 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _41349 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41349 + idx + 68] = mem[_39349 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41349 + 68] = mem[_41349 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41349 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _45389 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_45389] = 30
                                    mem[_45389 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _47826 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_47826 + idx + 68] = mem[_45389 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_47826 + 68] = mem[_47826 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _47826 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _57693 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_57693] = 30
                                    mem[_57693 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _59027 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_59027 + idx + 68] = mem[_57693 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59027 + 68] = mem[_59027 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59027 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35858 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35858] = 30
                                mem[_35858 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _36881 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36881 + idx + 68] = mem[_35858 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36881 + 68] = mem[_36881 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36881 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 2
                                _41348 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41348] = 30
                                mem[_41348 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _43642 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_43642 + idx + 68] = mem[_41348 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43642 + 68] = mem[_43642 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43642 + -mem[64] + 100
                                stor2[address(msg.sender)] -= arg2
                                mem[0] = msg.sender
                                mem[32] = 1
                                _47823 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_47823] = 30
                                mem[_47823 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _50015 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50015 + idx + 68] = mem[_47823 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50015 + 68] = mem[_50015 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50015 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                _59026 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_59026] = 30
                                mem[_59026 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _60080 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_60080 + idx + 68] = mem[_59026 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_60080 + 68] = mem[_60080 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _60080 + -mem[64] + 100
                            _31666 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31666] = 26
                            mem[_31666 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32647 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32647] = 26
                                mem[_32647 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            else:
                                _32646 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32646] = 26
                                mem[_32646 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100 * reflectFees
                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 4
                if not stor4[address(arg1)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _32181 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32181] = 26
                                mem[_32181 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _34635 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34635] = 30
                                    mem[_34635 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _36599 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36599] = 30
                                    mem[_36599 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _38004 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38004 + idx + 68] = mem[_36599 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38004 + 68] = mem[_38004 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38004 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _45526 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_45526] = 30
                                    mem[_45526 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _48019 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_48019 + idx + 68] = mem[_45526 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_48019 + 68] = mem[_48019 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _48019 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34841 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34841] = 30
                                mem[_34841 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _35264 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35264 + idx + 68] = mem[_34841 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35264 + 68] = mem[_35264 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35264 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _38003 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38003] = 30
                                mem[_38003 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _39532 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39532 + idx + 68] = mem[_38003 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39532 + 68] = mem[_39532 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39532 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _48018 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_48018] = 30
                                mem[_48018 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _50214 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_50214 + idx + 68] = mem[_48018 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_50214 + 68] = mem[_50214 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _50214 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _32341 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32341] = 30
                                mem[_32341 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _32491 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_32491 + idx + 68] = mem[_32341 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32491 + 68] = mem[_32491 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _32491 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _33284 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33284] = 30
                                mem[_33284 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _33511 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_33511 + idx + 68] = mem[_33284 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33511 + 68] = mem[_33511 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33511 + -mem[64] + 100
                            _32403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32403] = 26
                            mem[_32403 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _34842 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34842] = 30
                                mem[_34842 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _38009 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38009] = 30
                                mem[_38009 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _39539 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39539 + idx + 68] = mem[_38009 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39539 + 68] = mem[_39539 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39539 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _48023 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_48023] = 30
                                mem[_48023 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _50219 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_50219 + idx + 68] = mem[_48023 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_50219 + 68] = mem[_50219 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _50219 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _35267 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35267] = 30
                            mem[_35267 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _35965 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_35965 + idx + 68] = mem[_35267 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35965 + 68] = mem[_35965 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35965 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _39538 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39538] = 30
                            mem[_39538 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _41590 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_41590 + idx + 68] = mem[_39538 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_41590 + 68] = mem[_41590 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _41590 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            _50218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_50218] = 30
                            mem[_50218 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _52145 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_52145 + idx + 68] = mem[_50218 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_52145 + 68] = mem[_52145 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _52145 + -mem[64] + 100
                        _31711 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31711] = 26
                        mem[_31711 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 1000 * 10^18:
                            _32665 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32665] = 26
                            mem[_32665 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                        else:
                            _32664 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32664] = 26
                            mem[_32664 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        require arg2 / 100
                        if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * reflectFees > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _32178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32178] = 26
                                mem[_32178 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        _34634 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34634] = 30
                                        mem[_34634 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _36596 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36596] = 30
                                        mem[_36596 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _37995 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37995 + idx + 68] = mem[_36596 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37995 + 68] = mem[_37995 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37995 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _45515 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45515] = 30
                                        mem[_45515 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _48004 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_48004 + idx + 68] = mem[_45515 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_48004 + 68] = mem[_48004 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _48004 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34839 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34839] = 30
                                    mem[_34839 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        _35257 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35257 + idx + 68] = mem[_34839 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35257 + 68] = mem[_35257 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35257 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _37994 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37994] = 30
                                    mem[_37994 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _39513 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39513 + idx + 68] = mem[_37994 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39513 + 68] = mem[_39513 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39513 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    _48003 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48003] = 30
                                    mem[_48003 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _50200 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50200 + idx + 68] = mem[_48003 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50200 + 68] = mem[_50200 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50200 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    _34838 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34838] = 30
                                    mem[_34838 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35254 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35254 + idx + 68] = mem[_34838 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35254 + 68] = mem[_35254 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35254 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _37993 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37993] = 30
                                    mem[_37993 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _39510 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39510 + idx + 68] = mem[_37993 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39510 + 68] = mem[_39510 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39510 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _48002 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48002] = 30
                                    mem[_48002 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _50197 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50197 + idx + 68] = mem[_48002 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50197 + 68] = mem[_50197 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50197 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35253 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35253] = 30
                                mem[_35253 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _35948 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35948 + idx + 68] = mem[_35253 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35948 + 68] = mem[_35948 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35948 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _39509 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39509] = 30
                                mem[_39509 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _41554 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_41554 + idx + 68] = mem[_39509 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41554 + 68] = mem[_41554 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41554 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                _50196 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50196] = 30
                                mem[_50196 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _52117 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_52117 + idx + 68] = mem[_50196 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52117 + 68] = mem[_52117 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52117 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _32340 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32340] = 30
                                mem[_32340 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _32488 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_32488 + idx + 68] = mem[_32340 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32488 + 68] = mem[_32488 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _32488 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _33282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33282] = 30
                                mem[_33282 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _33506 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_33506 + idx + 68] = mem[_33282 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33506 + 68] = mem[_33506 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33506 + -mem[64] + 100
                            _32402 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32402] = 26
                            mem[_32402 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100 * reflectFees:
                                    _34840 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34840] = 30
                                    mem[_34840 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38002 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38002] = 30
                                    mem[_38002 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _39523 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39523 + idx + 68] = mem[_38002 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39523 + 68] = mem[_39523 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39523 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _48011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48011] = 30
                                    mem[_48011 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _50207 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50207 + idx + 68] = mem[_48011 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50207 + 68] = mem[_50207 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50207 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35261 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35261] = 30
                                mem[_35261 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                    _35958 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35958 + idx + 68] = mem[_35261 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35958 + 68] = mem[_35958 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35958 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _39522 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39522] = 30
                                mem[_39522 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _41570 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_41570 + idx + 68] = mem[_39522 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41570 + 68] = mem[_41570 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41570 + -mem[64] + 100
                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                _50206 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50206] = 30
                                mem[_50206 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _52129 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_52129 + idx + 68] = mem[_50206 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52129 + 68] = mem[_52129 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52129 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100 * reflectFees:
                                _35260 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35260] = 30
                                mem[_35260 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _35955 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35955 + idx + 68] = mem[_35260 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35955 + 68] = mem[_35955 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35955 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _39521 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39521] = 30
                                mem[_39521 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _41567 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_41567 + idx + 68] = mem[_39521 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41567 + 68] = mem[_41567 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41567 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _50205 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50205] = 30
                                mem[_50205 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _52126 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_52126 + idx + 68] = mem[_50205 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52126 + 68] = mem[_52126 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52126 + -mem[64] + 100
                            require arg2 / 100 * reflectFees
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _35954 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35954] = 30
                            mem[_35954 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                _37021 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_37021 + idx + 68] = mem[_35954 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_37021 + 68] = mem[_37021 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _37021 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _41566 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_41566] = 30
                            mem[_41566 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _43874 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_43874 + idx + 68] = mem[_41566 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43874 + 68] = mem[_43874 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43874 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                            _52125 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_52125] = 30
                            mem[_52125 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                return 1
                            _54124 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_54124 + idx + 68] = mem[_52125 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_54124 + 68] = mem[_54124 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _54124 + -mem[64] + 100
                        _31706 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31706] = 26
                        mem[_31706 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 1000 * 10^18:
                            _32663 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32663] = 26
                            mem[_32663 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100 * reflectFees:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            else:
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                        else:
                            _32662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32662] = 26
                            mem[_32662 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not arg2 / 100 * reflectFees:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                    if arg2 / 100 * reflectFees * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                    if arg2 / 100 * reflectFees * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * t / s
                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg2 / 100 * reflectFees
                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                else:
                    mem[0] = msg.sender
                    mem[32] = 4
                    if not stor4[address(msg.sender)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32163 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32163] = 26
                                    mem[_32163 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34629 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34629] = 30
                                        mem[_34629 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _36575 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36575] = 30
                                        mem[_36575 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _37947 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37947 + idx + 68] = mem[_36575 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37947 + 68] = mem[_37947 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37947 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _45435 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45435] = 30
                                        mem[_45435 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _47887 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_47887 + idx + 68] = mem[_45435 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_47887 + 68] = mem[_47887 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _47887 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34826 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34826] = 30
                                    mem[_34826 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35213 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35213 + idx + 68] = mem[_34826 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35213 + 68] = mem[_35213 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35213 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _37946 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37946] = 30
                                    mem[_37946 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _39403 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39403 + idx + 68] = mem[_37946 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39403 + 68] = mem[_39403 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39403 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _47886 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47886] = 30
                                    mem[_47886 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50076 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50076 + idx + 68] = mem[_47886 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50076 + 68] = mem[_50076 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50076 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32335 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32335] = 30
                                    mem[_32335 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32473 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32473 + idx + 68] = mem[_32335 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32473 + 68] = mem[_32473 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32473 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33272 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33272] = 30
                                    mem[_33272 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33481 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33481 + idx + 68] = mem[_33272 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33481 + 68] = mem[_33481 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33481 + -mem[64] + 100
                                _32397 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32397] = 26
                                mem[_32397 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _34827 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34827] = 30
                                    mem[_34827 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _37952 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37952] = 30
                                    mem[_37952 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _39410 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39410 + idx + 68] = mem[_37952 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39410 + 68] = mem[_39410 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39410 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _47891 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47891] = 30
                                    mem[_47891 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50081 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50081 + idx + 68] = mem[_47891 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50081 + 68] = mem[_50081 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50081 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35216 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35216] = 30
                                mem[_35216 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _35893 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35893 + idx + 68] = mem[_35216 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35893 + 68] = mem[_35893 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35893 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _39409 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39409] = 30
                                mem[_39409 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _41426 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_41426 + idx + 68] = mem[_39409 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41426 + 68] = mem[_41426 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41426 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _50080 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50080] = 30
                                mem[_50080 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _52004 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_52004 + idx + 68] = mem[_50080 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52004 + 68] = mem[_52004 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52004 + -mem[64] + 100
                            _31681 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31681] = 26
                            mem[_31681 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32653 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32653] = 26
                                mem[_32653 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            else:
                                _32652 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32652] = 26
                                mem[_32652 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32160 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32160] = 26
                                    mem[_32160 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34628 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34628] = 30
                                            mem[_34628 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36572 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36572] = 30
                                            mem[_36572 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _37938 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_37938 + idx + 68] = mem[_36572 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37938 + 68] = mem[_37938 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37938 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45424 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45424] = 30
                                            mem[_45424 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _47872 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_47872 + idx + 68] = mem[_45424 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47872 + 68] = mem[_47872 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47872 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34824 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34824] = 30
                                        mem[_34824 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _35206 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35206 + idx + 68] = mem[_34824 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35206 + 68] = mem[_35206 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35206 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _37937 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37937] = 30
                                        mem[_37937 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39384 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39384 + idx + 68] = mem[_37937 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39384 + 68] = mem[_39384 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39384 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _47871 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47871] = 30
                                        mem[_47871 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50062 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50062 + idx + 68] = mem[_47871 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50062 + 68] = mem[_50062 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50062 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _34823 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34823] = 30
                                        mem[_34823 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35203 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35203 + idx + 68] = mem[_34823 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35203 + 68] = mem[_35203 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35203 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _37936 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37936] = 30
                                        mem[_37936 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _39381 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39381 + idx + 68] = mem[_37936 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39381 + 68] = mem[_39381 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39381 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _47870 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47870] = 30
                                        mem[_47870 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50059 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50059 + idx + 68] = mem[_47870 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50059 + 68] = mem[_50059 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50059 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35202 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35202] = 30
                                    mem[_35202 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _35876 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35876 + idx + 68] = mem[_35202 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35876 + 68] = mem[_35876 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35876 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39380 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39380] = 30
                                    mem[_39380 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _41390 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41390 + idx + 68] = mem[_39380 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41390 + 68] = mem[_41390 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41390 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _50058 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50058] = 30
                                    mem[_50058 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _51976 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_51976 + idx + 68] = mem[_50058 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51976 + 68] = mem[_51976 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51976 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32334 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32334] = 30
                                    mem[_32334 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32470 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32470 + idx + 68] = mem[_32334 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32470 + 68] = mem[_32470 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32470 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33270 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33270] = 30
                                    mem[_33270 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33476 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33476 + idx + 68] = mem[_33270 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33476 + 68] = mem[_33476 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33476 + -mem[64] + 100
                                _32396 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32396] = 26
                                mem[_32396 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        _34825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34825] = 30
                                        mem[_34825 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _37945 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37945] = 30
                                        mem[_37945 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39394 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39394 + idx + 68] = mem[_37945 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39394 + 68] = mem[_39394 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39394 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _47879 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47879] = 30
                                        mem[_47879 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50069 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50069 + idx + 68] = mem[_47879 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50069 + 68] = mem[_50069 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50069 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35210 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35210] = 30
                                    mem[_35210 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        _35886 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35886 + idx + 68] = mem[_35210 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35886 + 68] = mem[_35886 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35886 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39393 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39393] = 30
                                    mem[_39393 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _41406 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41406 + idx + 68] = mem[_39393 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41406 + 68] = mem[_41406 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41406 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    _50068 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50068] = 30
                                    mem[_50068 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _51988 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_51988 + idx + 68] = mem[_50068 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51988 + 68] = mem[_51988 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51988 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    _35209 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35209] = 30
                                    mem[_35209 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35883 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35883 + idx + 68] = mem[_35209 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35883 + 68] = mem[_35883 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35883 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39392 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39392] = 30
                                    mem[_39392 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _41403 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41403 + idx + 68] = mem[_39392 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41403 + 68] = mem[_41403 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41403 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _50067 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50067] = 30
                                    mem[_50067 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _51985 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_51985 + idx + 68] = mem[_50067 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51985 + 68] = mem[_51985 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51985 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35882 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35882] = 30
                                mem[_35882 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _36916 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36916 + idx + 68] = mem[_35882 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36916 + 68] = mem[_36916 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36916 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _41402 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41402] = 30
                                mem[_41402 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _43698 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_43698 + idx + 68] = mem[_41402 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43698 + 68] = mem[_43698 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43698 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                _51984 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51984] = 30
                                mem[_51984 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _53990 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_53990 + idx + 68] = mem[_51984 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53990 + 68] = mem[_53990 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53990 + -mem[64] + 100
                            _31676 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31676] = 26
                            mem[_31676 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32651 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32651] = 26
                                mem[_32651 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            else:
                                _32650 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32650] = 26
                                mem[_32650 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100 * reflectFees
                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not stor4[address(arg1)]:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32169 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32169] = 26
                                        mem[_32169 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34631 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34631] = 30
                                            mem[_34631 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36583 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36583] = 30
                                            mem[_36583 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _37966 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_37966 + idx + 68] = mem[_36583 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37966 + 68] = mem[_37966 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37966 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45458 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45458] = 30
                                            mem[_45458 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _47920 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_47920 + idx + 68] = mem[_45458 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47920 + 68] = mem[_47920 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47920 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34831 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34831] = 30
                                        mem[_34831 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35230 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35230 + idx + 68] = mem[_34831 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35230 + 68] = mem[_35230 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35230 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _37965 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37965] = 30
                                        mem[_37965 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _39446 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39446 + idx + 68] = mem[_37965 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39446 + 68] = mem[_39446 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39446 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _47919 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47919] = 30
                                        mem[_47919 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50112 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50112 + idx + 68] = mem[_47919 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50112 + 68] = mem[_50112 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50112 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32337 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32337] = 30
                                        mem[_32337 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32479 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32479 + idx + 68] = mem[_32337 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32479 + 68] = mem[_32479 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32479 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33276 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33276] = 30
                                        mem[_33276 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33491 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33491 + idx + 68] = mem[_33276 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33491 + 68] = mem[_33491 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33491 + -mem[64] + 100
                                    _32399 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32399] = 26
                                    mem[_32399 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34832] = 30
                                        mem[_34832 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _37971 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37971] = 30
                                        mem[_37971 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39453 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39453 + idx + 68] = mem[_37971 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39453 + 68] = mem[_39453 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39453 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _47924 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47924] = 30
                                        mem[_47924 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50117 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50117 + idx + 68] = mem[_47924 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50117 + 68] = mem[_50117 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50117 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35233 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35233] = 30
                                    mem[_35233 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35917 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35917 + idx + 68] = mem[_35233 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35917 + 68] = mem[_35917 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35917 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39452 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39452] = 30
                                    mem[_39452 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _41482 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41482 + idx + 68] = mem[_39452 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41482 + 68] = mem[_41482 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41482 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _50116 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50116] = 30
                                    mem[_50116 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52048 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52048 + idx + 68] = mem[_50116 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52048 + 68] = mem[_52048 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52048 + -mem[64] + 100
                                _31691 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31691] = 26
                                mem[_31691 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32657 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32657] = 26
                                    mem[_32657 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                else:
                                    _32656 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32656] = 26
                                    mem[_32656 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32166 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32166] = 26
                                        mem[_32166 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34630 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34630] = 30
                                                mem[_34630 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _36580 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36580] = 30
                                                mem[_36580 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _37957 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_37957 + idx + 68] = mem[_36580 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_37957 + 68] = mem[_37957 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _37957 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _45447 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45447] = 30
                                                mem[_45447 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _47905 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_47905 + idx + 68] = mem[_45447 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47905 + 68] = mem[_47905 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47905 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34829 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34829] = 30
                                            mem[_34829 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _35223 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35223 + idx + 68] = mem[_34829 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35223 + 68] = mem[_35223 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35223 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _37956 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37956] = 30
                                            mem[_37956 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _39427 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39427 + idx + 68] = mem[_37956 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39427 + 68] = mem[_39427 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39427 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _47904 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_47904] = 30
                                            mem[_47904 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50098 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50098 + idx + 68] = mem[_47904 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50098 + 68] = mem[_50098 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50098 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _34828 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34828] = 30
                                            mem[_34828 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35220 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35220 + idx + 68] = mem[_34828 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35220 + 68] = mem[_35220 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35220 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _37955 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37955] = 30
                                            mem[_37955 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _39424 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39424 + idx + 68] = mem[_37955 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39424 + 68] = mem[_39424 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39424 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _47903 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_47903] = 30
                                            mem[_47903 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50095 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50095 + idx + 68] = mem[_47903 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50095 + 68] = mem[_50095 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50095 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35219 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35219] = 30
                                        mem[_35219 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _35900 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35900 + idx + 68] = mem[_35219 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35900 + 68] = mem[_35900 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35900 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39423 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39423] = 30
                                        mem[_39423 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _41446 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41446 + idx + 68] = mem[_39423 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41446 + 68] = mem[_41446 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41446 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _50094 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50094] = 30
                                        mem[_50094 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52020 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52020 + idx + 68] = mem[_50094 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52020 + 68] = mem[_52020 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52020 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32336 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32336] = 30
                                        mem[_32336 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32476 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32476 + idx + 68] = mem[_32336 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32476 + 68] = mem[_32476 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32476 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33274 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33274] = 30
                                        mem[_33274 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33486 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33486 + idx + 68] = mem[_33274 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33486 + 68] = mem[_33486 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33486 + -mem[64] + 100
                                    _32398 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32398] = 26
                                    mem[_32398 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34830 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34830] = 30
                                            mem[_34830 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _37964 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37964] = 30
                                            mem[_37964 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _39437 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39437 + idx + 68] = mem[_37964 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39437 + 68] = mem[_39437 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39437 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _47912 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_47912] = 30
                                            mem[_47912 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50105 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50105 + idx + 68] = mem[_47912 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50105 + 68] = mem[_50105 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50105 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35227 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35227] = 30
                                        mem[_35227 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _35910 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35910 + idx + 68] = mem[_35227 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35910 + 68] = mem[_35910 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35910 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39436 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39436] = 30
                                        mem[_39436 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _41462 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41462 + idx + 68] = mem[_39436 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41462 + 68] = mem[_41462 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41462 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _50104 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50104] = 30
                                        mem[_50104 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52032 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52032 + idx + 68] = mem[_50104 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52032 + 68] = mem[_52032 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52032 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _35226 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35226] = 30
                                        mem[_35226 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35907 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35907 + idx + 68] = mem[_35226 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35907 + 68] = mem[_35907 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35907 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39435 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39435] = 30
                                        mem[_39435 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _41459 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41459 + idx + 68] = mem[_39435 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41459 + 68] = mem[_41459 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41459 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _50103 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50103] = 30
                                        mem[_50103 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52029 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52029 + idx + 68] = mem[_50103 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52029 + 68] = mem[_52029 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52029 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35906 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35906] = 30
                                    mem[_35906 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _36951 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36951 + idx + 68] = mem[_35906 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36951 + 68] = mem[_36951 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36951 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _41458 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41458] = 30
                                    mem[_41458 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _43760 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_43760 + idx + 68] = mem[_41458 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43760 + 68] = mem[_43760 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43760 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _52028 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52028] = 30
                                    mem[_52028 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _54040 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_54040 + idx + 68] = mem[_52028 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54040 + 68] = mem[_54040 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54040 + -mem[64] + 100
                                _31686 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31686] = 26
                                mem[_31686 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32655 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32655] = 26
                                    mem[_32655 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    _32654 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32654] = 26
                                    mem[_32654 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                        else:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32175 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32175] = 26
                                        mem[_32175 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34633 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34633] = 30
                                            mem[_34633 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _36591 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36591] = 30
                                            mem[_36591 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _37985 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_37985 + idx + 68] = mem[_36591 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37985 + 68] = mem[_37985 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37985 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40695 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40695] = 30
                                            mem[_40695 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _43020 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_43020 + idx + 68] = mem[_40695 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43020 + 68] = mem[_43020 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43020 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _54097 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_54097] = 30
                                            mem[_54097 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _56095 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_56095 + idx + 68] = mem[_54097 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_56095 + 68] = mem[_56095 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _56095 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34836 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34836] = 30
                                        mem[_34836 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35247 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35247 + idx + 68] = mem[_34836 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35247 + 68] = mem[_35247 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35247 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _37984 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37984] = 30
                                        mem[_37984 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _39489 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39489 + idx + 68] = mem[_37984 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39489 + 68] = mem[_39489 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39489 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _43017 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43017] = 30
                                        mem[_43017 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _45495 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_45495 + idx + 68] = mem[_43017 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45495 + 68] = mem[_45495 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45495 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _56094 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_56094] = 30
                                        mem[_56094 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _57812 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_57812 + idx + 68] = mem[_56094 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_57812 + 68] = mem[_57812 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _57812 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32339 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32339] = 30
                                        mem[_32339 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32485 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32485 + idx + 68] = mem[_32339 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32485 + 68] = mem[_32485 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32485 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33280 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33280] = 30
                                        mem[_33280 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33501 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33501 + idx + 68] = mem[_33280 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33501 + 68] = mem[_33501 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33501 + -mem[64] + 100
                                    _32401 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32401] = 26
                                    mem[_32401 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34837 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34837] = 30
                                        mem[_34837 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _37990 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37990] = 30
                                        mem[_37990 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _39496 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39496 + idx + 68] = mem[_37990 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39496 + 68] = mem[_39496 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39496 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _43023 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43023] = 30
                                        mem[_43023 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _45504 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_45504 + idx + 68] = mem[_43023 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45504 + 68] = mem[_45504 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45504 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _56099 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_56099] = 30
                                        mem[_56099 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _57817 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_57817 + idx + 68] = mem[_56099 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_57817 + 68] = mem[_57817 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _57817 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35250 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35250] = 30
                                    mem[_35250 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35941 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35941 + idx + 68] = mem[_35250 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35941 + 68] = mem[_35941 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35941 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _39495 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39495] = 30
                                    mem[_39495 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _41534 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41534 + idx + 68] = mem[_39495 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41534 + 68] = mem[_41534 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41534 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _45501 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_45501] = 30
                                    mem[_45501 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _47985 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_47985 + idx + 68] = mem[_45501 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_47985 + 68] = mem[_47985 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _47985 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _57816 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_57816] = 30
                                    mem[_57816 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _59130 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_59130 + idx + 68] = mem[_57816 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59130 + 68] = mem[_59130 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59130 + -mem[64] + 100
                                _31701 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31701] = 26
                                mem[_31701 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32661 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32661] = 26
                                    mem[_32661 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                else:
                                    _32660 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32660] = 26
                                    mem[_32660 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32172 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32172] = 26
                                        mem[_32172 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34632 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34632] = 30
                                                mem[_34632 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _36588 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36588] = 30
                                                mem[_36588 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _37976 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_37976 + idx + 68] = mem[_36588 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_37976 + 68] = mem[_37976 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _37976 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _40686 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40686] = 30
                                                mem[_40686 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _43011 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_43011 + idx + 68] = mem[_40686 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43011 + 68] = mem[_43011 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43011 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _54085 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_54085] = 30
                                                mem[_54085 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _56086 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_56086 + idx + 68] = mem[_54085 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_56086 + 68] = mem[_56086 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _56086 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34834 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34834] = 30
                                            mem[_34834 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _35240 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35240 + idx + 68] = mem[_34834 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35240 + 68] = mem[_35240 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35240 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _37975 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37975] = 30
                                            mem[_37975 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _39470 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39470 + idx + 68] = mem[_37975 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39470 + 68] = mem[_39470 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39470 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43008 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43008] = 30
                                            mem[_43008 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _45474 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45474 + idx + 68] = mem[_43008 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45474 + 68] = mem[_45474 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45474 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _56085 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56085] = 30
                                            mem[_56085 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _57798 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_57798 + idx + 68] = mem[_56085 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_57798 + 68] = mem[_57798 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _57798 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _34833 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34833] = 30
                                            mem[_34833 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35237 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35237 + idx + 68] = mem[_34833 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35237 + 68] = mem[_35237 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35237 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _37974 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37974] = 30
                                            mem[_37974 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _39467 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39467 + idx + 68] = mem[_37974 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39467 + 68] = mem[_39467 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39467 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43005 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43005] = 30
                                            mem[_43005 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _45471 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45471 + idx + 68] = mem[_43005 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45471 + 68] = mem[_45471 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45471 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _56084 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56084] = 30
                                            mem[_56084 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _57795 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_57795 + idx + 68] = mem[_56084 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_57795 + 68] = mem[_57795 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _57795 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35236 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35236] = 30
                                        mem[_35236 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _35924 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35924 + idx + 68] = mem[_35236 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35924 + 68] = mem[_35924 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35924 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _39466 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39466] = 30
                                        mem[_39466 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _41502 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41502 + idx + 68] = mem[_39466 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41502 + 68] = mem[_41502 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41502 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _45468 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45468] = 30
                                        mem[_45468 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _47943 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_47943 + idx + 68] = mem[_45468 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47943 + 68] = mem[_47943 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47943 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _57794 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57794] = 30
                                        mem[_57794 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _59102 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59102 + idx + 68] = mem[_57794 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59102 + 68] = mem[_59102 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59102 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32338 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32338] = 30
                                        mem[_32338 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32482 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32482 + idx + 68] = mem[_32338 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32482 + 68] = mem[_32482 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32482 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33278 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33278] = 30
                                        mem[_33278 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33496 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33496 + idx + 68] = mem[_33278 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33496 + 68] = mem[_33496 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33496 + -mem[64] + 100
                                    _32400 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32400] = 26
                                    mem[_32400 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34835 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34835] = 30
                                            mem[_34835 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _37983 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37983] = 30
                                            mem[_37983 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _39480 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39480 + idx + 68] = mem[_37983 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39480 + 68] = mem[_39480 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39480 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43014 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43014] = 30
                                            mem[_43014 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _45486 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45486 + idx + 68] = mem[_43014 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45486 + 68] = mem[_45486 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45486 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _56091 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56091] = 30
                                            mem[_56091 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _57805 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_57805 + idx + 68] = mem[_56091 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_57805 + 68] = mem[_57805 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _57805 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35244 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35244] = 30
                                        mem[_35244 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _35934 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35934 + idx + 68] = mem[_35244 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35934 + 68] = mem[_35934 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35934 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _39479 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39479] = 30
                                        mem[_39479 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _41516 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41516 + idx + 68] = mem[_39479 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41516 + 68] = mem[_41516 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41516 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _45483 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45483] = 30
                                        mem[_45483 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _47961 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_47961 + idx + 68] = mem[_45483 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47961 + 68] = mem[_47961 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47961 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _57804 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57804] = 30
                                        mem[_57804 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _59114 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59114 + idx + 68] = mem[_57804 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59114 + 68] = mem[_59114 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59114 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _35243 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35243] = 30
                                        mem[_35243 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35931 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35931 + idx + 68] = mem[_35243 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35931 + 68] = mem[_35931 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35931 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _39478 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39478] = 30
                                        mem[_39478 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _41513 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41513 + idx + 68] = mem[_39478 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41513 + 68] = mem[_41513 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41513 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _45480 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45480] = 30
                                        mem[_45480 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _47958 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_47958 + idx + 68] = mem[_45480 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47958 + 68] = mem[_47958 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47958 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _57803 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57803] = 30
                                        mem[_57803 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _59111 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59111 + idx + 68] = mem[_57803 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59111 + 68] = mem[_59111 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59111 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35930 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35930] = 30
                                    mem[_35930 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _36986 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36986 + idx + 68] = mem[_35930 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36986 + 68] = mem[_36986 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36986 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _41512 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41512] = 30
                                    mem[_41512 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _43818 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_43818 + idx + 68] = mem[_41512 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43818 + 68] = mem[_43818 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43818 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _47955 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47955] = 30
                                    mem[_47955 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _50153 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50153 + idx + 68] = mem[_47955 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50153 + 68] = mem[_50153 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50153 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _59110 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_59110] = 30
                                    mem[_59110 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _60138 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_60138 + idx + 68] = mem[_59110 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_60138 + 68] = mem[_60138 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _60138 + -mem[64] + 100
                                _31696 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31696] = 26
                                mem[_31696 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32659 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32659] = 26
                                    mem[_32659 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    _32658 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32658] = 26
                                    mem[_32658 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
        else:
            mem[0] = arg1
            mem[32] = 4
            if stor4[address(arg1)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not arg2 / 100:
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = 1000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _32229 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32229] = 26
                            mem[_32229 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _34651 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34651] = 30
                                mem[_34651 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _36663 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36663] = 30
                                mem[_36663 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _38156 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_38156 + idx + 68] = mem[_36663 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38156 + 68] = mem[_38156 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38156 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _49471 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_49471] = 30
                                mem[_49471 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _51540 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_51540 + idx + 68] = mem[_49471 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_51540 + 68] = mem[_51540 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _51540 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _34881 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34881] = 30
                            mem[_34881 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _35400 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_35400 + idx + 68] = mem[_34881 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35400 + 68] = mem[_35400 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35400 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _38155 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38155] = 30
                            mem[_38155 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _39876 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_39876 + idx + 68] = mem[_38155 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39876 + 68] = mem[_39876 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39876 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            _51539 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_51539] = 30
                            mem[_51539 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _53498 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_53498 + idx + 68] = mem[_51539 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_53498 + 68] = mem[_53498 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _53498 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _32357 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32357] = 30
                            mem[_32357 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _32539 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_32539 + idx + 68] = mem[_32357 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32539 + 68] = mem[_32539 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _32539 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _33316 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33316] = 30
                            mem[_33316 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _33591 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_33591 + idx + 68] = mem[_33316 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_33591 + 68] = mem[_33591 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _33591 + -mem[64] + 100
                        _32419 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32419] = 26
                        mem[_32419 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _34882 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34882] = 30
                            mem[_34882 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 1
                            _38161 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38161] = 30
                            mem[_38161 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _39883 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_39883 + idx + 68] = mem[_38161 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39883 + 68] = mem[_39883 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39883 + -mem[64] + 100
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _51544 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_51544] = 30
                            mem[_51544 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _53503 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_53503 + idx + 68] = mem[_51544 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_53503 + 68] = mem[_53503 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _53503 + -mem[64] + 100
                        require arg2
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _35403 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35403] = 30
                        mem[_35403 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 1000 * 10^18:
                            _36157 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_36157 + idx + 68] = mem[_35403 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_36157 + 68] = mem[_36157 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36157 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _39882 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_39882] = 30
                        mem[_39882 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _42030 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_42030 + idx + 68] = mem[_39882 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_42030 + 68] = mem[_42030 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _42030 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] += arg2
                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                        _53502 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_53502] = 30
                        mem[_53502 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _55482 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_55482 + idx + 68] = mem[_53502 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_55482 + 68] = mem[_55482 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _55482 + -mem[64] + 100
                    _31791 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31791] = 26
                    mem[_31791 + 32] = 'SafeMath: division by zero'
                    if t < stor6 / 1000 * 10^18:
                        _32697 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32697] = 26
                        mem[_32697 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require arg2
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                    else:
                        _32696 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32696] = 26
                        mem[_32696 + 32] = 'SafeMath: division by zero'
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require s
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require arg2
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * t / s
                    if 0 > stor6:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    require arg2 / 100
                    if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 * reflectFees > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = 1000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _32226 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32226] = 26
                            mem[_32226 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100 * reflectFees:
                                    _34650 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34650] = 30
                                    mem[_34650 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _36660 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36660] = 30
                                    mem[_36660 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _38147 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38147 + idx + 68] = mem[_36660 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38147 + 68] = mem[_38147 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38147 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _49459 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49459] = 30
                                    mem[_49459 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _51531 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_51531 + idx + 68] = mem[_49459 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51531 + 68] = mem[_51531 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51531 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34879 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34879] = 30
                                mem[_34879 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                    _35393 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35393 + idx + 68] = mem[_34879 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35393 + 68] = mem[_35393 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35393 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _38146 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38146] = 30
                                mem[_38146 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _39857 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39857 + idx + 68] = mem[_38146 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39857 + 68] = mem[_39857 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39857 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                _51530 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51530] = 30
                                mem[_51530 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _53484 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_53484 + idx + 68] = mem[_51530 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53484 + 68] = mem[_53484 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53484 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100 * reflectFees:
                                _34878 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34878] = 30
                                mem[_34878 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _35390 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35390 + idx + 68] = mem[_34878 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35390 + 68] = mem[_35390 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35390 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _38145 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38145] = 30
                                mem[_38145 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _39854 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39854 + idx + 68] = mem[_38145 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39854 + 68] = mem[_39854 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39854 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _51529 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51529] = 30
                                mem[_51529 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _53481 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_53481 + idx + 68] = mem[_51529 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53481 + 68] = mem[_53481 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53481 + -mem[64] + 100
                            require arg2 / 100 * reflectFees
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _35389 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35389] = 30
                            mem[_35389 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                _36140 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_36140 + idx + 68] = mem[_35389 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36140 + 68] = mem[_36140 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36140 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _39853 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39853] = 30
                            mem[_39853 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _41994 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_41994 + idx + 68] = mem[_39853 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_41994 + 68] = mem[_41994 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _41994 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                            _53480 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53480] = 30
                            mem[_53480 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                return 1
                            _55454 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_55454 + idx + 68] = mem[_53480 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_55454 + 68] = mem[_55454 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55454 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _32356 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32356] = 30
                            mem[_32356 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _32536 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_32536 + idx + 68] = mem[_32356 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32536 + 68] = mem[_32536 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _32536 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _33314 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33314] = 30
                            mem[_33314 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _33586 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_33586 + idx + 68] = mem[_33314 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_33586 + 68] = mem[_33586 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _33586 + -mem[64] + 100
                        _32418 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32418] = 26
                        mem[_32418 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not arg2 / 100 * reflectFees:
                                _34880 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34880] = 30
                                mem[_34880 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _38154 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38154] = 30
                                mem[_38154 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _39867 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_39867 + idx + 68] = mem[_38154 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39867 + 68] = mem[_39867 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39867 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _51536 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51536] = 30
                                mem[_51536 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _53491 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_53491 + idx + 68] = mem[_51536 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53491 + 68] = mem[_53491 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53491 + -mem[64] + 100
                            require arg2 / 100 * reflectFees
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _35397 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35397] = 30
                            mem[_35397 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                _36150 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_36150 + idx + 68] = mem[_35397 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36150 + 68] = mem[_36150 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36150 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _39866 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39866] = 30
                            mem[_39866 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _42010 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_42010 + idx + 68] = mem[_39866 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_42010 + 68] = mem[_42010 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _42010 + -mem[64] + 100
                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            _53490 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53490] = 30
                            mem[_53490 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                return 1
                            _55466 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_55466 + idx + 68] = mem[_53490 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_55466 + 68] = mem[_55466 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55466 + -mem[64] + 100
                        require arg2
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not arg2 / 100 * reflectFees:
                            _35396 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35396] = 30
                            mem[_35396 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _36147 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_36147 + idx + 68] = mem[_35396 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36147 + 68] = mem[_36147 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36147 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _39865 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_39865] = 30
                            mem[_39865 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _42007 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_42007 + idx + 68] = mem[_39865 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_42007 + 68] = mem[_42007 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _42007 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            _53489 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53489] = 30
                            mem[_53489 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                return 1
                            _55463 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_55463 + idx + 68] = mem[_53489 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_55463 + 68] = mem[_55463 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55463 + -mem[64] + 100
                        require arg2 / 100 * reflectFees
                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _36146 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_36146] = 30
                        mem[_36146 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                            _37301 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_37301 + idx + 68] = mem[_36146 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_37301 + 68] = mem[_37301 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _37301 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _42006 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_42006] = 30
                        mem[_42006 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _44350 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_44350 + idx + 68] = mem[_42006 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_44350 + 68] = mem[_44350 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _44350 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                        _55462 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_55462] = 30
                        mem[_55462 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100 * reflectFees
                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                            return 1
                        _57269 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_57269 + idx + 68] = mem[_55462 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_57269 + 68] = mem[_57269 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _57269 + -mem[64] + 100
                    _31786 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31786] = 26
                    mem[_31786 + 32] = 'SafeMath: division by zero'
                    if t < stor6 / 1000 * 10^18:
                        _32695 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32695] = 26
                        mem[_32695 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not arg2 / 100 * reflectFees:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                        else:
                            require arg2
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100 * reflectFees:
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                    else:
                        _32694 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32694] = 26
                        mem[_32694 + 32] = 'SafeMath: division by zero'
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require s
                        if not arg2:
                            if not arg2 / 100 * reflectFees:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * reflectFees * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                if arg2 / 100 * reflectFees * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                        else:
                            require arg2
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100 * reflectFees:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                if arg2 / 100 * reflectFees * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg2 / 100 * reflectFees
                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
            else:
                if stor4[address(msg.sender)]:
                    mem[0] = msg.sender
                    mem[32] = 4
                    if not stor4[address(msg.sender)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32187 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32187] = 26
                                    mem[_32187 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34637 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34637] = 30
                                        mem[_34637 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _36607 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36607] = 30
                                        mem[_36607 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _38023 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38023 + idx + 68] = mem[_36607 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38023 + 68] = mem[_38023 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38023 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _45549 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45549] = 30
                                        mem[_45549 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _48052 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_48052 + idx + 68] = mem[_45549 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_48052 + 68] = mem[_48052 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _48052 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34846 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34846] = 30
                                    mem[_34846 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35281 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35281 + idx + 68] = mem[_34846 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35281 + 68] = mem[_35281 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35281 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38022 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38022] = 30
                                    mem[_38022 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _39575 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39575 + idx + 68] = mem[_38022 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39575 + 68] = mem[_39575 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39575 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _48051 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48051] = 30
                                    mem[_48051 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50250 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50250 + idx + 68] = mem[_48051 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50250 + 68] = mem[_50250 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50250 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32343 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32343] = 30
                                    mem[_32343 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32497 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32497 + idx + 68] = mem[_32343 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32497 + 68] = mem[_32497 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32497 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33288 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33288] = 30
                                    mem[_33288 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33521 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33521 + idx + 68] = mem[_33288 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33521 + 68] = mem[_33521 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33521 + -mem[64] + 100
                                _32405 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32405] = 26
                                mem[_32405 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _34847 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34847] = 30
                                    mem[_34847 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38028 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38028] = 30
                                    mem[_38028 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _39582 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39582 + idx + 68] = mem[_38028 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39582 + 68] = mem[_39582 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39582 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _48056 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48056] = 30
                                    mem[_48056 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50255 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50255 + idx + 68] = mem[_48056 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50255 + 68] = mem[_50255 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50255 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35284 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35284] = 30
                                mem[_35284 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _35989 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35989 + idx + 68] = mem[_35284 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35989 + 68] = mem[_35989 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35989 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _39581 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39581] = 30
                                mem[_39581 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _41646 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_41646 + idx + 68] = mem[_39581 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41646 + 68] = mem[_41646 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41646 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _50254 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50254] = 30
                                mem[_50254 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _52189 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_52189 + idx + 68] = mem[_50254 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52189 + 68] = mem[_52189 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52189 + -mem[64] + 100
                            _31721 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31721] = 26
                            mem[_31721 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32669 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32669] = 26
                                mem[_32669 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            else:
                                _32668 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32668] = 26
                                mem[_32668 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32184 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32184] = 26
                                    mem[_32184 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34636 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34636] = 30
                                            mem[_34636 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36604 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36604] = 30
                                            mem[_36604 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _38014 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38014 + idx + 68] = mem[_36604 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38014 + 68] = mem[_38014 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38014 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45538 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45538] = 30
                                            mem[_45538 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _48037 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48037 + idx + 68] = mem[_45538 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48037 + 68] = mem[_48037 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48037 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34844 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34844] = 30
                                        mem[_34844 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _35274 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35274 + idx + 68] = mem[_34844 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35274 + 68] = mem[_35274 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35274 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38013 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38013] = 30
                                        mem[_38013 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39556 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39556 + idx + 68] = mem[_38013 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39556 + 68] = mem[_39556 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39556 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _48036 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48036] = 30
                                        mem[_48036 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50236 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50236 + idx + 68] = mem[_48036 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50236 + 68] = mem[_50236 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50236 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _34843 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34843] = 30
                                        mem[_34843 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35271 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35271 + idx + 68] = mem[_34843 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35271 + 68] = mem[_35271 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35271 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38012 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38012] = 30
                                        mem[_38012 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _39553 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39553 + idx + 68] = mem[_38012 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39553 + 68] = mem[_39553 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39553 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _48035 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48035] = 30
                                        mem[_48035 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50233 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50233 + idx + 68] = mem[_48035 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50233 + 68] = mem[_50233 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50233 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35270 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35270] = 30
                                    mem[_35270 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _35972 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35972 + idx + 68] = mem[_35270 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35972 + 68] = mem[_35972 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35972 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39552 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39552] = 30
                                    mem[_39552 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _41610 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41610 + idx + 68] = mem[_39552 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41610 + 68] = mem[_41610 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41610 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _50232 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50232] = 30
                                    mem[_50232 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52161 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52161 + idx + 68] = mem[_50232 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52161 + 68] = mem[_52161 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52161 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32342 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32342] = 30
                                    mem[_32342 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32494 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32494 + idx + 68] = mem[_32342 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32494 + 68] = mem[_32494 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32494 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33286 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33286] = 30
                                    mem[_33286 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33516 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33516 + idx + 68] = mem[_33286 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33516 + 68] = mem[_33516 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33516 + -mem[64] + 100
                                _32404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32404] = 26
                                mem[_32404 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        _34845 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34845] = 30
                                        mem[_34845 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38021 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38021] = 30
                                        mem[_38021 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39566 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39566 + idx + 68] = mem[_38021 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39566 + 68] = mem[_39566 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39566 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _48044 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48044] = 30
                                        mem[_48044 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50243 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50243 + idx + 68] = mem[_48044 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50243 + 68] = mem[_50243 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50243 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35278 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35278] = 30
                                    mem[_35278 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        _35982 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35982 + idx + 68] = mem[_35278 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35982 + 68] = mem[_35982 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35982 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39565 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39565] = 30
                                    mem[_39565 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _41626 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41626 + idx + 68] = mem[_39565 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41626 + 68] = mem[_41626 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41626 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    _50242 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50242] = 30
                                    mem[_50242 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52173 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52173 + idx + 68] = mem[_50242 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52173 + 68] = mem[_52173 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52173 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    _35277 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35277] = 30
                                    mem[_35277 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35979 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35979 + idx + 68] = mem[_35277 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35979 + 68] = mem[_35979 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35979 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39564 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39564] = 30
                                    mem[_39564 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _41623 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41623 + idx + 68] = mem[_39564 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41623 + 68] = mem[_41623 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41623 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _50241 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50241] = 30
                                    mem[_50241 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52170 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52170 + idx + 68] = mem[_50241 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52170 + 68] = mem[_52170 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52170 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35978 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35978] = 30
                                mem[_35978 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _37056 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_37056 + idx + 68] = mem[_35978 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37056 + 68] = mem[_37056 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37056 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _41622 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41622] = 30
                                mem[_41622 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _43936 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_43936 + idx + 68] = mem[_41622 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43936 + 68] = mem[_43936 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43936 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                _52169 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52169] = 30
                                mem[_52169 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _54174 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_54174 + idx + 68] = mem[_52169 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54174 + 68] = mem[_54174 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54174 + -mem[64] + 100
                            _31716 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31716] = 26
                            mem[_31716 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32667 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32667] = 26
                                mem[_32667 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            else:
                                _32666 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32666] = 26
                                mem[_32666 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100 * reflectFees
                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not stor4[address(arg1)]:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32193 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32193] = 26
                                        mem[_32193 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34639 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34639] = 30
                                            mem[_34639 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36615 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36615] = 30
                                            mem[_36615 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _38042 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38042 + idx + 68] = mem[_36615 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38042 + 68] = mem[_38042 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38042 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45572 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45572] = 30
                                            mem[_45572 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _48085 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48085 + idx + 68] = mem[_45572 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48085 + 68] = mem[_48085 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48085 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34851 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34851] = 30
                                        mem[_34851 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35298 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35298 + idx + 68] = mem[_34851 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35298 + 68] = mem[_35298 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35298 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38041 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38041] = 30
                                        mem[_38041 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _39618 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39618 + idx + 68] = mem[_38041 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39618 + 68] = mem[_39618 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39618 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _48084 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48084] = 30
                                        mem[_48084 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50286 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50286 + idx + 68] = mem[_48084 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50286 + 68] = mem[_50286 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50286 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32345 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32345] = 30
                                        mem[_32345 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32503 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32503 + idx + 68] = mem[_32345 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32503 + 68] = mem[_32503 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32503 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33292 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33292] = 30
                                        mem[_33292 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33531 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33531 + idx + 68] = mem[_33292 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33531 + 68] = mem[_33531 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33531 + -mem[64] + 100
                                    _32407 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32407] = 26
                                    mem[_32407 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34852 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34852] = 30
                                        mem[_34852 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38047 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38047] = 30
                                        mem[_38047 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39625 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39625 + idx + 68] = mem[_38047 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39625 + 68] = mem[_39625 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39625 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _48089 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48089] = 30
                                        mem[_48089 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50291 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50291 + idx + 68] = mem[_48089 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50291 + 68] = mem[_50291 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50291 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35301] = 30
                                    mem[_35301 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _36013 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36013 + idx + 68] = mem[_35301 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36013 + 68] = mem[_36013 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36013 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39624 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39624] = 30
                                    mem[_39624 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _41702 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41702 + idx + 68] = mem[_39624 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41702 + 68] = mem[_41702 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41702 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _50290 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50290] = 30
                                    mem[_50290 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52233 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52233 + idx + 68] = mem[_50290 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52233 + 68] = mem[_52233 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52233 + -mem[64] + 100
                                _31731 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31731] = 26
                                mem[_31731 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32673 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32673] = 26
                                    mem[_32673 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                else:
                                    _32672 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32672] = 26
                                    mem[_32672 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32190 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32190] = 26
                                        mem[_32190 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34638 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34638] = 30
                                                mem[_34638 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _36612 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36612] = 30
                                                mem[_36612 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _38033 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38033 + idx + 68] = mem[_36612 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38033 + 68] = mem[_38033 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38033 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _45561 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45561] = 30
                                                mem[_45561 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _48070 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48070 + idx + 68] = mem[_45561 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48070 + 68] = mem[_48070 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48070 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34849 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34849] = 30
                                            mem[_34849 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _35291 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35291 + idx + 68] = mem[_34849 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35291 + 68] = mem[_35291 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35291 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38032 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38032] = 30
                                            mem[_38032 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _39599 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39599 + idx + 68] = mem[_38032 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39599 + 68] = mem[_39599 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39599 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _48069 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48069] = 30
                                            mem[_48069 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50272 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50272 + idx + 68] = mem[_48069 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50272 + 68] = mem[_50272 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50272 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _34848 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34848] = 30
                                            mem[_34848 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35288 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35288 + idx + 68] = mem[_34848 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35288 + 68] = mem[_35288 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35288 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38031 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38031] = 30
                                            mem[_38031 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _39596 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39596 + idx + 68] = mem[_38031 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39596 + 68] = mem[_39596 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39596 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _48068 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48068] = 30
                                            mem[_48068 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50269 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50269 + idx + 68] = mem[_48068 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50269 + 68] = mem[_50269 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50269 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35287 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35287] = 30
                                        mem[_35287 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _35996 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35996 + idx + 68] = mem[_35287 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35996 + 68] = mem[_35996 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35996 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39595 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39595] = 30
                                        mem[_39595 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _41666 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41666 + idx + 68] = mem[_39595 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41666 + 68] = mem[_41666 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41666 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _50268 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50268] = 30
                                        mem[_50268 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52205 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52205 + idx + 68] = mem[_50268 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52205 + 68] = mem[_52205 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52205 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32344 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32344] = 30
                                        mem[_32344 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32500 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32500 + idx + 68] = mem[_32344 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32500 + 68] = mem[_32500 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32500 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33290 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33290] = 30
                                        mem[_33290 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33526 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33526 + idx + 68] = mem[_33290 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33526 + 68] = mem[_33526 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33526 + -mem[64] + 100
                                    _32406 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32406] = 26
                                    mem[_32406 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34850 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34850] = 30
                                            mem[_34850 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38040 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38040] = 30
                                            mem[_38040 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _39609 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39609 + idx + 68] = mem[_38040 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39609 + 68] = mem[_39609 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39609 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _48077 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48077] = 30
                                            mem[_48077 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50279 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50279 + idx + 68] = mem[_48077 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50279 + 68] = mem[_50279 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50279 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35295 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35295] = 30
                                        mem[_35295 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _36006 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36006 + idx + 68] = mem[_35295 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36006 + 68] = mem[_36006 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36006 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39608 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39608] = 30
                                        mem[_39608 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _41682 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41682 + idx + 68] = mem[_39608 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41682 + 68] = mem[_41682 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41682 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _50278 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50278] = 30
                                        mem[_50278 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52217 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52217 + idx + 68] = mem[_50278 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52217 + 68] = mem[_52217 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52217 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _35294 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35294] = 30
                                        mem[_35294 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36003 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36003 + idx + 68] = mem[_35294 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36003 + 68] = mem[_36003 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36003 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39607 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39607] = 30
                                        mem[_39607 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _41679 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41679 + idx + 68] = mem[_39607 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41679 + 68] = mem[_41679 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41679 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _50277 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50277] = 30
                                        mem[_50277 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52214 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52214 + idx + 68] = mem[_50277 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52214 + 68] = mem[_52214 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52214 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36002 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36002] = 30
                                    mem[_36002 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _37091 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_37091 + idx + 68] = mem[_36002 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37091 + 68] = mem[_37091 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37091 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _41678 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41678] = 30
                                    mem[_41678 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _43998 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_43998 + idx + 68] = mem[_41678 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43998 + 68] = mem[_43998 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43998 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _52213 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52213] = 30
                                    mem[_52213 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _54224 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_54224 + idx + 68] = mem[_52213 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54224 + 68] = mem[_54224 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54224 + -mem[64] + 100
                                _31726 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31726] = 26
                                mem[_31726 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32671 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32671] = 26
                                    mem[_32671 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    _32670 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32670] = 26
                                    mem[_32670 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                        else:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32199 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32199] = 26
                                        mem[_32199 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34641 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34641] = 30
                                            mem[_34641 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _36623 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36623] = 30
                                            mem[_36623 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _38061 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38061 + idx + 68] = mem[_36623 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38061 + 68] = mem[_38061 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38061 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40777 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40777] = 30
                                            mem[_40777 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _43093 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_43093 + idx + 68] = mem[_40777 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43093 + 68] = mem[_43093 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43093 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _54281 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_54281] = 30
                                            mem[_54281 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _56261 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_56261 + idx + 68] = mem[_54281 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_56261 + 68] = mem[_56261 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _56261 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34856 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34856] = 30
                                        mem[_34856 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35315 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35315 + idx + 68] = mem[_34856 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35315 + 68] = mem[_35315 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35315 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _38060 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38060] = 30
                                        mem[_38060 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _39661 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39661 + idx + 68] = mem[_38060 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39661 + 68] = mem[_39661 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39661 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _43090 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43090] = 30
                                        mem[_43090 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _45609 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_45609 + idx + 68] = mem[_43090 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45609 + 68] = mem[_45609 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45609 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _56260 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_56260] = 30
                                        mem[_56260 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _57961 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_57961 + idx + 68] = mem[_56260 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_57961 + 68] = mem[_57961 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _57961 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32347 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32347] = 30
                                        mem[_32347 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32509 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32509 + idx + 68] = mem[_32347 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32509 + 68] = mem[_32509 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32509 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33296 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33296] = 30
                                        mem[_33296 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33541 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33541 + idx + 68] = mem[_33296 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33541 + 68] = mem[_33541 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33541 + -mem[64] + 100
                                    _32409 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32409] = 26
                                    mem[_32409 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34857 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34857] = 30
                                        mem[_34857 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _38066 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38066] = 30
                                        mem[_38066 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _39668 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39668 + idx + 68] = mem[_38066 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39668 + 68] = mem[_39668 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39668 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _43096 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43096] = 30
                                        mem[_43096 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _45618 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_45618 + idx + 68] = mem[_43096 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45618 + 68] = mem[_45618 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45618 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _56265 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_56265] = 30
                                        mem[_56265 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _57966 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_57966 + idx + 68] = mem[_56265 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_57966 + 68] = mem[_57966 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _57966 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35318 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35318] = 30
                                    mem[_35318 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _36037 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36037 + idx + 68] = mem[_35318 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36037 + 68] = mem[_36037 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36037 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _39667 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39667] = 30
                                    mem[_39667 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _41754 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41754 + idx + 68] = mem[_39667 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41754 + 68] = mem[_41754 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41754 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _45615 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_45615] = 30
                                    mem[_45615 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _48150 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_48150 + idx + 68] = mem[_45615 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_48150 + 68] = mem[_48150 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _48150 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _57965 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_57965] = 30
                                    mem[_57965 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _59238 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_59238 + idx + 68] = mem[_57965 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59238 + 68] = mem[_59238 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59238 + -mem[64] + 100
                                _31741 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31741] = 26
                                mem[_31741 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32677 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32677] = 26
                                    mem[_32677 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                else:
                                    _32676 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32676] = 26
                                    mem[_32676 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32196 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32196] = 26
                                        mem[_32196 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34640 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34640] = 30
                                                mem[_34640 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _36620 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36620] = 30
                                                mem[_36620 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _38052 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38052 + idx + 68] = mem[_36620 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38052 + 68] = mem[_38052 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38052 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _40768 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40768] = 30
                                                mem[_40768 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _43084 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_43084 + idx + 68] = mem[_40768 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43084 + 68] = mem[_43084 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43084 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _54269 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_54269] = 30
                                                mem[_54269 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _56252 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_56252 + idx + 68] = mem[_54269 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_56252 + 68] = mem[_56252 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _56252 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34854 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34854] = 30
                                            mem[_34854 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _35308 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35308 + idx + 68] = mem[_34854 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35308 + 68] = mem[_35308 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35308 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38051 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38051] = 30
                                            mem[_38051 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _39642 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39642 + idx + 68] = mem[_38051 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39642 + 68] = mem[_39642 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39642 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43081 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43081] = 30
                                            mem[_43081 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _45588 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45588 + idx + 68] = mem[_43081 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45588 + 68] = mem[_45588 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45588 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _56251 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56251] = 30
                                            mem[_56251 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _57947 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_57947 + idx + 68] = mem[_56251 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_57947 + 68] = mem[_57947 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _57947 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _34853 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34853] = 30
                                            mem[_34853 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35305 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35305 + idx + 68] = mem[_34853 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35305 + 68] = mem[_35305 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35305 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38050 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38050] = 30
                                            mem[_38050 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _39639 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39639 + idx + 68] = mem[_38050 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39639 + 68] = mem[_39639 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39639 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43078 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43078] = 30
                                            mem[_43078 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _45585 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45585 + idx + 68] = mem[_43078 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45585 + 68] = mem[_45585 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45585 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _56250 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56250] = 30
                                            mem[_56250 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _57944 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_57944 + idx + 68] = mem[_56250 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_57944 + 68] = mem[_57944 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _57944 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35304 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35304] = 30
                                        mem[_35304 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _36020 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36020 + idx + 68] = mem[_35304 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36020 + 68] = mem[_36020 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36020 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _39638 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39638] = 30
                                        mem[_39638 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _41722 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41722 + idx + 68] = mem[_39638 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41722 + 68] = mem[_41722 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41722 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _45582 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45582] = 30
                                        mem[_45582 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _48108 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48108 + idx + 68] = mem[_45582 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48108 + 68] = mem[_48108 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48108 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _57943 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57943] = 30
                                        mem[_57943 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _59210 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59210 + idx + 68] = mem[_57943 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59210 + 68] = mem[_59210 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59210 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32346 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32346] = 30
                                        mem[_32346 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32506 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32506 + idx + 68] = mem[_32346 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32506 + 68] = mem[_32506 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32506 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33294 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33294] = 30
                                        mem[_33294 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33536 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33536 + idx + 68] = mem[_33294 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33536 + 68] = mem[_33536 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33536 + -mem[64] + 100
                                    _32408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32408] = 26
                                    mem[_32408 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34855 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34855] = 30
                                            mem[_34855 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38059 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38059] = 30
                                            mem[_38059 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _39652 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39652 + idx + 68] = mem[_38059 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39652 + 68] = mem[_39652 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39652 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43087 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43087] = 30
                                            mem[_43087 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _45600 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45600 + idx + 68] = mem[_43087 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45600 + 68] = mem[_45600 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45600 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _56257 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56257] = 30
                                            mem[_56257 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _57954 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_57954 + idx + 68] = mem[_56257 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_57954 + 68] = mem[_57954 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _57954 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35312 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35312] = 30
                                        mem[_35312 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _36030 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36030 + idx + 68] = mem[_35312 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36030 + 68] = mem[_36030 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36030 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _39651 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39651] = 30
                                        mem[_39651 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _41736 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41736 + idx + 68] = mem[_39651 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41736 + 68] = mem[_41736 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41736 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _45597 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45597] = 30
                                        mem[_45597 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _48126 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48126 + idx + 68] = mem[_45597 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48126 + 68] = mem[_48126 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48126 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _57953 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57953] = 30
                                        mem[_57953 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _59222 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59222 + idx + 68] = mem[_57953 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59222 + 68] = mem[_59222 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59222 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _35311 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35311] = 30
                                        mem[_35311 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36027 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36027 + idx + 68] = mem[_35311 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36027 + 68] = mem[_36027 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36027 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _39650 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39650] = 30
                                        mem[_39650 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _41733 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41733 + idx + 68] = mem[_39650 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41733 + 68] = mem[_41733 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41733 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _45594 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45594] = 30
                                        mem[_45594 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _48123 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48123 + idx + 68] = mem[_45594 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48123 + 68] = mem[_48123 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48123 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _57952 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57952] = 30
                                        mem[_57952 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _59219 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59219 + idx + 68] = mem[_57952 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59219 + 68] = mem[_59219 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59219 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36026 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36026] = 30
                                    mem[_36026 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _37126 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_37126 + idx + 68] = mem[_36026 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37126 + 68] = mem[_37126 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37126 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _41732 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41732] = 30
                                    mem[_41732 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _44056 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_44056 + idx + 68] = mem[_41732 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44056 + 68] = mem[_44056 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44056 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _48120 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48120] = 30
                                    mem[_48120 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _50327 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50327 + idx + 68] = mem[_48120 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50327 + 68] = mem[_50327 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50327 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _59218 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_59218] = 30
                                    mem[_59218 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _60210 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_60210 + idx + 68] = mem[_59218 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_60210 + 68] = mem[_60210 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _60210 + -mem[64] + 100
                                _31736 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31736] = 26
                                mem[_31736 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32675 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32675] = 26
                                    mem[_32675 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    _32674 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32674] = 26
                                    mem[_32674 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    if not stor4[address(arg1)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32223 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32223] = 26
                                    mem[_32223 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34649 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34649] = 30
                                        mem[_34649 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _36655 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36655] = 30
                                        mem[_36655 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _38137 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38137 + idx + 68] = mem[_36655 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38137 + 68] = mem[_38137 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38137 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _45731 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45731] = 30
                                        mem[_45731 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _48316 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_48316 + idx + 68] = mem[_45731 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_48316 + 68] = mem[_48316 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _48316 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34876 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34876] = 30
                                    mem[_34876 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35383 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35383 + idx + 68] = mem[_34876 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35383 + 68] = mem[_35383 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35383 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38136 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38136] = 30
                                    mem[_38136 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _39833 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39833 + idx + 68] = mem[_38136 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39833 + 68] = mem[_39833 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39833 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _48315 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48315] = 30
                                    mem[_48315 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50526 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50526 + idx + 68] = mem[_48315 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50526 + 68] = mem[_50526 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50526 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32355 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32355] = 30
                                    mem[_32355 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32533 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32533 + idx + 68] = mem[_32355 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32533 + 68] = mem[_32533 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32533 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33312 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33312] = 30
                                    mem[_33312 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33581 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33581 + idx + 68] = mem[_33312 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33581 + 68] = mem[_33581 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33581 + -mem[64] + 100
                                _32417 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32417] = 26
                                mem[_32417 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _34877 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34877] = 30
                                    mem[_34877 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38142 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38142] = 30
                                    mem[_38142 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _39840 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39840 + idx + 68] = mem[_38142 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39840 + 68] = mem[_39840 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39840 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _48320 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48320] = 30
                                    mem[_48320 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50531 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50531 + idx + 68] = mem[_48320 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50531 + 68] = mem[_50531 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50531 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35386 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35386] = 30
                                mem[_35386 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _36133 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36133 + idx + 68] = mem[_35386 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36133 + 68] = mem[_36133 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36133 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _39839 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39839] = 30
                                mem[_39839 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _41974 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_41974 + idx + 68] = mem[_39839 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41974 + 68] = mem[_41974 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41974 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _50530 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50530] = 30
                                mem[_50530 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _52471 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_52471 + idx + 68] = mem[_50530 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52471 + 68] = mem[_52471 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52471 + -mem[64] + 100
                            _31781 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31781] = 26
                            mem[_31781 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32693 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32693] = 26
                                mem[_32693 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            else:
                                _32692 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32692] = 26
                                mem[_32692 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32220 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32220] = 26
                                    mem[_32220 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34648 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34648] = 30
                                            mem[_34648 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36652 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36652] = 30
                                            mem[_36652 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _38128 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38128 + idx + 68] = mem[_36652 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38128 + 68] = mem[_38128 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38128 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45720 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45720] = 30
                                            mem[_45720 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _48301 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48301 + idx + 68] = mem[_45720 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48301 + 68] = mem[_48301 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48301 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34874 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34874] = 30
                                        mem[_34874 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _35376 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35376 + idx + 68] = mem[_34874 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35376 + 68] = mem[_35376 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35376 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38127 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38127] = 30
                                        mem[_38127 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39814 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39814 + idx + 68] = mem[_38127 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39814 + 68] = mem[_39814 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39814 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _48300 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48300] = 30
                                        mem[_48300 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50512 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50512 + idx + 68] = mem[_48300 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50512 + 68] = mem[_50512 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50512 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _34873 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34873] = 30
                                        mem[_34873 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35373 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35373 + idx + 68] = mem[_34873 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35373 + 68] = mem[_35373 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35373 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38126 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38126] = 30
                                        mem[_38126 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _39811 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39811 + idx + 68] = mem[_38126 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39811 + 68] = mem[_39811 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39811 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _48299 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48299] = 30
                                        mem[_48299 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50509 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50509 + idx + 68] = mem[_48299 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50509 + 68] = mem[_50509 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50509 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35372 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35372] = 30
                                    mem[_35372 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _36116 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36116 + idx + 68] = mem[_35372 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36116 + 68] = mem[_36116 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36116 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39810 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39810] = 30
                                    mem[_39810 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _41938 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41938 + idx + 68] = mem[_39810 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41938 + 68] = mem[_41938 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41938 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _50508 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50508] = 30
                                    mem[_50508 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52443 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52443 + idx + 68] = mem[_50508 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52443 + 68] = mem[_52443 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52443 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32354 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32354] = 30
                                    mem[_32354 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32530 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32530 + idx + 68] = mem[_32354 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32530 + 68] = mem[_32530 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32530 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33310] = 30
                                    mem[_33310 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33576 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33576 + idx + 68] = mem[_33310 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33576 + 68] = mem[_33576 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33576 + -mem[64] + 100
                                _32416 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32416] = 26
                                mem[_32416 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        _34875 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34875] = 30
                                        mem[_34875 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38135 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38135] = 30
                                        mem[_38135 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39824 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39824 + idx + 68] = mem[_38135 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39824 + 68] = mem[_39824 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39824 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _48308 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48308] = 30
                                        mem[_48308 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50519 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50519 + idx + 68] = mem[_48308 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50519 + 68] = mem[_50519 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50519 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35380 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35380] = 30
                                    mem[_35380 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        _36126 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36126 + idx + 68] = mem[_35380 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36126 + 68] = mem[_36126 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36126 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39823 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39823] = 30
                                    mem[_39823 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _41954 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41954 + idx + 68] = mem[_39823 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41954 + 68] = mem[_41954 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41954 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    _50518 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50518] = 30
                                    mem[_50518 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52455 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52455 + idx + 68] = mem[_50518 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52455 + 68] = mem[_52455 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52455 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    _35379 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35379] = 30
                                    mem[_35379 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _36123 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36123 + idx + 68] = mem[_35379 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36123 + 68] = mem[_36123 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36123 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39822 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39822] = 30
                                    mem[_39822 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _41951 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41951 + idx + 68] = mem[_39822 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41951 + 68] = mem[_41951 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41951 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _50517 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50517] = 30
                                    mem[_50517 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52452 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52452 + idx + 68] = mem[_50517 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52452 + 68] = mem[_52452 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52452 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36122 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36122] = 30
                                mem[_36122 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _37266 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_37266 + idx + 68] = mem[_36122 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37266 + 68] = mem[_37266 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37266 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _41950 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41950] = 30
                                mem[_41950 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _44288 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_44288 + idx + 68] = mem[_41950 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44288 + 68] = mem[_44288 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44288 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                _52451 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52451] = 30
                                mem[_52451 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _54442 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_54442 + idx + 68] = mem[_52451 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54442 + 68] = mem[_54442 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54442 + -mem[64] + 100
                            _31776 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31776] = 26
                            mem[_31776 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32691 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32691] = 26
                                mem[_32691 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            else:
                                _32690 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32690] = 26
                                mem[_32690 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100 * reflectFees
                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                    else:
                        mem[0] = msg.sender
                        mem[32] = 4
                        if not stor4[address(msg.sender)]:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32205 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32205] = 26
                                        mem[_32205 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34643 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34643] = 30
                                            mem[_34643 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36631 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36631] = 30
                                            mem[_36631 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _38080 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38080 + idx + 68] = mem[_36631 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38080 + 68] = mem[_38080 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38080 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45640 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45640] = 30
                                            mem[_45640 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _48184 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48184 + idx + 68] = mem[_45640 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48184 + 68] = mem[_48184 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48184 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34861 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34861] = 30
                                        mem[_34861 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35332 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35332 + idx + 68] = mem[_34861 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35332 + 68] = mem[_35332 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35332 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38079 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38079] = 30
                                        mem[_38079 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _39704 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39704 + idx + 68] = mem[_38079 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39704 + 68] = mem[_39704 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39704 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _48183 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48183] = 30
                                        mem[_48183 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50388 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50388 + idx + 68] = mem[_48183 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50388 + 68] = mem[_50388 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50388 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32349 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32349] = 30
                                        mem[_32349 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32515 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32515 + idx + 68] = mem[_32349 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32515 + 68] = mem[_32515 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32515 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33300 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33300] = 30
                                        mem[_33300 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33551 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33551 + idx + 68] = mem[_33300 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33551 + 68] = mem[_33551 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33551 + -mem[64] + 100
                                    _32411 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32411] = 26
                                    mem[_32411 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34862 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34862] = 30
                                        mem[_34862 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38085 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38085] = 30
                                        mem[_38085 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39711 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39711 + idx + 68] = mem[_38085 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39711 + 68] = mem[_39711 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39711 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _48188 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48188] = 30
                                        mem[_48188 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50393 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50393 + idx + 68] = mem[_48188 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50393 + 68] = mem[_50393 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50393 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35335 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35335] = 30
                                    mem[_35335 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _36061 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36061 + idx + 68] = mem[_35335 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36061 + 68] = mem[_36061 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36061 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39710 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39710] = 30
                                    mem[_39710 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _41810 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_41810 + idx + 68] = mem[_39710 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41810 + 68] = mem[_41810 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41810 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _50392 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50392] = 30
                                    mem[_50392 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52330 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52330 + idx + 68] = mem[_50392 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52330 + 68] = mem[_52330 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52330 + -mem[64] + 100
                                _31751 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31751] = 26
                                mem[_31751 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32681 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32681] = 26
                                    mem[_32681 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                else:
                                    _32680 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32680] = 26
                                    mem[_32680 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32202 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32202] = 26
                                        mem[_32202 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34642 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34642] = 30
                                                mem[_34642 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _36628 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36628] = 30
                                                mem[_36628 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _38071 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38071 + idx + 68] = mem[_36628 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38071 + 68] = mem[_38071 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38071 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _45629 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45629] = 30
                                                mem[_45629 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _48169 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48169 + idx + 68] = mem[_45629 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48169 + 68] = mem[_48169 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48169 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34859 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34859] = 30
                                            mem[_34859 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _35325 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35325 + idx + 68] = mem[_34859 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35325 + 68] = mem[_35325 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35325 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38070 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38070] = 30
                                            mem[_38070 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _39685 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39685 + idx + 68] = mem[_38070 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39685 + 68] = mem[_39685 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39685 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _48168 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48168] = 30
                                            mem[_48168 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50374 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50374 + idx + 68] = mem[_48168 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50374 + 68] = mem[_50374 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50374 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _34858 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34858] = 30
                                            mem[_34858 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35322 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35322 + idx + 68] = mem[_34858 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35322 + 68] = mem[_35322 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35322 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38069 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38069] = 30
                                            mem[_38069 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _39682 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39682 + idx + 68] = mem[_38069 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39682 + 68] = mem[_39682 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39682 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _48167 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48167] = 30
                                            mem[_48167 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50371 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50371 + idx + 68] = mem[_48167 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50371 + 68] = mem[_50371 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50371 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35321 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35321] = 30
                                        mem[_35321 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _36044 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36044 + idx + 68] = mem[_35321 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36044 + 68] = mem[_36044 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36044 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39681 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39681] = 30
                                        mem[_39681 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _41774 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41774 + idx + 68] = mem[_39681 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41774 + 68] = mem[_41774 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41774 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _50370 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50370] = 30
                                        mem[_50370 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52302 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52302 + idx + 68] = mem[_50370 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52302 + 68] = mem[_52302 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52302 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32348 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32348] = 30
                                        mem[_32348 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32512 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32512 + idx + 68] = mem[_32348 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32512 + 68] = mem[_32512 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32512 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33298 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33298] = 30
                                        mem[_33298 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33546 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33546 + idx + 68] = mem[_33298 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33546 + 68] = mem[_33546 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33546 + -mem[64] + 100
                                    _32410 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32410] = 26
                                    mem[_32410 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34860 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34860] = 30
                                            mem[_34860 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38078 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38078] = 30
                                            mem[_38078 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _39695 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39695 + idx + 68] = mem[_38078 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39695 + 68] = mem[_39695 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39695 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _48176 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48176] = 30
                                            mem[_48176 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50381 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50381 + idx + 68] = mem[_48176 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50381 + 68] = mem[_50381 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50381 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35329 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35329] = 30
                                        mem[_35329 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _36054 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36054 + idx + 68] = mem[_35329 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36054 + 68] = mem[_36054 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36054 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39694 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39694] = 30
                                        mem[_39694 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _41790 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41790 + idx + 68] = mem[_39694 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41790 + 68] = mem[_41790 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41790 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _50380 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50380] = 30
                                        mem[_50380 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52314 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52314 + idx + 68] = mem[_50380 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52314 + 68] = mem[_52314 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52314 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _35328 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35328] = 30
                                        mem[_35328 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36051 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36051 + idx + 68] = mem[_35328 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36051 + 68] = mem[_36051 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36051 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39693 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39693] = 30
                                        mem[_39693 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _41787 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41787 + idx + 68] = mem[_39693 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41787 + 68] = mem[_41787 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41787 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _50379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50379] = 30
                                        mem[_50379 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52311 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52311 + idx + 68] = mem[_50379 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52311 + 68] = mem[_52311 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52311 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36050] = 30
                                    mem[_36050 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _37161 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_37161 + idx + 68] = mem[_36050 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37161 + 68] = mem[_37161 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37161 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _41786 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41786] = 30
                                    mem[_41786 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _44112 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_44112 + idx + 68] = mem[_41786 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44112 + 68] = mem[_44112 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44112 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _52310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52310] = 30
                                    mem[_52310 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _54308 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_54308 + idx + 68] = mem[_52310 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54308 + 68] = mem[_54308 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54308 + -mem[64] + 100
                                _31746 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31746] = 26
                                mem[_31746 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32679 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32679] = 26
                                    mem[_32679 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    _32678 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32678] = 26
                                    mem[_32678 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                        else:
                            mem[0] = arg1
                            mem[32] = 4
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            if not stor4[address(arg1)]:
                                if not arg2 / 100:
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32211 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32211] = 26
                                            mem[_32211 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                _34645 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34645] = 30
                                                mem[_34645 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _36639 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36639] = 30
                                                mem[_36639 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _38099 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38099 + idx + 68] = mem[_36639 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38099 + 68] = mem[_38099 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38099 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _45663 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45663] = 30
                                                mem[_45663 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _48217 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48217 + idx + 68] = mem[_45663 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48217 + 68] = mem[_48217 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48217 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34866 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34866] = 30
                                            mem[_34866 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35349 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35349 + idx + 68] = mem[_34866 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35349 + 68] = mem[_35349 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35349 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38098 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38098] = 30
                                            mem[_38098 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _39747 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39747 + idx + 68] = mem[_38098 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39747 + 68] = mem[_39747 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39747 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _48216 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48216] = 30
                                            mem[_48216 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _50424 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50424 + idx + 68] = mem[_48216 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50424 + 68] = mem[_50424 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50424 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32351 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32351] = 30
                                            mem[_32351 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32521 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32521 + idx + 68] = mem[_32351 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32521 + 68] = mem[_32521 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32521 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33304 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33304] = 30
                                            mem[_33304 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33561 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33561 + idx + 68] = mem[_33304 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33561 + 68] = mem[_33561 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33561 + -mem[64] + 100
                                        _32413 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32413] = 26
                                        mem[_32413 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34867 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34867] = 30
                                            mem[_34867 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38104 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38104] = 30
                                            mem[_38104 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _39754 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39754 + idx + 68] = mem[_38104 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39754 + 68] = mem[_39754 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39754 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _48221 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48221] = 30
                                            mem[_48221 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _50429 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50429 + idx + 68] = mem[_48221 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50429 + 68] = mem[_50429 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50429 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35352 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35352] = 30
                                        mem[_35352 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36085 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36085 + idx + 68] = mem[_35352 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36085 + 68] = mem[_36085 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36085 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39753 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39753] = 30
                                        mem[_39753 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _41866 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41866 + idx + 68] = mem[_39753 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41866 + 68] = mem[_41866 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41866 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _50428 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50428] = 30
                                        mem[_50428 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52374 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52374 + idx + 68] = mem[_50428 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52374 + 68] = mem[_52374 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52374 + -mem[64] + 100
                                    _31761 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31761] = 26
                                    mem[_31761 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32685 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32685] = 26
                                        mem[_32685 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    else:
                                        _32684 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32684] = 26
                                        mem[_32684 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32208 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32208] = 26
                                            mem[_32208 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    _34644 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34644] = 30
                                                    mem[_34644 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _36636 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_36636] = 30
                                                    mem[_36636 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _38090 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_38090 + idx + 68] = mem[_36636 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_38090 + 68] = mem[_38090 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _38090 + -mem[64] + 100
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _45652 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_45652] = 30
                                                    mem[_45652 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _48202 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_48202 + idx + 68] = mem[_45652 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_48202 + 68] = mem[_48202 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _48202 + -mem[64] + 100
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _34864 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34864] = 30
                                                mem[_34864 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    _35342 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35342 + idx + 68] = mem[_34864 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35342 + 68] = mem[_35342 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35342 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38089 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38089] = 30
                                                mem[_38089 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _39728 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_39728 + idx + 68] = mem[_38089 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39728 + 68] = mem[_39728 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39728 + -mem[64] + 100
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                _48201 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48201] = 30
                                                mem[_48201 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _50410 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_50410 + idx + 68] = mem[_48201 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50410 + 68] = mem[_50410 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50410 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                _34863 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34863] = 30
                                                mem[_34863 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    _35339 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35339 + idx + 68] = mem[_34863 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35339 + 68] = mem[_35339 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35339 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38088 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38088] = 30
                                                mem[_38088 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _39725 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_39725 + idx + 68] = mem[_38088 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39725 + 68] = mem[_39725 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39725 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                _48200 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48200] = 30
                                                mem[_48200 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _50407 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_50407 + idx + 68] = mem[_48200 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50407 + 68] = mem[_50407 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50407 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35338 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35338] = 30
                                            mem[_35338 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                _36068 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36068 + idx + 68] = mem[_35338 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36068 + 68] = mem[_36068 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36068 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _39724 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39724] = 30
                                            mem[_39724 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _41830 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_41830 + idx + 68] = mem[_39724 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41830 + 68] = mem[_41830 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41830 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            _50406 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50406] = 30
                                            mem[_50406 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52346 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52346 + idx + 68] = mem[_50406 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52346 + 68] = mem[_52346 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52346 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32350 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32350] = 30
                                            mem[_32350 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32518 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32518 + idx + 68] = mem[_32350 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32518 + 68] = mem[_32518 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32518 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33302 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33302] = 30
                                            mem[_33302 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33556 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33556 + idx + 68] = mem[_33302 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33556 + 68] = mem[_33556 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33556 + -mem[64] + 100
                                        _32412 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32412] = 26
                                        mem[_32412 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34865 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34865] = 30
                                                mem[_34865 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38097 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38097] = 30
                                                mem[_38097 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _39738 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_39738 + idx + 68] = mem[_38097 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39738 + 68] = mem[_39738 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39738 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _48209 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48209] = 30
                                                mem[_48209 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _50417 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_50417 + idx + 68] = mem[_48209 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50417 + 68] = mem[_50417 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50417 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35346 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35346] = 30
                                            mem[_35346 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _36078 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36078 + idx + 68] = mem[_35346 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36078 + 68] = mem[_36078 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36078 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _39737 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39737] = 30
                                            mem[_39737 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _41846 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_41846 + idx + 68] = mem[_39737 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41846 + 68] = mem[_41846 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41846 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _50416 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50416] = 30
                                            mem[_50416 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52358 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52358 + idx + 68] = mem[_50416 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52358 + 68] = mem[_52358 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52358 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _35345 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35345] = 30
                                            mem[_35345 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _36075 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36075 + idx + 68] = mem[_35345 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36075 + 68] = mem[_36075 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36075 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _39736 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39736] = 30
                                            mem[_39736 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _41843 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_41843 + idx + 68] = mem[_39736 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41843 + 68] = mem[_41843 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41843 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _50415 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50415] = 30
                                            mem[_50415 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52355 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52355 + idx + 68] = mem[_50415 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52355 + 68] = mem[_52355 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52355 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _36074 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36074] = 30
                                        mem[_36074 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _37196 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37196 + idx + 68] = mem[_36074 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37196 + 68] = mem[_37196 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37196 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _41842 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41842] = 30
                                        mem[_41842 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _44174 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_44174 + idx + 68] = mem[_41842 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44174 + 68] = mem[_44174 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44174 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _52354 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52354] = 30
                                        mem[_52354 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _54358 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_54358 + idx + 68] = mem[_52354 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54358 + 68] = mem[_54358 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54358 + -mem[64] + 100
                                    _31756 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31756] = 26
                                    mem[_31756 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32683 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32683] = 26
                                        mem[_32683 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        _32682 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32682] = 26
                                        mem[_32682 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * t / s
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                            else:
                                if not arg2 / 100:
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32217 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32217] = 26
                                            mem[_32217 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                _34647 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34647] = 30
                                                mem[_34647 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _36647 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36647] = 30
                                                mem[_36647 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _38118 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38118 + idx + 68] = mem[_36647 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38118 + 68] = mem[_38118 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38118 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _40839 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40839] = 30
                                                mem[_40839 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _43150 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_43150 + idx + 68] = mem[_40839 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43150 + 68] = mem[_43150 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43150 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] += arg2
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _54415 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_54415] = 30
                                                mem[_54415 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _56380 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_56380 + idx + 68] = mem[_54415 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_56380 + 68] = mem[_56380 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _56380 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34871 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34871] = 30
                                            mem[_34871 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35366 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35366 + idx + 68] = mem[_34871 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35366 + 68] = mem[_35366 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35366 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38117 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38117] = 30
                                            mem[_38117 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _39790 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39790 + idx + 68] = mem[_38117 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39790 + 68] = mem[_39790 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39790 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43147 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43147] = 30
                                            mem[_43147 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _45700 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45700 + idx + 68] = mem[_43147 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45700 + 68] = mem[_45700 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45700 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _56379 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56379] = 30
                                            mem[_56379 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58071 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_58071 + idx + 68] = mem[_56379 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58071 + 68] = mem[_58071 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58071 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32353 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32353] = 30
                                            mem[_32353 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32527 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32527 + idx + 68] = mem[_32353 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32527 + 68] = mem[_32527 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32527 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33308 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33308] = 30
                                            mem[_33308 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33571 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33571 + idx + 68] = mem[_33308 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33571 + 68] = mem[_33571 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33571 + -mem[64] + 100
                                        _32415 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32415] = 26
                                        mem[_32415 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34872 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34872] = 30
                                            mem[_34872 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38123 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38123] = 30
                                            mem[_38123 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _39797 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39797 + idx + 68] = mem[_38123 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39797 + 68] = mem[_39797 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39797 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43153 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43153] = 30
                                            mem[_43153 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _45709 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45709 + idx + 68] = mem[_43153 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45709 + 68] = mem[_45709 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45709 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _56384 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56384] = 30
                                            mem[_56384 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58076 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_58076 + idx + 68] = mem[_56384 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58076 + 68] = mem[_58076 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58076 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35369 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35369] = 30
                                        mem[_35369 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36109 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36109 + idx + 68] = mem[_35369 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36109 + 68] = mem[_36109 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36109 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _39796 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39796] = 30
                                        mem[_39796 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _41918 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_41918 + idx + 68] = mem[_39796 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41918 + 68] = mem[_41918 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41918 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _45706 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45706] = 30
                                        mem[_45706 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _48282 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48282 + idx + 68] = mem[_45706 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48282 + 68] = mem[_48282 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48282 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _58075 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58075] = 30
                                        mem[_58075 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _59322 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59322 + idx + 68] = mem[_58075 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59322 + 68] = mem[_59322 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59322 + -mem[64] + 100
                                    _31771 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31771] = 26
                                    mem[_31771 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32689 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32689] = 26
                                        mem[_32689 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    else:
                                        _32688 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32688] = 26
                                        mem[_32688 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32214 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32214] = 26
                                            mem[_32214 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    _34646 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34646] = 30
                                                    mem[_34646 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 2
                                                    _36644 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_36644] = 30
                                                    mem[_36644 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        _38109 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_38109 + idx + 68] = mem[_36644 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_38109 + 68] = mem[_38109 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _38109 + -mem[64] + 100
                                                    stor2[address(msg.sender)] -= arg2
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _40830 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_40830] = 30
                                                    mem[_40830 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _43141 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_43141 + idx + 68] = mem[_40830 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_43141 + 68] = mem[_43141 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _43141 + -mem[64] + 100
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _54403 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_54403] = 30
                                                    mem[_54403 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _56371 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_56371 + idx + 68] = mem[_54403 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_56371 + 68] = mem[_56371 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _56371 + -mem[64] + 100
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _34869 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34869] = 30
                                                mem[_34869 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    _35359 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35359 + idx + 68] = mem[_34869 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35359 + 68] = mem[_35359 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35359 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _38108 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38108] = 30
                                                mem[_38108 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _39771 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_39771 + idx + 68] = mem[_38108 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39771 + 68] = mem[_39771 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39771 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _43138 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43138] = 30
                                                mem[_43138 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _45679 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_45679 + idx + 68] = mem[_43138 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_45679 + 68] = mem[_45679 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _45679 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                _56370 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56370] = 30
                                                mem[_56370 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _58057 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_58057 + idx + 68] = mem[_56370 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58057 + 68] = mem[_58057 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58057 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                _34868 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34868] = 30
                                                mem[_34868 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    _35356 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35356 + idx + 68] = mem[_34868 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35356 + 68] = mem[_35356 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35356 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _38107 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38107] = 30
                                                mem[_38107 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _39768 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_39768 + idx + 68] = mem[_38107 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39768 + 68] = mem[_39768 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39768 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _43135 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43135] = 30
                                                mem[_43135 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _45676 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_45676 + idx + 68] = mem[_43135 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_45676 + 68] = mem[_45676 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _45676 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                _56369 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56369] = 30
                                                mem[_56369 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _58054 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_58054 + idx + 68] = mem[_56369 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58054 + 68] = mem[_58054 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58054 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35355 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35355] = 30
                                            mem[_35355 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                _36092 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36092 + idx + 68] = mem[_35355 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36092 + 68] = mem[_36092 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36092 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _39767 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39767] = 30
                                            mem[_39767 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _41886 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_41886 + idx + 68] = mem[_39767 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41886 + 68] = mem[_41886 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41886 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _45673 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45673] = 30
                                            mem[_45673 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _48240 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48240 + idx + 68] = mem[_45673 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48240 + 68] = mem[_48240 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48240 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            _58053 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58053] = 30
                                            mem[_58053 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _59294 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_59294 + idx + 68] = mem[_58053 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59294 + 68] = mem[_59294 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59294 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32352 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32352] = 30
                                            mem[_32352 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32524 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32524 + idx + 68] = mem[_32352 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32524 + 68] = mem[_32524 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32524 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33306 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33306] = 30
                                            mem[_33306 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33566 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33566 + idx + 68] = mem[_33306 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33566 + 68] = mem[_33566 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33566 + -mem[64] + 100
                                        _32414 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32414] = 26
                                        mem[_32414 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34870 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34870] = 30
                                                mem[_34870 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _38116 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38116] = 30
                                                mem[_38116 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _39781 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_39781 + idx + 68] = mem[_38116 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39781 + 68] = mem[_39781 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39781 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _43144 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43144] = 30
                                                mem[_43144 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _45691 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_45691 + idx + 68] = mem[_43144 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_45691 + 68] = mem[_45691 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _45691 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _56376 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56376] = 30
                                                mem[_56376 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _58064 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_58064 + idx + 68] = mem[_56376 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58064 + 68] = mem[_58064 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58064 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35363 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35363] = 30
                                            mem[_35363 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _36102 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36102 + idx + 68] = mem[_35363 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36102 + 68] = mem[_36102 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36102 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _39780 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39780] = 30
                                            mem[_39780 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _41900 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_41900 + idx + 68] = mem[_39780 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41900 + 68] = mem[_41900 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41900 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _45688 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45688] = 30
                                            mem[_45688 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _48258 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48258 + idx + 68] = mem[_45688 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48258 + 68] = mem[_48258 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48258 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _58063 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58063] = 30
                                            mem[_58063 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _59306 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_59306 + idx + 68] = mem[_58063 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59306 + 68] = mem[_59306 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59306 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _35362 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35362] = 30
                                            mem[_35362 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _36099 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36099 + idx + 68] = mem[_35362 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36099 + 68] = mem[_36099 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36099 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _39779 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39779] = 30
                                            mem[_39779 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _41897 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_41897 + idx + 68] = mem[_39779 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41897 + 68] = mem[_41897 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41897 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _45685 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45685] = 30
                                            mem[_45685 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _48255 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48255 + idx + 68] = mem[_45685 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48255 + 68] = mem[_48255 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48255 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _58062 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58062] = 30
                                            mem[_58062 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _59303 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_59303 + idx + 68] = mem[_58062 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59303 + 68] = mem[_59303 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59303 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _36098 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36098] = 30
                                        mem[_36098 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _37231 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37231 + idx + 68] = mem[_36098 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37231 + 68] = mem[_37231 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37231 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _41896 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41896] = 30
                                        mem[_41896 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _44232 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_44232 + idx + 68] = mem[_41896 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44232 + 68] = mem[_44232 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44232 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _48252 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48252] = 30
                                        mem[_48252 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _50465 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50465 + idx + 68] = mem[_48252 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50465 + 68] = mem[_50465 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50465 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _59302 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_59302] = 30
                                        mem[_59302 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _60268 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_60268 + idx + 68] = mem[_59302 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60268 + 68] = mem[_60268 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60268 + -mem[64] + 100
                                    _31766 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31766] = 26
                                    mem[_31766 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32687 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32687] = 26
                                        mem[_32687 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        _32686 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32686] = 26
                                        mem[_32686 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * t / s
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
    else:
        mem[0] = arg1
        mem[32] = 4
        if not stor4[address(arg1)]:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not arg2 / 100:
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 0 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow'
                idx = 0
                s = 1000 * 10^18
                t = stor6
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _32325 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32325] = 26
                        mem[_32325 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _34683 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34683] = 30
                            mem[_34683 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 2
                            _36791 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_36791] = 30
                            mem[_36791 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _38460 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_38460 + idx + 68] = mem[_36791 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_38460 + 68] = mem[_38460 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _38460 + -mem[64] + 100
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _41209 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_41209] = 30
                            mem[_41209 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _43487 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_43487 + idx + 68] = mem[_41209 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43487 + 68] = mem[_43487 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43487 + -mem[64] + 100
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _51819 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_51819] = 30
                            mem[_51819 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _53826 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_53826 + idx + 68] = mem[_51819 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_53826 + 68] = mem[_53826 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _53826 + -mem[64] + 100
                        require arg2
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _34961 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34961] = 30
                        mem[_34961 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 1000 * 10^18:
                            _35672 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_35672 + idx + 68] = mem[_34961 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_35672 + 68] = mem[_35672 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _35672 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 2
                        _38459 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_38459] = 30
                        mem[_38459 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _40564 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_40564 + idx + 68] = mem[_38459 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_40564 + 68] = mem[_40564 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _40564 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _43484 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_43484] = 30
                        mem[_43484 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _46238 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_46238 + idx + 68] = mem[_43484 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_46238 + 68] = mem[_46238 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _46238 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                        _53825 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_53825] = 30
                        mem[_53825 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _55854 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_55854 + idx + 68] = mem[_53825 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_55854 + 68] = mem[_55854 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _55854 + -mem[64] + 100
                    require idx < stor5.length
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _32389 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32389] = 30
                        mem[_32389 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _32635 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_32635 + idx + 68] = mem[_32389 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_32635 + 68] = mem[_32635 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _32635 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _33380 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33380] = 30
                        mem[_33380 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _33751 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_33751 + idx + 68] = mem[_33380 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_33751 + 68] = mem[_33751 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _33751 + -mem[64] + 100
                    _32451 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32451] = 26
                    mem[_32451 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        _34962 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34962] = 30
                        mem[_34962 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 2
                        _38465 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_38465] = 30
                        mem[_38465 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _40571 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_40571 + idx + 68] = mem[_38465 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_40571 + 68] = mem[_40571 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _40571 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _43490 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_43490] = 30
                        mem[_43490 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _46247 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_46247 + idx + 68] = mem[_43490 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_46247 + 68] = mem[_46247 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _46247 + -mem[64] + 100
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        _53830 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_53830] = 30
                        mem[_53830 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _55859 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_55859 + idx + 68] = mem[_53830 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_55859 + 68] = mem[_55859 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _55859 + -mem[64] + 100
                    require arg2
                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _35675 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35675] = 30
                    mem[_35675 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg2 * stor6 / 1000 * 10^18:
                        _36541 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_36541 + idx + 68] = mem[_35675 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_36541 + 68] = mem[_36541 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36541 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 2
                    _40570 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_40570] = 30
                    mem[_40570 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _42906 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_42906 + idx + 68] = mem[_40570 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_42906 + 68] = mem[_42906 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _42906 + -mem[64] + 100
                    stor2[address(msg.sender)] -= arg2
                    mem[0] = msg.sender
                    mem[32] = 1
                    _46244 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_46244] = 30
                    mem[_46244 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                        _49055 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_49055 + idx + 68] = mem[_46244 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_49055 + 68] = mem[_49055 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _49055 + -mem[64] + 100
                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                    _55858 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_55858] = 30
                    mem[_55858 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                        return 1
                    _57596 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_57596 + idx + 68] = mem[_55858 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_57596 + 68] = mem[_57596 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _57596 + -mem[64] + 100
                _31951 = mem[64]
                mem[64] = mem[64] + 64
                mem[_31951] = 26
                mem[_31951 + 32] = 'SafeMath: division by zero'
                if t < stor6 / 1000 * 10^18:
                    _32761 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32761] = 26
                    mem[_32761 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        require arg2
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if 0 > arg2 * stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                else:
                    _32760 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32760] = 26
                    mem[_32760 + 32] = 'SafeMath: division by zero'
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require s
                    if not arg2:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        require arg2
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if 0 > arg2 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * t / s > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] += arg2 * t / s
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow'
                if totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                emit Transfer(arg2, msg.sender, arg1);
            else:
                require arg2 / 100
                if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if arg2 / 100 * reflectFees > arg2:
                    revert with 0, 'SafeMath: subtraction overflow'
                idx = 0
                s = 1000 * 10^18
                t = stor6
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _32322 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32322] = 26
                        mem[_32322 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not arg2 / 100 * reflectFees:
                                _34682 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34682] = 30
                                mem[_34682 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 2
                                _36788 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36788] = 30
                                mem[_36788 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _38451 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_38451 + idx + 68] = mem[_36788 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38451 + 68] = mem[_38451 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38451 + -mem[64] + 100
                                stor2[address(msg.sender)] -= arg2
                                mem[0] = msg.sender
                                mem[32] = 1
                                _41200 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41200] = 30
                                mem[_41200 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _43478 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_43478 + idx + 68] = mem[_41200 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43478 + 68] = mem[_43478 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43478 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _51808 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51808] = 30
                                mem[_51808 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _53811 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_53811 + idx + 68] = mem[_51808 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53811 + 68] = mem[_53811 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53811 + -mem[64] + 100
                            require arg2 / 100 * reflectFees
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _34959 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34959] = 30
                            mem[_34959 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                _35665 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_35665 + idx + 68] = mem[_34959 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35665 + 68] = mem[_35665 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35665 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 2
                            _38450 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38450] = 30
                            mem[_38450 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _40545 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_40545 + idx + 68] = mem[_38450 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_40545 + 68] = mem[_40545 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _40545 + -mem[64] + 100
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _43475 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_43475] = 30
                            mem[_43475 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _46217 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_46217 + idx + 68] = mem[_43475 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_46217 + 68] = mem[_46217 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _46217 + -mem[64] + 100
                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            _53810 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53810] = 30
                            mem[_53810 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                return 1
                            _55840 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_55840 + idx + 68] = mem[_53810 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_55840 + 68] = mem[_55840 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55840 + -mem[64] + 100
                        require arg2
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not arg2 / 100 * reflectFees:
                            _34958 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34958] = 30
                            mem[_34958 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _35662 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_35662 + idx + 68] = mem[_34958 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35662 + 68] = mem[_35662 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _35662 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 2
                            _38449 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38449] = 30
                            mem[_38449 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _40542 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_40542 + idx + 68] = mem[_38449 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_40542 + 68] = mem[_40542 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _40542 + -mem[64] + 100
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _43472 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_43472] = 30
                            mem[_43472 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _46214 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_46214 + idx + 68] = mem[_43472 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_46214 + 68] = mem[_46214 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _46214 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            _53809 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53809] = 30
                            mem[_53809 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                return 1
                            _55837 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_55837 + idx + 68] = mem[_53809 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_55837 + 68] = mem[_55837 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55837 + -mem[64] + 100
                        require arg2 / 100 * reflectFees
                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _35661 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35661] = 30
                        mem[_35661 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                            _36524 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_36524 + idx + 68] = mem[_35661 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_36524 + 68] = mem[_36524 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36524 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 2
                        _40541 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_40541] = 30
                        mem[_40541 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _42874 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_42874 + idx + 68] = mem[_40541 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_42874 + 68] = mem[_42874 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _42874 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _46211 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_46211] = 30
                        mem[_46211 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _49013 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_49013 + idx + 68] = mem[_46211 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_49013 + 68] = mem[_49013 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _49013 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                        _55836 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_55836] = 30
                        mem[_55836 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100 * reflectFees
                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                            return 1
                        _57568 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_57568 + idx + 68] = mem[_55836 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_57568 + 68] = mem[_57568 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _57568 + -mem[64] + 100
                    require idx < stor5.length
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _32388 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32388] = 30
                        mem[_32388 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _32632 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_32632 + idx + 68] = mem[_32388 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_32632 + 68] = mem[_32632 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _32632 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _33378 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33378] = 30
                        mem[_33378 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _33746 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_33746 + idx + 68] = mem[_33378 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_33746 + 68] = mem[_33746 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _33746 + -mem[64] + 100
                    _32450 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32450] = 26
                    mem[_32450 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if not arg2 / 100 * reflectFees:
                            _34960 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34960] = 30
                            mem[_34960 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 2
                            _38458 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38458] = 30
                            mem[_38458 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _40555 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_40555 + idx + 68] = mem[_38458 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_40555 + 68] = mem[_40555 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _40555 + -mem[64] + 100
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _43481 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_43481] = 30
                            mem[_43481 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _46229 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_46229 + idx + 68] = mem[_43481 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_46229 + 68] = mem[_46229 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _46229 + -mem[64] + 100
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _53818 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53818] = 30
                            mem[_53818 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                return 1
                            _55847 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_55847 + idx + 68] = mem[_53818 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_55847 + 68] = mem[_55847 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55847 + -mem[64] + 100
                        require arg2 / 100 * reflectFees
                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _35669 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35669] = 30
                        mem[_35669 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                            _36534 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_36534 + idx + 68] = mem[_35669 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_36534 + 68] = mem[_36534 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36534 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 2
                        _40554 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_40554] = 30
                        mem[_40554 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _42888 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_42888 + idx + 68] = mem[_40554 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_42888 + 68] = mem[_42888 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _42888 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _46226 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_46226] = 30
                        mem[_46226 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _49031 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_49031 + idx + 68] = mem[_46226 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_49031 + 68] = mem[_49031 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _49031 + -mem[64] + 100
                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                        _55846 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_55846] = 30
                        mem[_55846 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100 * reflectFees
                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                            return 1
                        _57580 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_57580 + idx + 68] = mem[_55846 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_57580 + 68] = mem[_57580 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _57580 + -mem[64] + 100
                    require arg2
                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not arg2 / 100 * reflectFees:
                        _35668 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35668] = 30
                        mem[_35668 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 1000 * 10^18:
                            _36531 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_36531 + idx + 68] = mem[_35668 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_36531 + 68] = mem[_36531 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36531 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 2
                        _40553 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_40553] = 30
                        mem[_40553 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _42885 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_42885 + idx + 68] = mem[_40553 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_42885 + 68] = mem[_42885 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _42885 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _46223 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_46223] = 30
                        mem[_46223 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _49028 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_49028 + idx + 68] = mem[_46223 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_49028 + 68] = mem[_49028 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _49028 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                        _55845 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_55845] = 30
                        mem[_55845 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100 * reflectFees
                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                            return 1
                        _57577 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_57577 + idx + 68] = mem[_55845 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_57577 + 68] = mem[_57577 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _57577 + -mem[64] + 100
                    require arg2 / 100 * reflectFees
                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _36530 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_36530] = 30
                    mem[_36530 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                        _37861 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_37861 + idx + 68] = mem[_36530 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_37861 + 68] = mem[_37861 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _37861 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 2
                    _42884 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_42884] = 30
                    mem[_42884 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _45298 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_45298 + idx + 68] = mem[_42884 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_45298 + 68] = mem[_45298 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _45298 + -mem[64] + 100
                    stor2[address(msg.sender)] -= arg2
                    mem[0] = msg.sender
                    mem[32] = 1
                    _49025 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_49025] = 30
                    mem[_49025 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                        _51259 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_51259 + idx + 68] = mem[_49025 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_51259 + 68] = mem[_51259 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _51259 + -mem[64] + 100
                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                    _57576 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_57576] = 30
                    mem[_57576 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg2 / 100 * reflectFees
                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                        return 1
                    _58941 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_58941 + idx + 68] = mem[_57576 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_58941 + 68] = mem[_58941 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _58941 + -mem[64] + 100
                _31946 = mem[64]
                mem[64] = mem[64] + 64
                mem[_31946] = 26
                mem[_31946 + 32] = 'SafeMath: division by zero'
                if t < stor6 / 1000 * 10^18:
                    _32759 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32759] = 26
                    mem[_32759 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if not arg2 / 100 * reflectFees:
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require arg2 / 100 * reflectFees
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                    else:
                        require arg2
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not arg2 / 100 * reflectFees:
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require arg2 / 100 * reflectFees
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                else:
                    _32758 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32758] = 26
                    mem[_32758 + 32] = 'SafeMath: division by zero'
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require s
                    if not arg2:
                        if not arg2 / 100 * reflectFees:
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require arg2 / 100 * reflectFees
                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if arg2 / 100 * reflectFees * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                            if arg2 / 100 * reflectFees * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                    else:
                        require arg2
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not arg2 / 100 * reflectFees:
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require arg2 / 100 * reflectFees
                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                            if arg2 / 100 * reflectFees * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg2 / 100 * reflectFees
                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
        else:
            if stor4[address(msg.sender)]:
                if stor4[address(msg.sender)]:
                    mem[0] = msg.sender
                    mem[32] = 4
                    if not stor4[address(msg.sender)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32235 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32235] = 26
                                    mem[_32235 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34653 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34653] = 30
                                        mem[_34653 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _36671 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36671] = 30
                                        mem[_36671 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _38175 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38175 + idx + 68] = mem[_36671 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38175 + 68] = mem[_38175 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38175 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _45784 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45784] = 30
                                        mem[_45784 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _48389 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_48389 + idx + 68] = mem[_45784 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_48389 + 68] = mem[_48389 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _48389 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34886 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34886] = 30
                                    mem[_34886 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35417 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35417 + idx + 68] = mem[_34886 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35417 + 68] = mem[_35417 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35417 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38174 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38174] = 30
                                    mem[_38174 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _39919 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39919 + idx + 68] = mem[_38174 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39919 + 68] = mem[_39919 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39919 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _48388 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48388] = 30
                                    mem[_48388 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50596 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50596 + idx + 68] = mem[_48388 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50596 + 68] = mem[_50596 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50596 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32359 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32359] = 30
                                    mem[_32359 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32545 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32545 + idx + 68] = mem[_32359 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32545 + 68] = mem[_32545 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32545 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33320 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33320] = 30
                                    mem[_33320 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33601 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33601 + idx + 68] = mem[_33320 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33601 + 68] = mem[_33601 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33601 + -mem[64] + 100
                                _32421 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32421] = 26
                                mem[_32421 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _34887 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34887] = 30
                                    mem[_34887 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38180 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38180] = 30
                                    mem[_38180 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _39926 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_39926 + idx + 68] = mem[_38180 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39926 + 68] = mem[_39926 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39926 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _48393 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48393] = 30
                                    mem[_48393 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50601 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50601 + idx + 68] = mem[_48393 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50601 + 68] = mem[_50601 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50601 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35420 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35420] = 30
                                mem[_35420 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _36181 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36181 + idx + 68] = mem[_35420 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36181 + 68] = mem[_36181 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36181 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _39925 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_39925] = 30
                                mem[_39925 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _42086 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_42086 + idx + 68] = mem[_39925 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42086 + 68] = mem[_42086 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42086 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _50600 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50600] = 30
                                mem[_50600 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _52533 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_52533 + idx + 68] = mem[_50600 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52533 + 68] = mem[_52533 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52533 + -mem[64] + 100
                            _31801 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31801] = 26
                            mem[_31801 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32701 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32701] = 26
                                mem[_32701 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            else:
                                _32700 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32700] = 26
                                mem[_32700 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32232 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32232] = 26
                                    mem[_32232 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34652 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34652] = 30
                                            mem[_34652 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36668 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36668] = 30
                                            mem[_36668 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _38166 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38166 + idx + 68] = mem[_36668 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38166 + 68] = mem[_38166 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38166 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45773 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45773] = 30
                                            mem[_45773 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _48374 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48374 + idx + 68] = mem[_45773 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48374 + 68] = mem[_48374 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48374 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34884 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34884] = 30
                                        mem[_34884 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _35410 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35410 + idx + 68] = mem[_34884 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35410 + 68] = mem[_35410 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35410 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38165 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38165] = 30
                                        mem[_38165 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39900 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39900 + idx + 68] = mem[_38165 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39900 + 68] = mem[_39900 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39900 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _48373 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48373] = 30
                                        mem[_48373 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50582 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50582 + idx + 68] = mem[_48373 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50582 + 68] = mem[_50582 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50582 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _34883 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34883] = 30
                                        mem[_34883 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35407 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35407 + idx + 68] = mem[_34883 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35407 + 68] = mem[_35407 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35407 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38164 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38164] = 30
                                        mem[_38164 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _39897 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39897 + idx + 68] = mem[_38164 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39897 + 68] = mem[_39897 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39897 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _48372 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48372] = 30
                                        mem[_48372 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50579 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50579 + idx + 68] = mem[_48372 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50579 + 68] = mem[_50579 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50579 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35406 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35406] = 30
                                    mem[_35406 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _36164 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36164 + idx + 68] = mem[_35406 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36164 + 68] = mem[_36164 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36164 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39896 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39896] = 30
                                    mem[_39896 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _42050 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_42050 + idx + 68] = mem[_39896 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42050 + 68] = mem[_42050 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42050 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _50578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50578] = 30
                                    mem[_50578 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52505 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52505 + idx + 68] = mem[_50578 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52505 + 68] = mem[_52505 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52505 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32358 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32358] = 30
                                    mem[_32358 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32542 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32542 + idx + 68] = mem[_32358 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32542 + 68] = mem[_32542 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32542 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33318 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33318] = 30
                                    mem[_33318 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33596 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33596 + idx + 68] = mem[_33318 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33596 + 68] = mem[_33596 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33596 + -mem[64] + 100
                                _32420 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32420] = 26
                                mem[_32420 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        _34885 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34885] = 30
                                        mem[_34885 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38173 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38173] = 30
                                        mem[_38173 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39910 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39910 + idx + 68] = mem[_38173 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39910 + 68] = mem[_39910 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39910 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _48381 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48381] = 30
                                        mem[_48381 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50589 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50589 + idx + 68] = mem[_48381 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50589 + 68] = mem[_50589 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50589 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35414 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35414] = 30
                                    mem[_35414 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        _36174 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36174 + idx + 68] = mem[_35414 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36174 + 68] = mem[_36174 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36174 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39909 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39909] = 30
                                    mem[_39909 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _42066 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_42066 + idx + 68] = mem[_39909 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42066 + 68] = mem[_42066 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42066 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    _50588 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50588] = 30
                                    mem[_50588 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52517 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52517 + idx + 68] = mem[_50588 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52517 + 68] = mem[_52517 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52517 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    _35413 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35413] = 30
                                    mem[_35413 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _36171 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36171 + idx + 68] = mem[_35413 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36171 + 68] = mem[_36171 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36171 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39908] = 30
                                    mem[_39908 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _42063 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_42063 + idx + 68] = mem[_39908 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42063 + 68] = mem[_42063 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42063 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _50587 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50587] = 30
                                    mem[_50587 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52514 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52514 + idx + 68] = mem[_50587 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52514 + 68] = mem[_52514 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52514 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36170 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36170] = 30
                                mem[_36170 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _37336 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_37336 + idx + 68] = mem[_36170 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37336 + 68] = mem[_37336 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37336 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _42062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42062] = 30
                                mem[_42062 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _44412 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_44412 + idx + 68] = mem[_42062 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44412 + 68] = mem[_44412 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44412 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                _52513 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52513] = 30
                                mem[_52513 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _54500 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_54500 + idx + 68] = mem[_52513 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54500 + 68] = mem[_54500 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54500 + -mem[64] + 100
                            _31796 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31796] = 26
                            mem[_31796 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32699 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32699] = 26
                                mem[_32699 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            else:
                                _32698 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32698] = 26
                                mem[_32698 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100 * reflectFees
                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not stor4[address(arg1)]:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32241 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32241] = 26
                                        mem[_32241 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34655 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34655] = 30
                                            mem[_34655 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36679 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36679] = 30
                                            mem[_36679 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _38194 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38194 + idx + 68] = mem[_36679 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38194 + 68] = mem[_38194 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38194 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45807 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45807] = 30
                                            mem[_45807 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _48422 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48422 + idx + 68] = mem[_45807 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48422 + 68] = mem[_48422 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48422 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34891 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34891] = 30
                                        mem[_34891 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35434 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35434 + idx + 68] = mem[_34891 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35434 + 68] = mem[_35434 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35434 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38193 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38193] = 30
                                        mem[_38193 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _39962 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39962 + idx + 68] = mem[_38193 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39962 + 68] = mem[_39962 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39962 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _48421 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48421] = 30
                                        mem[_48421 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50632 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50632 + idx + 68] = mem[_48421 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50632 + 68] = mem[_50632 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50632 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32361 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32361] = 30
                                        mem[_32361 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32551 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32551 + idx + 68] = mem[_32361 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32551 + 68] = mem[_32551 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32551 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33324 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33324] = 30
                                        mem[_33324 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33611 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33611 + idx + 68] = mem[_33324 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33611 + 68] = mem[_33611 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33611 + -mem[64] + 100
                                    _32423 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32423] = 26
                                    mem[_32423 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34892 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34892] = 30
                                        mem[_34892 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38199 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38199] = 30
                                        mem[_38199 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _39969 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_39969 + idx + 68] = mem[_38199 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39969 + 68] = mem[_39969 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39969 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _48426 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48426] = 30
                                        mem[_48426 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50637 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50637 + idx + 68] = mem[_48426 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50637 + 68] = mem[_50637 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50637 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35437 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35437] = 30
                                    mem[_35437 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _36205 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36205 + idx + 68] = mem[_35437 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36205 + 68] = mem[_36205 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36205 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _39968 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39968] = 30
                                    mem[_39968 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _42142 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_42142 + idx + 68] = mem[_39968 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42142 + 68] = mem[_42142 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42142 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _50636 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50636] = 30
                                    mem[_50636 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52577 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52577 + idx + 68] = mem[_50636 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52577 + 68] = mem[_52577 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52577 + -mem[64] + 100
                                _31811 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31811] = 26
                                mem[_31811 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32705 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32705] = 26
                                    mem[_32705 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                else:
                                    _32704 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32704] = 26
                                    mem[_32704 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32238 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32238] = 26
                                        mem[_32238 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34654 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34654] = 30
                                                mem[_34654 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _36676 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36676] = 30
                                                mem[_36676 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _38185 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38185 + idx + 68] = mem[_36676 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38185 + 68] = mem[_38185 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38185 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _45796 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45796] = 30
                                                mem[_45796 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _48407 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48407 + idx + 68] = mem[_45796 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48407 + 68] = mem[_48407 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48407 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34889 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34889] = 30
                                            mem[_34889 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _35427 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35427 + idx + 68] = mem[_34889 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35427 + 68] = mem[_35427 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35427 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38184 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38184] = 30
                                            mem[_38184 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _39943 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39943 + idx + 68] = mem[_38184 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39943 + 68] = mem[_39943 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39943 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _48406 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48406] = 30
                                            mem[_48406 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50618 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50618 + idx + 68] = mem[_48406 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50618 + 68] = mem[_50618 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50618 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _34888 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34888] = 30
                                            mem[_34888 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35424 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35424 + idx + 68] = mem[_34888 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35424 + 68] = mem[_35424 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35424 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38183 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38183] = 30
                                            mem[_38183 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _39940 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39940 + idx + 68] = mem[_38183 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39940 + 68] = mem[_39940 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39940 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _48405 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48405] = 30
                                            mem[_48405 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50615 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50615 + idx + 68] = mem[_48405 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50615 + 68] = mem[_50615 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50615 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35423 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35423] = 30
                                        mem[_35423 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _36188 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36188 + idx + 68] = mem[_35423 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36188 + 68] = mem[_36188 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36188 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39939 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39939] = 30
                                        mem[_39939 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _42106 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42106 + idx + 68] = mem[_39939 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42106 + 68] = mem[_42106 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42106 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _50614 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50614] = 30
                                        mem[_50614 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52549 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52549 + idx + 68] = mem[_50614 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52549 + 68] = mem[_52549 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52549 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32360 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32360] = 30
                                        mem[_32360 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32548 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32548 + idx + 68] = mem[_32360 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32548 + 68] = mem[_32548 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32548 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33322 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33322] = 30
                                        mem[_33322 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33606 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33606 + idx + 68] = mem[_33322 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33606 + 68] = mem[_33606 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33606 + -mem[64] + 100
                                    _32422 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32422] = 26
                                    mem[_32422 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34890 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34890] = 30
                                            mem[_34890 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38192 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38192] = 30
                                            mem[_38192 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _39953 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39953 + idx + 68] = mem[_38192 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39953 + 68] = mem[_39953 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39953 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _48414 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48414] = 30
                                            mem[_48414 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50625 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50625 + idx + 68] = mem[_48414 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50625 + 68] = mem[_50625 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50625 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35431 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35431] = 30
                                        mem[_35431 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _36198 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36198 + idx + 68] = mem[_35431 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36198 + 68] = mem[_36198 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36198 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39952 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39952] = 30
                                        mem[_39952 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _42122 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42122 + idx + 68] = mem[_39952 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42122 + 68] = mem[_42122 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42122 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _50624 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50624] = 30
                                        mem[_50624 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52561 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52561 + idx + 68] = mem[_50624 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52561 + 68] = mem[_52561 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52561 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _35430 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35430] = 30
                                        mem[_35430 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36195 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36195 + idx + 68] = mem[_35430 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36195 + 68] = mem[_36195 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36195 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _39951 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39951] = 30
                                        mem[_39951 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _42119 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42119 + idx + 68] = mem[_39951 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42119 + 68] = mem[_42119 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42119 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _50623 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50623] = 30
                                        mem[_50623 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52558 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52558 + idx + 68] = mem[_50623 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52558 + 68] = mem[_52558 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52558 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36194 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36194] = 30
                                    mem[_36194 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _37371 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_37371 + idx + 68] = mem[_36194 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37371 + 68] = mem[_37371 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37371 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _42118 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42118] = 30
                                    mem[_42118 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _44474 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_44474 + idx + 68] = mem[_42118 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44474 + 68] = mem[_44474 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44474 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _52557 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52557] = 30
                                    mem[_52557 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _54550 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_54550 + idx + 68] = mem[_52557 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54550 + 68] = mem[_54550 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54550 + -mem[64] + 100
                                _31806 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31806] = 26
                                mem[_31806 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32703 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32703] = 26
                                    mem[_32703 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    _32702 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32702] = 26
                                    mem[_32702 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                        else:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32247 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32247] = 26
                                        mem[_32247 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34657 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34657] = 30
                                            mem[_34657 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _36687 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36687] = 30
                                            mem[_36687 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _38213 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38213 + idx + 68] = mem[_36687 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38213 + 68] = mem[_38213 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38213 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40941 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40941] = 30
                                            mem[_40941 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _43241 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_43241 + idx + 68] = mem[_40941 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43241 + 68] = mem[_43241 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43241 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _54607 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_54607] = 30
                                            mem[_54607 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _56556 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_56556 + idx + 68] = mem[_54607 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_56556 + 68] = mem[_56556 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _56556 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34896 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34896] = 30
                                        mem[_34896 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35451 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35451 + idx + 68] = mem[_34896 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35451 + 68] = mem[_35451 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35451 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _38212 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38212] = 30
                                        mem[_38212 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _40005 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_40005 + idx + 68] = mem[_38212 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40005 + 68] = mem[_40005 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40005 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _43238 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43238] = 30
                                        mem[_43238 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _45844 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_45844 + idx + 68] = mem[_43238 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45844 + 68] = mem[_45844 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45844 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _56555 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_56555] = 30
                                        mem[_56555 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _58236 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_58236 + idx + 68] = mem[_56555 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_58236 + 68] = mem[_58236 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _58236 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32363 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32363] = 30
                                        mem[_32363 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32557 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32557 + idx + 68] = mem[_32363 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32557 + 68] = mem[_32557 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32557 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33328 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33328] = 30
                                        mem[_33328 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33621 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33621 + idx + 68] = mem[_33328 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33621 + 68] = mem[_33621 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33621 + -mem[64] + 100
                                    _32425 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32425] = 26
                                    mem[_32425 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34897 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34897] = 30
                                        mem[_34897 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _38218 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38218] = 30
                                        mem[_38218 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _40012 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_40012 + idx + 68] = mem[_38218 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40012 + 68] = mem[_40012 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40012 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _43244 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43244] = 30
                                        mem[_43244 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _45853 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_45853 + idx + 68] = mem[_43244 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45853 + 68] = mem[_45853 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45853 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _56560 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_56560] = 30
                                        mem[_56560 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _58241 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_58241 + idx + 68] = mem[_56560 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_58241 + 68] = mem[_58241 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _58241 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35454 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35454] = 30
                                    mem[_35454 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _36229 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36229 + idx + 68] = mem[_35454 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36229 + 68] = mem[_36229 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36229 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _40011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40011] = 30
                                    mem[_40011 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _42194 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_42194 + idx + 68] = mem[_40011 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42194 + 68] = mem[_42194 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42194 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _45850 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_45850] = 30
                                    mem[_45850 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _48487 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_48487 + idx + 68] = mem[_45850 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_48487 + 68] = mem[_48487 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _48487 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _58240 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_58240] = 30
                                    mem[_58240 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _59444 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_59444 + idx + 68] = mem[_58240 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59444 + 68] = mem[_59444 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59444 + -mem[64] + 100
                                _31821 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31821] = 26
                                mem[_31821 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32709 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32709] = 26
                                    mem[_32709 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                else:
                                    _32708 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32708] = 26
                                    mem[_32708 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor2[address(msg.sender)] -= arg2
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32244 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32244] = 26
                                        mem[_32244 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34656 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34656] = 30
                                                mem[_34656 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _36684 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36684] = 30
                                                mem[_36684 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _38204 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38204 + idx + 68] = mem[_36684 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38204 + 68] = mem[_38204 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38204 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _40932 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40932] = 30
                                                mem[_40932 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _43232 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_43232 + idx + 68] = mem[_40932 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43232 + 68] = mem[_43232 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43232 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _54595 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_54595] = 30
                                                mem[_54595 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _56547 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_56547 + idx + 68] = mem[_54595 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_56547 + 68] = mem[_56547 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _56547 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34894 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34894] = 30
                                            mem[_34894 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _35444 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35444 + idx + 68] = mem[_34894 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35444 + 68] = mem[_35444 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35444 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38203 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38203] = 30
                                            mem[_38203 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _39986 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39986 + idx + 68] = mem[_38203 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39986 + 68] = mem[_39986 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39986 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43229 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43229] = 30
                                            mem[_43229 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _45823 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45823 + idx + 68] = mem[_43229 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45823 + 68] = mem[_45823 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45823 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _56546 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56546] = 30
                                            mem[_56546 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _58222 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_58222 + idx + 68] = mem[_56546 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58222 + 68] = mem[_58222 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58222 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _34893 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34893] = 30
                                            mem[_34893 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35441 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35441 + idx + 68] = mem[_34893 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35441 + 68] = mem[_35441 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35441 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38202 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38202] = 30
                                            mem[_38202 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _39983 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39983 + idx + 68] = mem[_38202 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39983 + 68] = mem[_39983 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39983 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43226 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43226] = 30
                                            mem[_43226 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _45820 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45820 + idx + 68] = mem[_43226 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45820 + 68] = mem[_45820 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45820 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _56545 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56545] = 30
                                            mem[_56545 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _58219 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_58219 + idx + 68] = mem[_56545 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58219 + 68] = mem[_58219 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58219 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35440 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35440] = 30
                                        mem[_35440 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _36212 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36212 + idx + 68] = mem[_35440 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36212 + 68] = mem[_36212 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36212 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _39982 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39982] = 30
                                        mem[_39982 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _42162 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42162 + idx + 68] = mem[_39982 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42162 + 68] = mem[_42162 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42162 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _45817 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45817] = 30
                                        mem[_45817 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _48445 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48445 + idx + 68] = mem[_45817 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48445 + 68] = mem[_48445 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48445 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _58218 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58218] = 30
                                        mem[_58218 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _59416 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59416 + idx + 68] = mem[_58218 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59416 + 68] = mem[_59416 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59416 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32362 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32362] = 30
                                        mem[_32362 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32554 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32554 + idx + 68] = mem[_32362 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32554 + 68] = mem[_32554 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32554 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33326 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33326] = 30
                                        mem[_33326 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33616 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33616 + idx + 68] = mem[_33326 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33616 + 68] = mem[_33616 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33616 + -mem[64] + 100
                                    _32424 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32424] = 26
                                    mem[_32424 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34895 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34895] = 30
                                            mem[_34895 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38211 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38211] = 30
                                            mem[_38211 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _39996 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_39996 + idx + 68] = mem[_38211 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39996 + 68] = mem[_39996 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39996 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43235 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43235] = 30
                                            mem[_43235 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _45835 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45835 + idx + 68] = mem[_43235 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45835 + 68] = mem[_45835 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45835 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _56552 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56552] = 30
                                            mem[_56552 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _58229 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_58229 + idx + 68] = mem[_56552 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58229 + 68] = mem[_58229 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58229 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35448 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35448] = 30
                                        mem[_35448 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _36222 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36222 + idx + 68] = mem[_35448 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36222 + 68] = mem[_36222 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36222 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _39995 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39995] = 30
                                        mem[_39995 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _42176 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42176 + idx + 68] = mem[_39995 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42176 + 68] = mem[_42176 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42176 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _45832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45832] = 30
                                        mem[_45832 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _48463 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48463 + idx + 68] = mem[_45832 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48463 + 68] = mem[_48463 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48463 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _58228 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58228] = 30
                                        mem[_58228 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _59428 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59428 + idx + 68] = mem[_58228 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59428 + 68] = mem[_59428 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59428 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _35447 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35447] = 30
                                        mem[_35447 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36219 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36219 + idx + 68] = mem[_35447 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36219 + 68] = mem[_36219 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36219 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _39994 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39994] = 30
                                        mem[_39994 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _42173 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42173 + idx + 68] = mem[_39994 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42173 + 68] = mem[_42173 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42173 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _45829 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45829] = 30
                                        mem[_45829 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _48460 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48460 + idx + 68] = mem[_45829 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48460 + 68] = mem[_48460 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48460 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _58227 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58227] = 30
                                        mem[_58227 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _59425 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59425 + idx + 68] = mem[_58227 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59425 + 68] = mem[_59425 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59425 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36218 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36218] = 30
                                    mem[_36218 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _37406 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_37406 + idx + 68] = mem[_36218 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37406 + 68] = mem[_37406 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37406 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 2
                                    _42172 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42172] = 30
                                    mem[_42172 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor2[address(msg.sender)]:
                                        _44532 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_44532 + idx + 68] = mem[_42172 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44532 + 68] = mem[_44532 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44532 + -mem[64] + 100
                                    stor2[address(msg.sender)] -= arg2
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _48457 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48457] = 30
                                    mem[_48457 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _50673 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50673 + idx + 68] = mem[_48457 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50673 + 68] = mem[_50673 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50673 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _59424 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_59424] = 30
                                    mem[_59424 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _60348 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_60348 + idx + 68] = mem[_59424 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_60348 + 68] = mem[_60348 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _60348 + -mem[64] + 100
                                _31816 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31816] = 26
                                mem[_31816 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32707 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32707] = 26
                                    mem[_32707 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    _32706 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32706] = 26
                                    mem[_32706 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    if not stor4[address(arg1)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32271 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32271] = 26
                                    mem[_32271 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34665 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34665] = 30
                                        mem[_34665 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _36719 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36719] = 30
                                        mem[_36719 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _38289 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38289 + idx + 68] = mem[_36719 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38289 + 68] = mem[_38289 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38289 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _45966 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45966] = 30
                                        mem[_45966 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _48653 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_48653 + idx + 68] = mem[_45966 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_48653 + 68] = mem[_48653 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _48653 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34916 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34916] = 30
                                    mem[_34916 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35519 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35519 + idx + 68] = mem[_34916 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35519 + 68] = mem[_35519 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35519 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38288 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38288] = 30
                                    mem[_38288 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _40177 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_40177 + idx + 68] = mem[_38288 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40177 + 68] = mem[_40177 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40177 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _48652 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48652] = 30
                                    mem[_48652 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50872 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50872 + idx + 68] = mem[_48652 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50872 + 68] = mem[_50872 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50872 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32371 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32371] = 30
                                    mem[_32371 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32581 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32581 + idx + 68] = mem[_32371 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32581 + 68] = mem[_32581 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32581 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33344 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33344] = 30
                                    mem[_33344 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33661 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33661 + idx + 68] = mem[_33344 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33661 + 68] = mem[_33661 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33661 + -mem[64] + 100
                                _32433 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32433] = 26
                                mem[_32433 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _34917 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34917] = 30
                                    mem[_34917 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38294 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38294] = 30
                                    mem[_38294 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _40184 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_40184 + idx + 68] = mem[_38294 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40184 + 68] = mem[_40184 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40184 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _48657 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48657] = 30
                                    mem[_48657 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50877 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_50877 + idx + 68] = mem[_48657 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50877 + 68] = mem[_50877 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50877 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35522 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35522] = 30
                                mem[_35522 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _36325 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36325 + idx + 68] = mem[_35522 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36325 + 68] = mem[_36325 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36325 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _40183 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40183] = 30
                                mem[_40183 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _42414 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_42414 + idx + 68] = mem[_40183 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42414 + 68] = mem[_42414 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42414 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _50876 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50876] = 30
                                mem[_50876 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _52815 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_52815 + idx + 68] = mem[_50876 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52815 + 68] = mem[_52815 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52815 + -mem[64] + 100
                            _31861 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31861] = 26
                            mem[_31861 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32725 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32725] = 26
                                mem[_32725 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            else:
                                _32724 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32724] = 26
                                mem[_32724 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _32268 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32268] = 26
                                    mem[_32268 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34664 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34664] = 30
                                            mem[_34664 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36716 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36716] = 30
                                            mem[_36716 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _38280 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38280 + idx + 68] = mem[_36716 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38280 + 68] = mem[_38280 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38280 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45955 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45955] = 30
                                            mem[_45955 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _48638 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48638 + idx + 68] = mem[_45955 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48638 + 68] = mem[_48638 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48638 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34914 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34914] = 30
                                        mem[_34914 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _35512 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35512 + idx + 68] = mem[_34914 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35512 + 68] = mem[_35512 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35512 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38279 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38279] = 30
                                        mem[_38279 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _40158 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_40158 + idx + 68] = mem[_38279 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40158 + 68] = mem[_40158 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40158 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _48637 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48637] = 30
                                        mem[_48637 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50858 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50858 + idx + 68] = mem[_48637 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50858 + 68] = mem[_50858 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50858 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _34913 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34913] = 30
                                        mem[_34913 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35509 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35509 + idx + 68] = mem[_34913 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35509 + 68] = mem[_35509 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35509 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38278 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38278] = 30
                                        mem[_38278 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _40155 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_40155 + idx + 68] = mem[_38278 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40155 + 68] = mem[_40155 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40155 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _48636 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48636] = 30
                                        mem[_48636 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50855 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50855 + idx + 68] = mem[_48636 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50855 + 68] = mem[_50855 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50855 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35508 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35508] = 30
                                    mem[_35508 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _36308 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36308 + idx + 68] = mem[_35508 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36308 + 68] = mem[_36308 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36308 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _40154 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40154] = 30
                                    mem[_40154 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _42378 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_42378 + idx + 68] = mem[_40154 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42378 + 68] = mem[_42378 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42378 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _50854 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50854] = 30
                                    mem[_50854 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52787 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52787 + idx + 68] = mem[_50854 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52787 + 68] = mem[_52787 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52787 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _32370 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32370] = 30
                                    mem[_32370 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _32578 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_32578 + idx + 68] = mem[_32370 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32578 + 68] = mem[_32578 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _32578 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _33342 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33342] = 30
                                    mem[_33342 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _33656 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_33656 + idx + 68] = mem[_33342 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33656 + 68] = mem[_33656 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33656 + -mem[64] + 100
                                _32432 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32432] = 26
                                mem[_32432 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        _34915 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34915] = 30
                                        mem[_34915 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38287 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38287] = 30
                                        mem[_38287 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _40168 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_40168 + idx + 68] = mem[_38287 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40168 + 68] = mem[_40168 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40168 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _48645 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48645] = 30
                                        mem[_48645 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _50865 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50865 + idx + 68] = mem[_48645 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50865 + 68] = mem[_50865 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50865 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35516 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35516] = 30
                                    mem[_35516 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        _36318 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36318 + idx + 68] = mem[_35516 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36318 + 68] = mem[_36318 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36318 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _40167 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40167] = 30
                                    mem[_40167 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _42394 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_42394 + idx + 68] = mem[_40167 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42394 + 68] = mem[_42394 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42394 + -mem[64] + 100
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    _50864 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50864] = 30
                                    mem[_50864 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52799 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52799 + idx + 68] = mem[_50864 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52799 + 68] = mem[_52799 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52799 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    _35515 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35515] = 30
                                    mem[_35515 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _36315 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36315 + idx + 68] = mem[_35515 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36315 + 68] = mem[_36315 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36315 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _40166 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40166] = 30
                                    mem[_40166 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _42391 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_42391 + idx + 68] = mem[_40166 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42391 + 68] = mem[_42391 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42391 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _50863 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50863] = 30
                                    mem[_50863 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _52796 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52796 + idx + 68] = mem[_50863 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52796 + 68] = mem[_52796 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52796 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36314 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36314] = 30
                                mem[_36314 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _37546 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_37546 + idx + 68] = mem[_36314 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_37546 + 68] = mem[_37546 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _37546 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _42390 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42390] = 30
                                mem[_42390 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _44764 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_44764 + idx + 68] = mem[_42390 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44764 + 68] = mem[_44764 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44764 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                _52795 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52795] = 30
                                mem[_52795 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _54768 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_54768 + idx + 68] = mem[_52795 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54768 + 68] = mem[_54768 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54768 + -mem[64] + 100
                            _31856 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31856] = 26
                            mem[_31856 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 1000 * 10^18:
                                _32723 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32723] = 26
                                mem[_32723 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            else:
                                _32722 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32722] = 26
                                mem[_32722 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                        if arg2 / 100 * reflectFees * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor6 += -1 * arg2 / 100 * reflectFees * t / s
                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg2 / 100 * reflectFees
                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                    else:
                        mem[0] = msg.sender
                        mem[32] = 4
                        if not stor4[address(msg.sender)]:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32253 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32253] = 26
                                        mem[_32253 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34659 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34659] = 30
                                            mem[_34659 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36695 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36695] = 30
                                            mem[_36695 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _38232 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38232 + idx + 68] = mem[_36695 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38232 + 68] = mem[_38232 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38232 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45875 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45875] = 30
                                            mem[_45875 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _48521 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48521 + idx + 68] = mem[_45875 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48521 + 68] = mem[_48521 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48521 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34901 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34901] = 30
                                        mem[_34901 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35468 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35468 + idx + 68] = mem[_34901 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35468 + 68] = mem[_35468 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35468 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38231 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38231] = 30
                                        mem[_38231 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _40048 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_40048 + idx + 68] = mem[_38231 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40048 + 68] = mem[_40048 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40048 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _48520 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48520] = 30
                                        mem[_48520 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50734 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50734 + idx + 68] = mem[_48520 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50734 + 68] = mem[_50734 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50734 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32365 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32365] = 30
                                        mem[_32365 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32563 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32563 + idx + 68] = mem[_32365 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32563 + 68] = mem[_32563 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32563 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33332 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33332] = 30
                                        mem[_33332 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33631 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33631 + idx + 68] = mem[_33332 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33631 + 68] = mem[_33631 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33631 + -mem[64] + 100
                                    _32427 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32427] = 26
                                    mem[_32427 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34902 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34902] = 30
                                        mem[_34902 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38237 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38237] = 30
                                        mem[_38237 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _40055 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_40055 + idx + 68] = mem[_38237 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40055 + 68] = mem[_40055 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40055 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _48525 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48525] = 30
                                        mem[_48525 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50739 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50739 + idx + 68] = mem[_48525 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50739 + 68] = mem[_50739 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50739 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35471 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35471] = 30
                                    mem[_35471 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _36253 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36253 + idx + 68] = mem[_35471 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36253 + 68] = mem[_36253 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36253 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _40054 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40054] = 30
                                    mem[_40054 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _42250 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_42250 + idx + 68] = mem[_40054 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42250 + 68] = mem[_42250 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42250 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _50738 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50738] = 30
                                    mem[_50738 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52674 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52674 + idx + 68] = mem[_50738 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52674 + 68] = mem[_52674 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52674 + -mem[64] + 100
                                _31831 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31831] = 26
                                mem[_31831 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32713 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32713] = 26
                                    mem[_32713 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                else:
                                    _32712 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32712] = 26
                                    mem[_32712 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32250 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32250] = 26
                                        mem[_32250 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34658 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34658] = 30
                                                mem[_34658 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _36692 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36692] = 30
                                                mem[_36692 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _38223 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38223 + idx + 68] = mem[_36692 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38223 + 68] = mem[_38223 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38223 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _45864 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45864] = 30
                                                mem[_45864 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _48506 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48506 + idx + 68] = mem[_45864 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48506 + 68] = mem[_48506 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48506 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34899 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34899] = 30
                                            mem[_34899 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _35461 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35461 + idx + 68] = mem[_34899 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35461 + 68] = mem[_35461 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35461 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38222 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38222] = 30
                                            mem[_38222 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _40029 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40029 + idx + 68] = mem[_38222 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40029 + 68] = mem[_40029 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40029 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _48505 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48505] = 30
                                            mem[_48505 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50720 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50720 + idx + 68] = mem[_48505 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50720 + 68] = mem[_50720 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50720 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _34898 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34898] = 30
                                            mem[_34898 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35458 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35458 + idx + 68] = mem[_34898 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35458 + 68] = mem[_35458 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35458 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38221 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38221] = 30
                                            mem[_38221 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _40026 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40026 + idx + 68] = mem[_38221 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40026 + 68] = mem[_40026 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40026 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _48504 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48504] = 30
                                            mem[_48504 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50717 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50717 + idx + 68] = mem[_48504 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50717 + 68] = mem[_50717 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50717 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35457 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35457] = 30
                                        mem[_35457 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _36236 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36236 + idx + 68] = mem[_35457 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36236 + 68] = mem[_36236 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36236 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40025 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40025] = 30
                                        mem[_40025 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _42214 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42214 + idx + 68] = mem[_40025 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42214 + 68] = mem[_42214 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42214 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _50716 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50716] = 30
                                        mem[_50716 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52646 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52646 + idx + 68] = mem[_50716 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52646 + 68] = mem[_52646 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52646 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32364 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32364] = 30
                                        mem[_32364 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32560 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32560 + idx + 68] = mem[_32364 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32560 + 68] = mem[_32560 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32560 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33330 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33330] = 30
                                        mem[_33330 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33626 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33626 + idx + 68] = mem[_33330 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33626 + 68] = mem[_33626 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33626 + -mem[64] + 100
                                    _32426 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32426] = 26
                                    mem[_32426 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34900 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34900] = 30
                                            mem[_34900 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38230 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38230] = 30
                                            mem[_38230 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _40039 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40039 + idx + 68] = mem[_38230 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40039 + 68] = mem[_40039 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40039 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _48513 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48513] = 30
                                            mem[_48513 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50727 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50727 + idx + 68] = mem[_48513 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50727 + 68] = mem[_50727 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50727 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35465 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35465] = 30
                                        mem[_35465 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _36246 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36246 + idx + 68] = mem[_35465 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36246 + 68] = mem[_36246 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36246 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40038 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40038] = 30
                                        mem[_40038 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _42230 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42230 + idx + 68] = mem[_40038 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42230 + 68] = mem[_42230 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42230 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _50726 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50726] = 30
                                        mem[_50726 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52658 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52658 + idx + 68] = mem[_50726 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52658 + 68] = mem[_52658 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52658 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _35464 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35464] = 30
                                        mem[_35464 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36243 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36243 + idx + 68] = mem[_35464 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36243 + 68] = mem[_36243 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36243 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40037 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40037] = 30
                                        mem[_40037 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _42227 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42227 + idx + 68] = mem[_40037 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42227 + 68] = mem[_42227 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42227 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _50725 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50725] = 30
                                        mem[_50725 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52655 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52655 + idx + 68] = mem[_50725 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52655 + 68] = mem[_52655 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52655 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36242 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36242] = 30
                                    mem[_36242 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _37441 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_37441 + idx + 68] = mem[_36242 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37441 + 68] = mem[_37441 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37441 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _42226 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42226] = 30
                                    mem[_42226 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _44588 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_44588 + idx + 68] = mem[_42226 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44588 + 68] = mem[_44588 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44588 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _52654 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52654] = 30
                                    mem[_52654 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _54634 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_54634 + idx + 68] = mem[_52654 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54634 + 68] = mem[_54634 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54634 + -mem[64] + 100
                                _31826 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31826] = 26
                                mem[_31826 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32711 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32711] = 26
                                    mem[_32711 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    _32710 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32710] = 26
                                    mem[_32710 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                        else:
                            mem[0] = arg1
                            mem[32] = 4
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            if not stor4[address(arg1)]:
                                if not arg2 / 100:
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32259 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32259] = 26
                                            mem[_32259 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                _34661 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34661] = 30
                                                mem[_34661 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _36703 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36703] = 30
                                                mem[_36703 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _38251 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38251 + idx + 68] = mem[_36703 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38251 + 68] = mem[_38251 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38251 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _45898 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45898] = 30
                                                mem[_45898 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _48554 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48554 + idx + 68] = mem[_45898 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48554 + 68] = mem[_48554 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48554 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34906 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34906] = 30
                                            mem[_34906 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35485 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35485 + idx + 68] = mem[_34906 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35485 + 68] = mem[_35485 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35485 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38250 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38250] = 30
                                            mem[_38250 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _40091 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40091 + idx + 68] = mem[_38250 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40091 + 68] = mem[_40091 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40091 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _48553 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48553] = 30
                                            mem[_48553 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _50770 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50770 + idx + 68] = mem[_48553 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50770 + 68] = mem[_50770 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50770 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32367 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32367] = 30
                                            mem[_32367 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32569 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32569 + idx + 68] = mem[_32367 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32569 + 68] = mem[_32569 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32569 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33336 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33336] = 30
                                            mem[_33336 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33641 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33641 + idx + 68] = mem[_33336 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33641 + 68] = mem[_33641 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33641 + -mem[64] + 100
                                        _32429 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32429] = 26
                                        mem[_32429 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34907 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34907] = 30
                                            mem[_34907 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38256 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38256] = 30
                                            mem[_38256 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _40098 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40098 + idx + 68] = mem[_38256 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40098 + 68] = mem[_40098 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40098 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _48558 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48558] = 30
                                            mem[_48558 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _50775 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50775 + idx + 68] = mem[_48558 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50775 + 68] = mem[_50775 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50775 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35488 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35488] = 30
                                        mem[_35488 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36277 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36277 + idx + 68] = mem[_35488 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36277 + 68] = mem[_36277 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36277 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40097 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40097] = 30
                                        mem[_40097 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _42306 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42306 + idx + 68] = mem[_40097 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42306 + 68] = mem[_42306 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42306 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _50774 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50774] = 30
                                        mem[_50774 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52718 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52718 + idx + 68] = mem[_50774 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52718 + 68] = mem[_52718 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52718 + -mem[64] + 100
                                    _31841 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31841] = 26
                                    mem[_31841 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32717 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32717] = 26
                                        mem[_32717 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    else:
                                        _32716 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32716] = 26
                                        mem[_32716 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32256 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32256] = 26
                                            mem[_32256 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    _34660 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34660] = 30
                                                    mem[_34660 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _36700 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_36700] = 30
                                                    mem[_36700 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _38242 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_38242 + idx + 68] = mem[_36700 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_38242 + 68] = mem[_38242 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _38242 + -mem[64] + 100
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _45887 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_45887] = 30
                                                    mem[_45887 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _48539 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_48539 + idx + 68] = mem[_45887 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_48539 + 68] = mem[_48539 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _48539 + -mem[64] + 100
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _34904 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34904] = 30
                                                mem[_34904 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    _35478 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35478 + idx + 68] = mem[_34904 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35478 + 68] = mem[_35478 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35478 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38241 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38241] = 30
                                                mem[_38241 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _40072 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40072 + idx + 68] = mem[_38241 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40072 + 68] = mem[_40072 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40072 + -mem[64] + 100
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                _48538 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48538] = 30
                                                mem[_48538 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _50756 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_50756 + idx + 68] = mem[_48538 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50756 + 68] = mem[_50756 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50756 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                _34903 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34903] = 30
                                                mem[_34903 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    _35475 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35475 + idx + 68] = mem[_34903 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35475 + 68] = mem[_35475 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35475 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38240 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38240] = 30
                                                mem[_38240 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _40069 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40069 + idx + 68] = mem[_38240 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40069 + 68] = mem[_40069 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40069 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                _48537 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48537] = 30
                                                mem[_48537 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _50753 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_50753 + idx + 68] = mem[_48537 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50753 + 68] = mem[_50753 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50753 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35474 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35474] = 30
                                            mem[_35474 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                _36260 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36260 + idx + 68] = mem[_35474 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36260 + 68] = mem[_36260 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36260 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40068 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40068] = 30
                                            mem[_40068 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _42270 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42270 + idx + 68] = mem[_40068 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42270 + 68] = mem[_42270 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42270 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            _50752 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50752] = 30
                                            mem[_50752 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52690 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52690 + idx + 68] = mem[_50752 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52690 + 68] = mem[_52690 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52690 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32366 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32366] = 30
                                            mem[_32366 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32566 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32566 + idx + 68] = mem[_32366 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32566 + 68] = mem[_32566 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32566 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33334 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33334] = 30
                                            mem[_33334 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33636 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33636 + idx + 68] = mem[_33334 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33636 + 68] = mem[_33636 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33636 + -mem[64] + 100
                                        _32428 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32428] = 26
                                        mem[_32428 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34905 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34905] = 30
                                                mem[_34905 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38249 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38249] = 30
                                                mem[_38249 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _40082 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40082 + idx + 68] = mem[_38249 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40082 + 68] = mem[_40082 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40082 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _48546 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48546] = 30
                                                mem[_48546 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _50763 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_50763 + idx + 68] = mem[_48546 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50763 + 68] = mem[_50763 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50763 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35482 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35482] = 30
                                            mem[_35482 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _36270 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36270 + idx + 68] = mem[_35482 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36270 + 68] = mem[_36270 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36270 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40081 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40081] = 30
                                            mem[_40081 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _42286 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42286 + idx + 68] = mem[_40081 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42286 + 68] = mem[_42286 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42286 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _50762 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50762] = 30
                                            mem[_50762 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52702 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52702 + idx + 68] = mem[_50762 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52702 + 68] = mem[_52702 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52702 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _35481 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35481] = 30
                                            mem[_35481 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _36267 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36267 + idx + 68] = mem[_35481 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36267 + 68] = mem[_36267 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36267 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40080 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40080] = 30
                                            mem[_40080 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _42283 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42283 + idx + 68] = mem[_40080 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42283 + 68] = mem[_42283 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42283 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _50761 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50761] = 30
                                            mem[_50761 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52699 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52699 + idx + 68] = mem[_50761 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52699 + 68] = mem[_52699 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52699 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _36266 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36266] = 30
                                        mem[_36266 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _37476 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37476 + idx + 68] = mem[_36266 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37476 + 68] = mem[_37476 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37476 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _42282 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42282] = 30
                                        mem[_42282 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _44650 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_44650 + idx + 68] = mem[_42282 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44650 + 68] = mem[_44650 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44650 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _52698 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52698] = 30
                                        mem[_52698 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _54684 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_54684 + idx + 68] = mem[_52698 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54684 + 68] = mem[_54684 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54684 + -mem[64] + 100
                                    _31836 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31836] = 26
                                    mem[_31836 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32715 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32715] = 26
                                        mem[_32715 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        _32714 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32714] = 26
                                        mem[_32714 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * t / s
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                            else:
                                if not arg2 / 100:
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32265 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32265] = 26
                                            mem[_32265 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                _34663 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34663] = 30
                                                mem[_34663 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _36711 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36711] = 30
                                                mem[_36711 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _38270 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38270 + idx + 68] = mem[_36711 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38270 + 68] = mem[_38270 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38270 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _41003 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41003] = 30
                                                mem[_41003 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _43298 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_43298 + idx + 68] = mem[_41003 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43298 + 68] = mem[_43298 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43298 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] += arg2
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _54741 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_54741] = 30
                                                mem[_54741 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _56675 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_56675 + idx + 68] = mem[_54741 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_56675 + 68] = mem[_56675 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _56675 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34911 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34911] = 30
                                            mem[_34911 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35502 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35502 + idx + 68] = mem[_34911 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35502 + 68] = mem[_35502 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35502 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38269 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38269] = 30
                                            mem[_38269 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _40134 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40134 + idx + 68] = mem[_38269 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40134 + 68] = mem[_40134 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40134 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43295 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43295] = 30
                                            mem[_43295 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _45935 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45935 + idx + 68] = mem[_43295 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45935 + 68] = mem[_45935 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45935 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _56674 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56674] = 30
                                            mem[_56674 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58346 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_58346 + idx + 68] = mem[_56674 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58346 + 68] = mem[_58346 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58346 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32369 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32369] = 30
                                            mem[_32369 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32575 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32575 + idx + 68] = mem[_32369 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32575 + 68] = mem[_32575 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32575 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33340 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33340] = 30
                                            mem[_33340 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33651 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33651 + idx + 68] = mem[_33340 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33651 + 68] = mem[_33651 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33651 + -mem[64] + 100
                                        _32431 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32431] = 26
                                        mem[_32431 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34912 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34912] = 30
                                            mem[_34912 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38275 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38275] = 30
                                            mem[_38275 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _40141 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40141 + idx + 68] = mem[_38275 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40141 + 68] = mem[_40141 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40141 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43301 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43301] = 30
                                            mem[_43301 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _45944 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45944 + idx + 68] = mem[_43301 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45944 + 68] = mem[_45944 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45944 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _56679 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56679] = 30
                                            mem[_56679 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58351 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_58351 + idx + 68] = mem[_56679 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58351 + 68] = mem[_58351 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58351 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35505 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35505] = 30
                                        mem[_35505 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36301 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36301 + idx + 68] = mem[_35505 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36301 + 68] = mem[_36301 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36301 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _40140 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40140] = 30
                                        mem[_40140 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _42358 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42358 + idx + 68] = mem[_40140 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42358 + 68] = mem[_42358 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42358 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _45941 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45941] = 30
                                        mem[_45941 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _48619 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48619 + idx + 68] = mem[_45941 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48619 + 68] = mem[_48619 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48619 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _58350 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58350] = 30
                                        mem[_58350 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _59528 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59528 + idx + 68] = mem[_58350 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59528 + 68] = mem[_59528 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59528 + -mem[64] + 100
                                    _31851 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31851] = 26
                                    mem[_31851 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32721 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32721] = 26
                                        mem[_32721 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    else:
                                        _32720 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32720] = 26
                                        mem[_32720 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32262 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32262] = 26
                                            mem[_32262 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    _34662 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34662] = 30
                                                    mem[_34662 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 2
                                                    _36708 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_36708] = 30
                                                    mem[_36708 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        _38261 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_38261 + idx + 68] = mem[_36708 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_38261 + 68] = mem[_38261 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _38261 + -mem[64] + 100
                                                    stor2[address(msg.sender)] -= arg2
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _40994 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_40994] = 30
                                                    mem[_40994 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _43289 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_43289 + idx + 68] = mem[_40994 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_43289 + 68] = mem[_43289 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _43289 + -mem[64] + 100
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _54729 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_54729] = 30
                                                    mem[_54729 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _56666 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_56666 + idx + 68] = mem[_54729 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_56666 + 68] = mem[_56666 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _56666 + -mem[64] + 100
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _34909 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34909] = 30
                                                mem[_34909 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    _35495 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35495 + idx + 68] = mem[_34909 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35495 + 68] = mem[_35495 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35495 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _38260 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38260] = 30
                                                mem[_38260 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _40115 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40115 + idx + 68] = mem[_38260 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40115 + 68] = mem[_40115 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40115 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _43286 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43286] = 30
                                                mem[_43286 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _45914 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_45914 + idx + 68] = mem[_43286 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_45914 + 68] = mem[_45914 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _45914 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                _56665 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56665] = 30
                                                mem[_56665 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _58332 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_58332 + idx + 68] = mem[_56665 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58332 + 68] = mem[_58332 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58332 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                _34908 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34908] = 30
                                                mem[_34908 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    _35492 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35492 + idx + 68] = mem[_34908 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35492 + 68] = mem[_35492 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35492 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _38259 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38259] = 30
                                                mem[_38259 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _40112 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40112 + idx + 68] = mem[_38259 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40112 + 68] = mem[_40112 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40112 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _43283 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43283] = 30
                                                mem[_43283 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _45911 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_45911 + idx + 68] = mem[_43283 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_45911 + 68] = mem[_45911 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _45911 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                _56664 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56664] = 30
                                                mem[_56664 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _58329 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_58329 + idx + 68] = mem[_56664 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58329 + 68] = mem[_58329 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58329 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35491 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35491] = 30
                                            mem[_35491 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                _36284 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36284 + idx + 68] = mem[_35491 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36284 + 68] = mem[_36284 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36284 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _40111 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40111] = 30
                                            mem[_40111 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _42326 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42326 + idx + 68] = mem[_40111 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42326 + 68] = mem[_42326 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42326 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _45908 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45908] = 30
                                            mem[_45908 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _48577 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48577 + idx + 68] = mem[_45908 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48577 + 68] = mem[_48577 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48577 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            _58328 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58328] = 30
                                            mem[_58328 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _59500 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_59500 + idx + 68] = mem[_58328 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59500 + 68] = mem[_59500 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59500 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32368 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32368] = 30
                                            mem[_32368 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32572 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32572 + idx + 68] = mem[_32368 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32572 + 68] = mem[_32572 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32572 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33338 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33338] = 30
                                            mem[_33338 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33646 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33646 + idx + 68] = mem[_33338 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33646 + 68] = mem[_33646 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33646 + -mem[64] + 100
                                        _32430 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32430] = 26
                                        mem[_32430 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34910 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34910] = 30
                                                mem[_34910 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _38268 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38268] = 30
                                                mem[_38268 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _40125 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40125 + idx + 68] = mem[_38268 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40125 + 68] = mem[_40125 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40125 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _43292 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43292] = 30
                                                mem[_43292 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _45926 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_45926 + idx + 68] = mem[_43292 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_45926 + 68] = mem[_45926 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _45926 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _56671 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56671] = 30
                                                mem[_56671 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _58339 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_58339 + idx + 68] = mem[_56671 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58339 + 68] = mem[_58339 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58339 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35499 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35499] = 30
                                            mem[_35499 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _36294 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36294 + idx + 68] = mem[_35499 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36294 + 68] = mem[_36294 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36294 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _40124 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40124] = 30
                                            mem[_40124 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _42340 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42340 + idx + 68] = mem[_40124 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42340 + 68] = mem[_42340 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42340 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _45923 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45923] = 30
                                            mem[_45923 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _48595 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48595 + idx + 68] = mem[_45923 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48595 + 68] = mem[_48595 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48595 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _58338 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58338] = 30
                                            mem[_58338 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _59512 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_59512 + idx + 68] = mem[_58338 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59512 + 68] = mem[_59512 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59512 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _35498 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35498] = 30
                                            mem[_35498 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _36291 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36291 + idx + 68] = mem[_35498 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36291 + 68] = mem[_36291 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36291 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _40123 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40123] = 30
                                            mem[_40123 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _42337 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42337 + idx + 68] = mem[_40123 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42337 + 68] = mem[_42337 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42337 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _45920 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45920] = 30
                                            mem[_45920 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _48592 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48592 + idx + 68] = mem[_45920 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48592 + 68] = mem[_48592 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48592 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _58337 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58337] = 30
                                            mem[_58337 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _59509 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_59509 + idx + 68] = mem[_58337 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59509 + 68] = mem[_59509 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59509 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _36290 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36290] = 30
                                        mem[_36290 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _37511 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37511 + idx + 68] = mem[_36290 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37511 + 68] = mem[_37511 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37511 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _42336 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42336] = 30
                                        mem[_42336 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _44708 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_44708 + idx + 68] = mem[_42336 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44708 + 68] = mem[_44708 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44708 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _48589 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48589] = 30
                                        mem[_48589 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _50811 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50811 + idx + 68] = mem[_48589 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50811 + 68] = mem[_50811 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50811 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _59508 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_59508] = 30
                                        mem[_59508 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _60406 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_60406 + idx + 68] = mem[_59508 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60406 + 68] = mem[_60406 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60406 + -mem[64] + 100
                                    _31846 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31846] = 26
                                    mem[_31846 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32719 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32719] = 26
                                        mem[_32719 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        _32718 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32718] = 26
                                        mem[_32718 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * t / s
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 4
                if stor4[address(arg1)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _32319 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32319] = 26
                                mem[_32319 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _34681 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34681] = 30
                                    mem[_34681 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _36783 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36783] = 30
                                    mem[_36783 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _38441 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_38441 + idx + 68] = mem[_36783 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38441 + 68] = mem[_38441 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38441 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _49883 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49883] = 30
                                    mem[_49883 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _51793 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_51793 + idx + 68] = mem[_49883 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51793 + 68] = mem[_51793 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51793 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34956 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34956] = 30
                                mem[_34956 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _35655 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_35655 + idx + 68] = mem[_34956 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35655 + 68] = mem[_35655 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _35655 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _38440 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38440] = 30
                                mem[_38440 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _40521 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_40521 + idx + 68] = mem[_38440 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40521 + 68] = mem[_40521 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40521 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _51792 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51792] = 30
                                mem[_51792 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _53790 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_53790 + idx + 68] = mem[_51792 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53790 + 68] = mem[_53790 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53790 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _32387 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32387] = 30
                                mem[_32387 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _32629 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_32629 + idx + 68] = mem[_32387 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32629 + 68] = mem[_32629 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _32629 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _33376 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33376] = 30
                                mem[_33376 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _33741 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_33741 + idx + 68] = mem[_33376 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33741 + 68] = mem[_33741 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33741 + -mem[64] + 100
                            _32449 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32449] = 26
                            mem[_32449 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _34957 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34957] = 30
                                mem[_34957 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _38446 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38446] = 30
                                mem[_38446 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _40528 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_40528 + idx + 68] = mem[_38446 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_40528 + 68] = mem[_40528 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _40528 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _51797 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51797] = 30
                                mem[_51797 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _53795 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_53795 + idx + 68] = mem[_51797 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53795 + 68] = mem[_53795 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53795 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _35658 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35658] = 30
                            mem[_35658 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _36517 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_36517 + idx + 68] = mem[_35658 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36517 + 68] = mem[_36517 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36517 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _40527 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_40527] = 30
                            mem[_40527 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _42854 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_42854 + idx + 68] = mem[_40527 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_42854 + 68] = mem[_42854 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _42854 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            _53794 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53794] = 30
                            mem[_53794 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _55822 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_55822 + idx + 68] = mem[_53794 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_55822 + 68] = mem[_55822 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55822 + -mem[64] + 100
                        _31941 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31941] = 26
                        mem[_31941 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 1000 * 10^18:
                            _32757 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32757] = 26
                            mem[_32757 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                        else:
                            _32756 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32756] = 26
                            mem[_32756 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        require arg2 / 100
                        if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if arg2 / 100 * reflectFees > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _32316 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32316] = 26
                                mem[_32316 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not arg2 / 100 * reflectFees:
                                        _34680 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34680] = 30
                                        mem[_34680 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _36780 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36780] = 30
                                        mem[_36780 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _38432 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_38432 + idx + 68] = mem[_36780 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38432 + 68] = mem[_38432 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38432 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _49871 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49871] = 30
                                        mem[_49871 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _51784 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_51784 + idx + 68] = mem[_49871 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51784 + 68] = mem[_51784 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51784 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34954 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34954] = 30
                                    mem[_34954 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        _35648 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35648 + idx + 68] = mem[_34954 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35648 + 68] = mem[_35648 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35648 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38431 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38431] = 30
                                    mem[_38431 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _40502 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_40502 + idx + 68] = mem[_38431 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40502 + 68] = mem[_40502 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40502 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    _51783 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51783] = 30
                                    mem[_51783 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _53776 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_53776 + idx + 68] = mem[_51783 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53776 + 68] = mem[_53776 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53776 + -mem[64] + 100
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    _34953 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34953] = 30
                                    mem[_34953 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _35645 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_35645 + idx + 68] = mem[_34953 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35645 + 68] = mem[_35645 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _35645 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38430 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38430] = 30
                                    mem[_38430 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _40499 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_40499 + idx + 68] = mem[_38430 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40499 + 68] = mem[_40499 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40499 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _51782 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51782] = 30
                                    mem[_51782 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _53773 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_53773 + idx + 68] = mem[_51782 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53773 + 68] = mem[_53773 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53773 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35644 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35644] = 30
                                mem[_35644 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _36500 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36500 + idx + 68] = mem[_35644 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36500 + 68] = mem[_36500 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36500 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _40498 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40498] = 30
                                mem[_40498 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _42818 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_42818 + idx + 68] = mem[_40498 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42818 + 68] = mem[_42818 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42818 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                _53772 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53772] = 30
                                mem[_53772 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _55794 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_55794 + idx + 68] = mem[_53772 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55794 + 68] = mem[_55794 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55794 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _32386 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32386] = 30
                                mem[_32386 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _32626 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_32626 + idx + 68] = mem[_32386 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32626 + 68] = mem[_32626 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _32626 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _33374 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33374] = 30
                                mem[_33374 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _33736 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_33736 + idx + 68] = mem[_33374 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33736 + 68] = mem[_33736 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33736 + -mem[64] + 100
                            _32448 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32448] = 26
                            mem[_32448 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100 * reflectFees:
                                    _34955 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34955] = 30
                                    mem[_34955 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _38439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38439] = 30
                                    mem[_38439 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _40512 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_40512 + idx + 68] = mem[_38439 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_40512 + 68] = mem[_40512 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _40512 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _51789 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51789] = 30
                                    mem[_51789 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _53783 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_53783 + idx + 68] = mem[_51789 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53783 + 68] = mem[_53783 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53783 + -mem[64] + 100
                                require arg2 / 100 * reflectFees
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35652 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35652] = 30
                                mem[_35652 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                    _36510 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36510 + idx + 68] = mem[_35652 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36510 + 68] = mem[_36510 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36510 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _40511 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40511] = 30
                                mem[_40511 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _42834 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_42834 + idx + 68] = mem[_40511 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42834 + 68] = mem[_42834 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42834 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                _53782 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53782] = 30
                                mem[_53782 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _55806 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_55806 + idx + 68] = mem[_53782 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55806 + 68] = mem[_55806 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55806 + -mem[64] + 100
                            require arg2
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not arg2 / 100 * reflectFees:
                                _35651 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35651] = 30
                                mem[_35651 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _36507 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_36507 + idx + 68] = mem[_35651 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36507 + 68] = mem[_36507 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36507 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _40510 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40510] = 30
                                mem[_40510 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _42831 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_42831 + idx + 68] = mem[_40510 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42831 + 68] = mem[_42831 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42831 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _53781 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53781] = 30
                                mem[_53781 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                    return 1
                                _55803 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_55803 + idx + 68] = mem[_53781 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55803 + 68] = mem[_55803 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55803 + -mem[64] + 100
                            require arg2 / 100 * reflectFees
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _36506 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_36506] = 30
                            mem[_36506 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                _37826 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_37826 + idx + 68] = mem[_36506 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_37826 + 68] = mem[_37826 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _37826 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _42830 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_42830] = 30
                            mem[_42830 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _45240 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_45240 + idx + 68] = mem[_42830 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_45240 + 68] = mem[_45240 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _45240 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                            _55802 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_55802] = 30
                            mem[_55802 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                return 1
                            _57531 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_57531 + idx + 68] = mem[_55802 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_57531 + 68] = mem[_57531 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _57531 + -mem[64] + 100
                        _31936 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31936] = 26
                        mem[_31936 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 1000 * 10^18:
                            _32755 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32755] = 26
                            mem[_32755 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not arg2 / 100 * reflectFees:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                            else:
                                require arg2
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                        else:
                            _32754 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32754] = 26
                            mem[_32754 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not arg2 / 100 * reflectFees:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                    if arg2 / 100 * reflectFees * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not arg2 / 100 * reflectFees:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                    if arg2 / 100 * reflectFees * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor6 += -1 * arg2 / 100 * reflectFees * t / s
                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg2 / 100 * reflectFees
                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                else:
                    if stor4[address(msg.sender)]:
                        mem[0] = msg.sender
                        mem[32] = 4
                        if not stor4[address(msg.sender)]:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32277 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32277] = 26
                                        mem[_32277 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34667 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34667] = 30
                                            mem[_34667 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36727 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36727] = 30
                                            mem[_36727 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _38308 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38308 + idx + 68] = mem[_36727 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38308 + 68] = mem[_38308 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38308 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _45989 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45989] = 30
                                            mem[_45989 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _48686 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48686 + idx + 68] = mem[_45989 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48686 + 68] = mem[_48686 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48686 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34921 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34921] = 30
                                        mem[_34921 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35536 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35536 + idx + 68] = mem[_34921 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35536 + 68] = mem[_35536 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35536 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38307 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38307] = 30
                                        mem[_38307 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _40220 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_40220 + idx + 68] = mem[_38307 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40220 + 68] = mem[_40220 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40220 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _48685 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48685] = 30
                                        mem[_48685 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50908 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50908 + idx + 68] = mem[_48685 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50908 + 68] = mem[_50908 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50908 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32373 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32373] = 30
                                        mem[_32373 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32587 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32587 + idx + 68] = mem[_32373 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32587 + 68] = mem[_32587 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32587 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33348 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33348] = 30
                                        mem[_33348 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33671 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33671 + idx + 68] = mem[_33348 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33671 + 68] = mem[_33671 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33671 + -mem[64] + 100
                                    _32435 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32435] = 26
                                    mem[_32435 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34922 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34922] = 30
                                        mem[_34922 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38313 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38313] = 30
                                        mem[_38313 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _40227 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_40227 + idx + 68] = mem[_38313 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40227 + 68] = mem[_40227 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40227 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _48690 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48690] = 30
                                        mem[_48690 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50913 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_50913 + idx + 68] = mem[_48690 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50913 + 68] = mem[_50913 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50913 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35539 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35539] = 30
                                    mem[_35539 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _36349 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36349 + idx + 68] = mem[_35539 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36349 + 68] = mem[_36349 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36349 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _40226 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40226] = 30
                                    mem[_40226 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _42470 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_42470 + idx + 68] = mem[_40226 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42470 + 68] = mem[_42470 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42470 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _50912 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50912] = 30
                                    mem[_50912 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52859 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_52859 + idx + 68] = mem[_50912 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52859 + 68] = mem[_52859 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52859 + -mem[64] + 100
                                _31871 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31871] = 26
                                mem[_31871 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32729 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32729] = 26
                                    mem[_32729 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                else:
                                    _32728 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32728] = 26
                                    mem[_32728 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32274 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32274] = 26
                                        mem[_32274 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34666 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34666] = 30
                                                mem[_34666 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _36724 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36724] = 30
                                                mem[_36724 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _38299 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38299 + idx + 68] = mem[_36724 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38299 + 68] = mem[_38299 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38299 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _45978 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45978] = 30
                                                mem[_45978 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _48671 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48671 + idx + 68] = mem[_45978 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48671 + 68] = mem[_48671 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48671 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34919 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34919] = 30
                                            mem[_34919 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _35529 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35529 + idx + 68] = mem[_34919 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35529 + 68] = mem[_35529 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35529 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38298 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38298] = 30
                                            mem[_38298 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _40201 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40201 + idx + 68] = mem[_38298 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40201 + 68] = mem[_40201 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40201 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _48670 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48670] = 30
                                            mem[_48670 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50894 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50894 + idx + 68] = mem[_48670 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50894 + 68] = mem[_50894 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50894 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _34918 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34918] = 30
                                            mem[_34918 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35526 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35526 + idx + 68] = mem[_34918 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35526 + 68] = mem[_35526 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35526 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38297 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38297] = 30
                                            mem[_38297 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _40198 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40198 + idx + 68] = mem[_38297 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40198 + 68] = mem[_40198 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40198 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _48669 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48669] = 30
                                            mem[_48669 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50891 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50891 + idx + 68] = mem[_48669 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50891 + 68] = mem[_50891 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50891 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35525 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35525] = 30
                                        mem[_35525 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _36332 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36332 + idx + 68] = mem[_35525 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36332 + 68] = mem[_36332 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36332 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40197 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40197] = 30
                                        mem[_40197 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _42434 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42434 + idx + 68] = mem[_40197 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42434 + 68] = mem[_42434 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42434 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _50890 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50890] = 30
                                        mem[_50890 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52831 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52831 + idx + 68] = mem[_50890 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52831 + 68] = mem[_52831 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52831 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32372 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32372] = 30
                                        mem[_32372 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32584 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32584 + idx + 68] = mem[_32372 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32584 + 68] = mem[_32584 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32584 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33346 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33346] = 30
                                        mem[_33346 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33666 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33666 + idx + 68] = mem[_33346 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33666 + 68] = mem[_33666 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33666 + -mem[64] + 100
                                    _32434 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32434] = 26
                                    mem[_32434 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34920 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34920] = 30
                                            mem[_34920 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38306 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38306] = 30
                                            mem[_38306 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _40211 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40211 + idx + 68] = mem[_38306 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40211 + 68] = mem[_40211 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40211 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _48678 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48678] = 30
                                            mem[_48678 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _50901 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50901 + idx + 68] = mem[_48678 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50901 + 68] = mem[_50901 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50901 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35533 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35533] = 30
                                        mem[_35533 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _36342 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36342 + idx + 68] = mem[_35533 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36342 + 68] = mem[_36342 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36342 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40210 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40210] = 30
                                        mem[_40210 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _42450 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42450 + idx + 68] = mem[_40210 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42450 + 68] = mem[_42450 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42450 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _50900 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50900] = 30
                                        mem[_50900 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52843 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52843 + idx + 68] = mem[_50900 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52843 + 68] = mem[_52843 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52843 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _35532 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35532] = 30
                                        mem[_35532 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36339 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36339 + idx + 68] = mem[_35532 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36339 + 68] = mem[_36339 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36339 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40209 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40209] = 30
                                        mem[_40209 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _42447 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42447 + idx + 68] = mem[_40209 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42447 + 68] = mem[_42447 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42447 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _50899 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50899] = 30
                                        mem[_50899 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _52840 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52840 + idx + 68] = mem[_50899 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52840 + 68] = mem[_52840 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52840 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36338 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36338] = 30
                                    mem[_36338 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _37581 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_37581 + idx + 68] = mem[_36338 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37581 + 68] = mem[_37581 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37581 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _42446 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42446] = 30
                                    mem[_42446 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _44826 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_44826 + idx + 68] = mem[_42446 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44826 + 68] = mem[_44826 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44826 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _52839 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52839] = 30
                                    mem[_52839 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _54818 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_54818 + idx + 68] = mem[_52839 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54818 + 68] = mem[_54818 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54818 + -mem[64] + 100
                                _31866 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31866] = 26
                                mem[_31866 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32727 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32727] = 26
                                    mem[_32727 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    _32726 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32726] = 26
                                    mem[_32726 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                        else:
                            mem[0] = arg1
                            mem[32] = 4
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            if not stor4[address(arg1)]:
                                if not arg2 / 100:
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32283 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32283] = 26
                                            mem[_32283 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                _34669 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34669] = 30
                                                mem[_34669 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _36735 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36735] = 30
                                                mem[_36735 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _38327 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38327 + idx + 68] = mem[_36735 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38327 + 68] = mem[_38327 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38327 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _46012 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_46012] = 30
                                                mem[_46012 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _48719 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48719 + idx + 68] = mem[_46012 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48719 + 68] = mem[_48719 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48719 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34926 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34926] = 30
                                            mem[_34926 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35553 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35553 + idx + 68] = mem[_34926 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35553 + 68] = mem[_35553 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35553 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38326 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38326] = 30
                                            mem[_38326 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _40263 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40263 + idx + 68] = mem[_38326 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40263 + 68] = mem[_40263 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40263 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _48718 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48718] = 30
                                            mem[_48718 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _50944 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50944 + idx + 68] = mem[_48718 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50944 + 68] = mem[_50944 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50944 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32375 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32375] = 30
                                            mem[_32375 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32593 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32593 + idx + 68] = mem[_32375 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32593 + 68] = mem[_32593 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32593 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33352 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33352] = 30
                                            mem[_33352 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33681 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33681 + idx + 68] = mem[_33352 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33681 + 68] = mem[_33681 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33681 + -mem[64] + 100
                                        _32437 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32437] = 26
                                        mem[_32437 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34927 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34927] = 30
                                            mem[_34927 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38332 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38332] = 30
                                            mem[_38332 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _40270 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40270 + idx + 68] = mem[_38332 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40270 + 68] = mem[_40270 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40270 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _48723 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48723] = 30
                                            mem[_48723 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _50949 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50949 + idx + 68] = mem[_48723 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50949 + 68] = mem[_50949 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50949 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35556 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35556] = 30
                                        mem[_35556 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36373 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36373 + idx + 68] = mem[_35556 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36373 + 68] = mem[_36373 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36373 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40269 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40269] = 30
                                        mem[_40269 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _42526 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42526 + idx + 68] = mem[_40269 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42526 + 68] = mem[_42526 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42526 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _50948 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50948] = 30
                                        mem[_50948 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52903 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_52903 + idx + 68] = mem[_50948 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52903 + 68] = mem[_52903 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52903 + -mem[64] + 100
                                    _31881 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31881] = 26
                                    mem[_31881 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32733 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32733] = 26
                                        mem[_32733 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    else:
                                        _32732 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32732] = 26
                                        mem[_32732 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32280 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32280] = 26
                                            mem[_32280 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    _34668 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34668] = 30
                                                    mem[_34668 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _36732 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_36732] = 30
                                                    mem[_36732 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _38318 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_38318 + idx + 68] = mem[_36732 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_38318 + 68] = mem[_38318 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _38318 + -mem[64] + 100
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _46001 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_46001] = 30
                                                    mem[_46001 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _48704 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_48704 + idx + 68] = mem[_46001 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_48704 + 68] = mem[_48704 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _48704 + -mem[64] + 100
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _34924 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34924] = 30
                                                mem[_34924 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    _35546 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35546 + idx + 68] = mem[_34924 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35546 + 68] = mem[_35546 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35546 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38317 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38317] = 30
                                                mem[_38317 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _40244 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40244 + idx + 68] = mem[_38317 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40244 + 68] = mem[_40244 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40244 + -mem[64] + 100
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                _48703 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48703] = 30
                                                mem[_48703 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _50930 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_50930 + idx + 68] = mem[_48703 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50930 + 68] = mem[_50930 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50930 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                _34923 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34923] = 30
                                                mem[_34923 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    _35543 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35543 + idx + 68] = mem[_34923 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35543 + 68] = mem[_35543 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35543 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38316 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38316] = 30
                                                mem[_38316 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _40241 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40241 + idx + 68] = mem[_38316 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40241 + 68] = mem[_40241 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40241 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                _48702 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48702] = 30
                                                mem[_48702 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _50927 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_50927 + idx + 68] = mem[_48702 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50927 + 68] = mem[_50927 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50927 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35542 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35542] = 30
                                            mem[_35542 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                _36356 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36356 + idx + 68] = mem[_35542 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36356 + 68] = mem[_36356 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36356 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40240 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40240] = 30
                                            mem[_40240 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _42490 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42490 + idx + 68] = mem[_40240 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42490 + 68] = mem[_42490 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42490 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            _50926 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50926] = 30
                                            mem[_50926 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52875 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52875 + idx + 68] = mem[_50926 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52875 + 68] = mem[_52875 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52875 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32374 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32374] = 30
                                            mem[_32374 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32590 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32590 + idx + 68] = mem[_32374 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32590 + 68] = mem[_32590 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32590 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33350 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33350] = 30
                                            mem[_33350 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33676 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33676 + idx + 68] = mem[_33350 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33676 + 68] = mem[_33676 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33676 + -mem[64] + 100
                                        _32436 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32436] = 26
                                        mem[_32436 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34925 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34925] = 30
                                                mem[_34925 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38325 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38325] = 30
                                                mem[_38325 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _40254 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40254 + idx + 68] = mem[_38325 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40254 + 68] = mem[_40254 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40254 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _48711 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48711] = 30
                                                mem[_48711 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _50937 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_50937 + idx + 68] = mem[_48711 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50937 + 68] = mem[_50937 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50937 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35550 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35550] = 30
                                            mem[_35550 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _36366 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36366 + idx + 68] = mem[_35550 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36366 + 68] = mem[_36366 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36366 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40253 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40253] = 30
                                            mem[_40253 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _42506 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42506 + idx + 68] = mem[_40253 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42506 + 68] = mem[_42506 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42506 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _50936 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50936] = 30
                                            mem[_50936 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52887 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52887 + idx + 68] = mem[_50936 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52887 + 68] = mem[_52887 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52887 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _35549 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35549] = 30
                                            mem[_35549 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _36363 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36363 + idx + 68] = mem[_35549 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36363 + 68] = mem[_36363 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36363 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40252 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40252] = 30
                                            mem[_40252 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _42503 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42503 + idx + 68] = mem[_40252 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42503 + 68] = mem[_42503 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42503 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _50935 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50935] = 30
                                            mem[_50935 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52884 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52884 + idx + 68] = mem[_50935 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52884 + 68] = mem[_52884 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52884 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _36362 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36362] = 30
                                        mem[_36362 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _37616 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37616 + idx + 68] = mem[_36362 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37616 + 68] = mem[_37616 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37616 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _42502 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42502] = 30
                                        mem[_42502 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _44888 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_44888 + idx + 68] = mem[_42502 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44888 + 68] = mem[_44888 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44888 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _52883 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52883] = 30
                                        mem[_52883 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _54868 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_54868 + idx + 68] = mem[_52883 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54868 + 68] = mem[_54868 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54868 + -mem[64] + 100
                                    _31876 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31876] = 26
                                    mem[_31876 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32731 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32731] = 26
                                        mem[_32731 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        _32730 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32730] = 26
                                        mem[_32730 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * t / s
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                            else:
                                if not arg2 / 100:
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32289 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32289] = 26
                                            mem[_32289 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                _34671 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34671] = 30
                                                mem[_34671 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _36743 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36743] = 30
                                                mem[_36743 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _38346 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38346 + idx + 68] = mem[_36743 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38346 + 68] = mem[_38346 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38346 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _41085 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41085] = 30
                                                mem[_41085 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _43371 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_43371 + idx + 68] = mem[_41085 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43371 + 68] = mem[_43371 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43371 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] += arg2
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _54925 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_54925] = 30
                                                mem[_54925 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _56841 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_56841 + idx + 68] = mem[_54925 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_56841 + 68] = mem[_56841 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _56841 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34931 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34931] = 30
                                            mem[_34931 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35570 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35570 + idx + 68] = mem[_34931 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35570 + 68] = mem[_35570 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35570 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38345 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38345] = 30
                                            mem[_38345 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _40306 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40306 + idx + 68] = mem[_38345 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40306 + 68] = mem[_40306 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40306 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43368 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43368] = 30
                                            mem[_43368 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _46049 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_46049 + idx + 68] = mem[_43368 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_46049 + 68] = mem[_46049 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _46049 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _56840 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56840] = 30
                                            mem[_56840 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58495 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_58495 + idx + 68] = mem[_56840 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58495 + 68] = mem[_58495 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58495 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32377 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32377] = 30
                                            mem[_32377 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32599 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32599 + idx + 68] = mem[_32377 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32599 + 68] = mem[_32599 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32599 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33356 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33356] = 30
                                            mem[_33356 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33691 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33691 + idx + 68] = mem[_33356 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33691 + 68] = mem[_33691 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33691 + -mem[64] + 100
                                        _32439 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32439] = 26
                                        mem[_32439 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34932 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34932] = 30
                                            mem[_34932 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _38351 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38351] = 30
                                            mem[_38351 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _40313 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40313 + idx + 68] = mem[_38351 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40313 + 68] = mem[_40313 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40313 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _43374 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43374] = 30
                                            mem[_43374 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _46058 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_46058 + idx + 68] = mem[_43374 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_46058 + 68] = mem[_46058 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _46058 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _56845 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56845] = 30
                                            mem[_56845 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58500 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_58500 + idx + 68] = mem[_56845 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58500 + 68] = mem[_58500 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58500 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35573 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35573] = 30
                                        mem[_35573 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36397 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36397 + idx + 68] = mem[_35573 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36397 + 68] = mem[_36397 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36397 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _40312 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40312] = 30
                                        mem[_40312 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _42578 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42578 + idx + 68] = mem[_40312 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42578 + 68] = mem[_42578 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42578 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _46055 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_46055] = 30
                                        mem[_46055 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _48784 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48784 + idx + 68] = mem[_46055 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48784 + 68] = mem[_48784 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48784 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] += arg2
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _58499 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58499] = 30
                                        mem[_58499 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _59636 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_59636 + idx + 68] = mem[_58499 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59636 + 68] = mem[_59636 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59636 + -mem[64] + 100
                                    _31891 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31891] = 26
                                    mem[_31891 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32737 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32737] = 26
                                        mem[_32737 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    else:
                                        _32736 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32736] = 26
                                        mem[_32736 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor2[address(msg.sender)] -= arg2
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32286 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32286] = 26
                                            mem[_32286 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    _34670 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34670] = 30
                                                    mem[_34670 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 2
                                                    _36740 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_36740] = 30
                                                    mem[_36740 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        _38337 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_38337 + idx + 68] = mem[_36740 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_38337 + 68] = mem[_38337 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _38337 + -mem[64] + 100
                                                    stor2[address(msg.sender)] -= arg2
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _41076 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41076] = 30
                                                    mem[_41076 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _43362 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_43362 + idx + 68] = mem[_41076 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_43362 + 68] = mem[_43362 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _43362 + -mem[64] + 100
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _54913 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_54913] = 30
                                                    mem[_54913 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _56832 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_56832 + idx + 68] = mem[_54913 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_56832 + 68] = mem[_56832 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _56832 + -mem[64] + 100
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _34929 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34929] = 30
                                                mem[_34929 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    _35563 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35563 + idx + 68] = mem[_34929 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35563 + 68] = mem[_35563 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35563 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _38336 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38336] = 30
                                                mem[_38336 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _40287 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40287 + idx + 68] = mem[_38336 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40287 + 68] = mem[_40287 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40287 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _43359 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43359] = 30
                                                mem[_43359 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _46028 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_46028 + idx + 68] = mem[_43359 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_46028 + 68] = mem[_46028 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _46028 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                _56831 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56831] = 30
                                                mem[_56831 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _58481 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_58481 + idx + 68] = mem[_56831 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58481 + 68] = mem[_58481 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58481 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                _34928 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34928] = 30
                                                mem[_34928 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    _35560 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35560 + idx + 68] = mem[_34928 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35560 + 68] = mem[_35560 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35560 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _38335 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38335] = 30
                                                mem[_38335 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _40284 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40284 + idx + 68] = mem[_38335 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40284 + 68] = mem[_40284 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40284 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _43356 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43356] = 30
                                                mem[_43356 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _46025 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_46025 + idx + 68] = mem[_43356 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_46025 + 68] = mem[_46025 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _46025 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                _56830 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56830] = 30
                                                mem[_56830 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _58478 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_58478 + idx + 68] = mem[_56830 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58478 + 68] = mem[_58478 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58478 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35559 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35559] = 30
                                            mem[_35559 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                _36380 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36380 + idx + 68] = mem[_35559 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36380 + 68] = mem[_36380 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36380 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _40283 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40283] = 30
                                            mem[_40283 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _42546 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42546 + idx + 68] = mem[_40283 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42546 + 68] = mem[_42546 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42546 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _46022 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46022] = 30
                                            mem[_46022 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _48742 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48742 + idx + 68] = mem[_46022 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48742 + 68] = mem[_48742 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48742 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            _58477 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58477] = 30
                                            mem[_58477 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _59608 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_59608 + idx + 68] = mem[_58477 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59608 + 68] = mem[_59608 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59608 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32376 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32376] = 30
                                            mem[_32376 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32596 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32596 + idx + 68] = mem[_32376 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32596 + 68] = mem[_32596 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32596 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33354 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33354] = 30
                                            mem[_33354 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33686 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33686 + idx + 68] = mem[_33354 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33686 + 68] = mem[_33686 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33686 + -mem[64] + 100
                                        _32438 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32438] = 26
                                        mem[_32438 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34930 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34930] = 30
                                                mem[_34930 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _38344 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38344] = 30
                                                mem[_38344 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _40297 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40297 + idx + 68] = mem[_38344 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40297 + 68] = mem[_40297 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40297 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _43365 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43365] = 30
                                                mem[_43365 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _46040 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_46040 + idx + 68] = mem[_43365 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_46040 + 68] = mem[_46040 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _46040 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _56837 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56837] = 30
                                                mem[_56837 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _58488 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_58488 + idx + 68] = mem[_56837 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58488 + 68] = mem[_58488 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58488 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35567 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35567] = 30
                                            mem[_35567 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _36390 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36390 + idx + 68] = mem[_35567 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36390 + 68] = mem[_36390 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36390 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _40296 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40296] = 30
                                            mem[_40296 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _42560 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42560 + idx + 68] = mem[_40296 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42560 + 68] = mem[_42560 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42560 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _46037 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46037] = 30
                                            mem[_46037 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _48760 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48760 + idx + 68] = mem[_46037 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48760 + 68] = mem[_48760 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48760 + -mem[64] + 100
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _58487 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58487] = 30
                                            mem[_58487 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _59620 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_59620 + idx + 68] = mem[_58487 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59620 + 68] = mem[_59620 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59620 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _35566 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35566] = 30
                                            mem[_35566 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _36387 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36387 + idx + 68] = mem[_35566 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36387 + 68] = mem[_36387 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36387 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _40295 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40295] = 30
                                            mem[_40295 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _42557 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42557 + idx + 68] = mem[_40295 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42557 + 68] = mem[_42557 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42557 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _46034 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46034] = 30
                                            mem[_46034 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _48757 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48757 + idx + 68] = mem[_46034 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48757 + 68] = mem[_48757 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48757 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _58486 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58486] = 30
                                            mem[_58486 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _59617 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_59617 + idx + 68] = mem[_58486 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59617 + 68] = mem[_59617 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59617 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _36386 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36386] = 30
                                        mem[_36386 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _37651 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37651 + idx + 68] = mem[_36386 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37651 + 68] = mem[_37651 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37651 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 2
                                        _42556 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42556] = 30
                                        mem[_42556 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor2[address(msg.sender)]:
                                            _44946 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_44946 + idx + 68] = mem[_42556 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44946 + 68] = mem[_44946 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44946 + -mem[64] + 100
                                        stor2[address(msg.sender)] -= arg2
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _48754 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48754] = 30
                                        mem[_48754 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _50985 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_50985 + idx + 68] = mem[_48754 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50985 + 68] = mem[_50985 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50985 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _59616 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_59616] = 30
                                        mem[_59616 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _60478 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_60478 + idx + 68] = mem[_59616 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60478 + 68] = mem[_60478 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60478 + -mem[64] + 100
                                    _31886 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31886] = 26
                                    mem[_31886 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32735 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32735] = 26
                                        mem[_32735 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        _32734 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32734] = 26
                                        mem[_32734 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * t / s
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        if not stor4[address(arg1)]:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32313 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32313] = 26
                                        mem[_32313 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34679 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34679] = 30
                                            mem[_34679 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _36775 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36775] = 30
                                            mem[_36775 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _38422 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_38422 + idx + 68] = mem[_36775 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38422 + 68] = mem[_38422 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38422 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _46171 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46171] = 30
                                            mem[_46171 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _48950 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_48950 + idx + 68] = mem[_46171 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48950 + 68] = mem[_48950 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48950 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34951 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34951] = 30
                                        mem[_34951 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _35638 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_35638 + idx + 68] = mem[_34951 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_35638 + 68] = mem[_35638 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _35638 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38421 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38421] = 30
                                        mem[_38421 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _40478 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_40478 + idx + 68] = mem[_38421 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40478 + 68] = mem[_40478 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40478 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _48949 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48949] = 30
                                        mem[_48949 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _51184 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_51184 + idx + 68] = mem[_48949 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51184 + 68] = mem[_51184 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51184 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32385 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32385] = 30
                                        mem[_32385 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32623 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32623 + idx + 68] = mem[_32385 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32623 + 68] = mem[_32623 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32623 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33372 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33372] = 30
                                        mem[_33372 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33731 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33731 + idx + 68] = mem[_33372 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33731 + 68] = mem[_33731 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33731 + -mem[64] + 100
                                    _32447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32447] = 26
                                    mem[_32447 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _34952 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34952] = 30
                                        mem[_34952 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _38427 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38427] = 30
                                        mem[_38427 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _40485 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_40485 + idx + 68] = mem[_38427 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_40485 + 68] = mem[_40485 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _40485 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _48954 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48954] = 30
                                        mem[_48954 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _51189 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_51189 + idx + 68] = mem[_48954 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51189 + 68] = mem[_51189 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51189 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35641 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35641] = 30
                                    mem[_35641 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _36493 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_36493 + idx + 68] = mem[_35641 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36493 + 68] = mem[_36493 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36493 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _40484 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40484] = 30
                                    mem[_40484 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _42798 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_42798 + idx + 68] = mem[_40484 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42798 + 68] = mem[_42798 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42798 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _51188 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51188] = 30
                                    mem[_51188 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _53141 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_53141 + idx + 68] = mem[_51188 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53141 + 68] = mem[_53141 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53141 + -mem[64] + 100
                                _31931 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31931] = 26
                                mem[_31931 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32753 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32753] = 26
                                    mem[_32753 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                else:
                                    _32752 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32752] = 26
                                    mem[_32752 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if arg2 / 100 * reflectFees > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _32310 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32310] = 26
                                        mem[_32310 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34678 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34678] = 30
                                                mem[_34678 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _36772 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36772] = 30
                                                mem[_36772 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _38413 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38413 + idx + 68] = mem[_36772 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38413 + 68] = mem[_38413 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38413 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _46160 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_46160] = 30
                                                mem[_46160 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _48935 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48935 + idx + 68] = mem[_46160 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48935 + 68] = mem[_48935 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48935 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34949 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34949] = 30
                                            mem[_34949 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _35631 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35631 + idx + 68] = mem[_34949 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35631 + 68] = mem[_35631 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35631 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38412 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38412] = 30
                                            mem[_38412 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _40459 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40459 + idx + 68] = mem[_38412 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40459 + 68] = mem[_40459 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40459 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _48934 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48934] = 30
                                            mem[_48934 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _51170 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_51170 + idx + 68] = mem[_48934 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51170 + 68] = mem[_51170 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51170 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _34948 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34948] = 30
                                            mem[_34948 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35628 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35628 + idx + 68] = mem[_34948 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35628 + 68] = mem[_35628 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35628 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38411 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38411] = 30
                                            mem[_38411 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _40456 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40456 + idx + 68] = mem[_38411 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40456 + 68] = mem[_40456 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40456 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _48933 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48933] = 30
                                            mem[_48933 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _51167 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_51167 + idx + 68] = mem[_48933 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51167 + 68] = mem[_51167 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51167 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35627 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35627] = 30
                                        mem[_35627 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _36476 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36476 + idx + 68] = mem[_35627 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36476 + 68] = mem[_36476 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36476 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40455 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40455] = 30
                                        mem[_40455 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _42762 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42762 + idx + 68] = mem[_40455 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42762 + 68] = mem[_42762 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42762 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _51166 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51166] = 30
                                        mem[_51166 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _53113 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_53113 + idx + 68] = mem[_51166 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53113 + 68] = mem[_53113 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53113 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _32384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32384] = 30
                                        mem[_32384 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _32620 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_32620 + idx + 68] = mem[_32384 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32620 + 68] = mem[_32620 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _32620 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _33370 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33370] = 30
                                        mem[_33370 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _33726 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_33726 + idx + 68] = mem[_33370 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33726 + 68] = mem[_33726 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33726 + -mem[64] + 100
                                    _32446 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32446] = 26
                                    mem[_32446 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            _34950 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34950] = 30
                                            mem[_34950 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38420 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38420] = 30
                                            mem[_38420 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _40469 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40469 + idx + 68] = mem[_38420 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40469 + 68] = mem[_40469 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40469 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _48942 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48942] = 30
                                            mem[_48942 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _51177 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_51177 + idx + 68] = mem[_48942 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51177 + 68] = mem[_51177 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51177 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35635 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35635] = 30
                                        mem[_35635 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                            _36486 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36486 + idx + 68] = mem[_35635 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36486 + 68] = mem[_36486 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36486 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40468 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40468] = 30
                                        mem[_40468 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _42778 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42778 + idx + 68] = mem[_40468 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42778 + 68] = mem[_42778 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42778 + -mem[64] + 100
                                        if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        _51176 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51176] = 30
                                        mem[_51176 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _53125 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_53125 + idx + 68] = mem[_51176 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53125 + 68] = mem[_53125 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53125 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not arg2 / 100 * reflectFees:
                                        _35634 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35634] = 30
                                        mem[_35634 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36483 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36483 + idx + 68] = mem[_35634 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36483 + 68] = mem[_36483 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36483 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40467 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40467] = 30
                                        mem[_40467 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _42775 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42775 + idx + 68] = mem[_40467 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42775 + 68] = mem[_42775 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42775 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _51175 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51175] = 30
                                        mem[_51175 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _53122 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_53122 + idx + 68] = mem[_51175 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53122 + 68] = mem[_53122 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53122 + -mem[64] + 100
                                    require arg2 / 100 * reflectFees
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36482 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36482] = 30
                                    mem[_36482 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _37791 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_37791 + idx + 68] = mem[_36482 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_37791 + 68] = mem[_37791 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _37791 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _42774 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42774] = 30
                                    mem[_42774 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _45178 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_45178 + idx + 68] = mem[_42774 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45178 + 68] = mem[_45178 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45178 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                    _53121 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53121] = 30
                                    mem[_53121 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                        return 1
                                    _55086 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_55086 + idx + 68] = mem[_53121 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55086 + 68] = mem[_55086 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55086 + -mem[64] + 100
                                _31926 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31926] = 26
                                mem[_31926 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 1000 * 10^18:
                                    _32751 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32751] = 26
                                    mem[_32751 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                else:
                                    _32750 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32750] = 26
                                    mem[_32750 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                            if arg2 / 100 * reflectFees * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += arg2 / 100 * reflectFees
                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                        else:
                            mem[0] = msg.sender
                            mem[32] = 4
                            if not stor4[address(msg.sender)]:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                if not arg2 / 100:
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32295 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32295] = 26
                                            mem[_32295 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                _34673 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34673] = 30
                                                mem[_34673 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _36751 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36751] = 30
                                                mem[_36751 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _38365 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_38365 + idx + 68] = mem[_36751 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38365 + 68] = mem[_38365 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38365 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _46080 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_46080] = 30
                                                mem[_46080 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _48818 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48818 + idx + 68] = mem[_46080 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48818 + 68] = mem[_48818 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48818 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _34936 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34936] = 30
                                            mem[_34936 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _35587 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_35587 + idx + 68] = mem[_34936 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_35587 + 68] = mem[_35587 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _35587 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38364 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38364] = 30
                                            mem[_38364 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _40349 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40349 + idx + 68] = mem[_38364 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40349 + 68] = mem[_40349 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40349 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _48817 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48817] = 30
                                            mem[_48817 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _51046 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_51046 + idx + 68] = mem[_48817 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51046 + 68] = mem[_51046 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51046 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32379 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32379] = 30
                                            mem[_32379 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32605 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32605 + idx + 68] = mem[_32379 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32605 + 68] = mem[_32605 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32605 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33360 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33360] = 30
                                            mem[_33360 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33701 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33701 + idx + 68] = mem[_33360 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33701 + 68] = mem[_33701 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33701 + -mem[64] + 100
                                        _32441 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32441] = 26
                                        mem[_32441 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _34937 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34937] = 30
                                            mem[_34937 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _38370 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38370] = 30
                                            mem[_38370 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _40356 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_40356 + idx + 68] = mem[_38370 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_40356 + 68] = mem[_40356 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _40356 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _48822 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48822] = 30
                                            mem[_48822 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _51051 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_51051 + idx + 68] = mem[_48822 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51051 + 68] = mem[_51051 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51051 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _35590 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35590] = 30
                                        mem[_35590 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _36421 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_36421 + idx + 68] = mem[_35590 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36421 + 68] = mem[_36421 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36421 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _40355 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40355] = 30
                                        mem[_40355 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _42634 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_42634 + idx + 68] = mem[_40355 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42634 + 68] = mem[_42634 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42634 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        _51050 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51050] = 30
                                        mem[_51050 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _53000 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_53000 + idx + 68] = mem[_51050 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53000 + 68] = mem[_53000 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53000 + -mem[64] + 100
                                    _31901 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31901] = 26
                                    mem[_31901 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32741 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32741] = 26
                                        mem[_32741 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    else:
                                        _32740 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32740] = 26
                                        mem[_32740 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    require arg2 / 100
                                    if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if arg2 / 100 * reflectFees > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = 1000 * 10^18
                                    t = stor6
                                    while idx < stor5.length:
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        if stor1[stor5[idx]] > t:
                                            _32292 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32292] = 26
                                            mem[_32292 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    _34672 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34672] = 30
                                                    mem[_34672 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _36748 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_36748] = 30
                                                    mem[_36748 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _38356 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_38356 + idx + 68] = mem[_36748 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_38356 + 68] = mem[_38356 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _38356 + -mem[64] + 100
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _46069 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_46069] = 30
                                                    mem[_46069 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _48803 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_48803 + idx + 68] = mem[_46069 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_48803 + 68] = mem[_48803 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _48803 + -mem[64] + 100
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _34934 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34934] = 30
                                                mem[_34934 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    _35580 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35580 + idx + 68] = mem[_34934 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35580 + 68] = mem[_35580 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35580 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38355 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38355] = 30
                                                mem[_38355 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _40330 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40330 + idx + 68] = mem[_38355 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40330 + 68] = mem[_40330 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40330 + -mem[64] + 100
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                _48802 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48802] = 30
                                                mem[_48802 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _51032 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_51032 + idx + 68] = mem[_48802 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51032 + 68] = mem[_51032 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51032 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                _34933 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34933] = 30
                                                mem[_34933 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    _35577 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35577 + idx + 68] = mem[_34933 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35577 + 68] = mem[_35577 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35577 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38354 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38354] = 30
                                                mem[_38354 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _40327 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40327 + idx + 68] = mem[_38354 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40327 + 68] = mem[_40327 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40327 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                _48801 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48801] = 30
                                                mem[_48801 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _51029 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_51029 + idx + 68] = mem[_48801 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51029 + 68] = mem[_51029 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51029 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35576 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35576] = 30
                                            mem[_35576 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                _36404 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36404 + idx + 68] = mem[_35576 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36404 + 68] = mem[_36404 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36404 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40326 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40326] = 30
                                            mem[_40326 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _42598 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42598 + idx + 68] = mem[_40326 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42598 + 68] = mem[_42598 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42598 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            _51028 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51028] = 30
                                            mem[_51028 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52972 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52972 + idx + 68] = mem[_51028 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52972 + 68] = mem[_52972 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52972 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        if stor2[stor5[idx]] <= s:
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            _32378 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32378] = 30
                                            mem[_32378 + 32] = 'SafeMath: subtraction overflow'
                                            if stor1[stor5[idx]] > t:
                                                _32602 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_32602 + idx + 68] = mem[_32378 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_32602 + 68] = mem[_32602 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _32602 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            _33358 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33358] = 30
                                            mem[_33358 + 32] = 'SafeMath: subtraction overflow'
                                            if stor2[stor5[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor2[stor5[idx]]
                                                t = t - stor1[stor5[idx]]
                                                continue 
                                            _33696 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_33696 + idx + 68] = mem[_33358 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33696 + 68] = mem[_33696 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33696 + -mem[64] + 100
                                        _32440 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32440] = 26
                                        mem[_32440 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                _34935 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34935] = 30
                                                mem[_34935 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38363 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38363] = 30
                                                mem[_38363 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _40340 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40340 + idx + 68] = mem[_38363 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40340 + 68] = mem[_40340 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40340 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _48810 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48810] = 30
                                                mem[_48810 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _51039 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_51039 + idx + 68] = mem[_48810 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51039 + 68] = mem[_51039 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51039 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35584 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35584] = 30
                                            mem[_35584 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                _36414 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36414 + idx + 68] = mem[_35584 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36414 + 68] = mem[_36414 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36414 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40339 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40339] = 30
                                            mem[_40339 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _42614 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42614 + idx + 68] = mem[_40339 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42614 + 68] = mem[_42614 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42614 + -mem[64] + 100
                                            if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            _51038 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51038] = 30
                                            mem[_51038 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52984 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52984 + idx + 68] = mem[_51038 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52984 + 68] = mem[_52984 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52984 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not arg2 / 100 * reflectFees:
                                            _35583 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35583] = 30
                                            mem[_35583 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _36411 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36411 + idx + 68] = mem[_35583 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36411 + 68] = mem[_36411 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36411 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40338 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40338] = 30
                                            mem[_40338 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _42611 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42611 + idx + 68] = mem[_40338 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42611 + 68] = mem[_42611 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42611 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _51037 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51037] = 30
                                            mem[_51037 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _52981 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_52981 + idx + 68] = mem[_51037 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52981 + 68] = mem[_52981 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52981 + -mem[64] + 100
                                        require arg2 / 100 * reflectFees
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _36410 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36410] = 30
                                        mem[_36410 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _37686 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_37686 + idx + 68] = mem[_36410 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_37686 + 68] = mem[_37686 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _37686 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _42610 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42610] = 30
                                        mem[_42610 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _45002 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_45002 + idx + 68] = mem[_42610 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45002 + 68] = mem[_45002 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45002 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                        _52980 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52980] = 30
                                        mem[_52980 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                            stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += arg2 / 100 * reflectFees
                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                            return 1
                                        _54952 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_54952 + idx + 68] = mem[_52980 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54952 + 68] = mem[_54952 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54952 + -mem[64] + 100
                                    _31896 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31896] = 26
                                    mem[_31896 + 32] = 'SafeMath: division by zero'
                                    if t < stor6 / 1000 * 10^18:
                                        _32739 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32739] = 26
                                        mem[_32739 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        else:
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                    else:
                                        _32738 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32738] = 26
                                        mem[_32738 + 32] = 'SafeMath: division by zero'
                                        if s <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require s
                                        if not arg2:
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                        else:
                                            require arg2
                                            if arg2 * t / s / arg2 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                if 0 > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * t / s
                                                if 0 > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                                if arg2 / 100 * reflectFees * t / s > stor6:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += arg2 / 100 * reflectFees
                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                            else:
                                mem[0] = arg1
                                mem[32] = 4
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                if not stor4[address(arg1)]:
                                    if not arg2 / 100:
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = 1000 * 10^18
                                        t = stor6
                                        while idx < stor5.length:
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            if stor1[stor5[idx]] > t:
                                                _32301 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32301] = 26
                                                mem[_32301 + 32] = 'SafeMath: division by zero'
                                                if not arg2:
                                                    _34675 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34675] = 30
                                                    mem[_34675 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _36759 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_36759] = 30
                                                    mem[_36759 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _38384 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_38384 + idx + 68] = mem[_36759 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_38384 + 68] = mem[_38384 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _38384 + -mem[64] + 100
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _46103 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_46103] = 30
                                                    mem[_46103 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                        return 1
                                                    _48851 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_48851 + idx + 68] = mem[_46103 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_48851 + 68] = mem[_48851 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _48851 + -mem[64] + 100
                                                require arg2
                                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _34941 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34941] = 30
                                                mem[_34941 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    _35604 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35604 + idx + 68] = mem[_34941 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35604 + 68] = mem[_35604 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35604 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38383 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38383] = 30
                                                mem[_38383 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _40392 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40392 + idx + 68] = mem[_38383 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40392 + 68] = mem[_40392 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40392 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                _48850 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48850] = 30
                                                mem[_48850 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _51082 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_51082 + idx + 68] = mem[_48850 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51082 + 68] = mem[_51082 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51082 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            if stor2[stor5[idx]] <= s:
                                                require idx < stor5.length
                                                mem[0] = stor5[idx]
                                                mem[32] = 1
                                                _32381 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32381] = 30
                                                mem[_32381 + 32] = 'SafeMath: subtraction overflow'
                                                if stor1[stor5[idx]] > t:
                                                    _32611 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_32611 + idx + 68] = mem[_32381 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_32611 + 68] = mem[_32611 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _32611 + -mem[64] + 100
                                                require idx < stor5.length
                                                mem[0] = stor5[idx]
                                                mem[32] = 2
                                                _33364 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33364] = 30
                                                mem[_33364 + 32] = 'SafeMath: subtraction overflow'
                                                if stor2[stor5[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor2[stor5[idx]]
                                                    t = t - stor1[stor5[idx]]
                                                    continue 
                                                _33711 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_33711 + idx + 68] = mem[_33364 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33711 + 68] = mem[_33711 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33711 + -mem[64] + 100
                                            _32443 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32443] = 26
                                            mem[_32443 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                _34942 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34942] = 30
                                                mem[_34942 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _38389 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38389] = 30
                                                mem[_38389 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _40399 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40399 + idx + 68] = mem[_38389 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40399 + 68] = mem[_40399 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40399 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _48855 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48855] = 30
                                                mem[_48855 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _51087 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_51087 + idx + 68] = mem[_48855 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51087 + 68] = mem[_51087 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51087 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35607 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35607] = 30
                                            mem[_35607 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _36445 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36445 + idx + 68] = mem[_35607 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36445 + 68] = mem[_36445 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36445 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _40398 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40398] = 30
                                            mem[_40398 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _42690 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42690 + idx + 68] = mem[_40398 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42690 + 68] = mem[_42690 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42690 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _51086 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51086] = 30
                                            mem[_51086 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _53044 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_53044 + idx + 68] = mem[_51086 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53044 + 68] = mem[_53044 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53044 + -mem[64] + 100
                                        _31911 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31911] = 26
                                        mem[_31911 + 32] = 'SafeMath: division by zero'
                                        if t < stor6 / 1000 * 10^18:
                                            _32745 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32745] = 26
                                            mem[_32745 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                require arg2
                                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        else:
                                            _32744 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32744] = 26
                                            mem[_32744 + 32] = 'SafeMath: division by zero'
                                            if s <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require s
                                            if not arg2:
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                require arg2
                                                if arg2 * t / s / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = 1000 * 10^18
                                        t = stor6
                                        while idx < stor5.length:
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            if stor1[stor5[idx]] > t:
                                                _32298 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32298] = 26
                                                mem[_32298 + 32] = 'SafeMath: division by zero'
                                                if not arg2:
                                                    if not arg2 / 100 * reflectFees:
                                                        _34674 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_34674] = 30
                                                        mem[_34674 + 32] = 'SafeMath: subtraction overflow'
                                                        mem[0] = msg.sender
                                                        mem[32] = 1
                                                        _36756 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_36756] = 30
                                                        mem[_36756 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor1[address(msg.sender)]:
                                                            _38375 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_38375 + idx + 68] = mem[_36756 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_38375 + 68] = mem[_38375 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _38375 + -mem[64] + 100
                                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = arg1
                                                        mem[32] = 1
                                                        _46092 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_46092] = 30
                                                        mem[_46092 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 <= stor6:
                                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += arg2 / 100 * reflectFees
                                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                            return 1
                                                        _48836 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_48836 + idx + 68] = mem[_46092 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_48836 + 68] = mem[_48836 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _48836 + -mem[64] + 100
                                                    require arg2 / 100 * reflectFees
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _34939 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34939] = 30
                                                    mem[_34939 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                        _35597 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_35597 + idx + 68] = mem[_34939 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_35597 + 68] = mem[_35597 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _35597 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _38374 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_38374] = 30
                                                    mem[_38374 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _40373 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_40373 + idx + 68] = mem[_38374 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_40373 + 68] = mem[_40373 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _40373 + -mem[64] + 100
                                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    _48835 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_48835] = 30
                                                    mem[_48835 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _51068 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_51068 + idx + 68] = mem[_48835 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_51068 + 68] = mem[_51068 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _51068 + -mem[64] + 100
                                                require arg2
                                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not arg2 / 100 * reflectFees:
                                                    _34938 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34938] = 30
                                                    mem[_34938 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                                        _35594 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_35594 + idx + 68] = mem[_34938 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_35594 + 68] = mem[_35594 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _35594 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _38373 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_38373] = 30
                                                    mem[_38373 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                        _40370 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_40370 + idx + 68] = mem[_38373 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_40370 + 68] = mem[_40370 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _40370 + -mem[64] + 100
                                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                    _48834 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_48834] = 30
                                                    mem[_48834 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _51065 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_51065 + idx + 68] = mem[_48834 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_51065 + 68] = mem[_51065 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _51065 + -mem[64] + 100
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _35593 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35593] = 30
                                                mem[_35593 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                    _36428 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_36428 + idx + 68] = mem[_35593 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_36428 + 68] = mem[_36428 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _36428 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _40369 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40369] = 30
                                                mem[_40369 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _42654 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_42654 + idx + 68] = mem[_40369 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42654 + 68] = mem[_42654 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42654 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                                _51064 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51064] = 30
                                                mem[_51064 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _53016 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_53016 + idx + 68] = mem[_51064 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53016 + 68] = mem[_53016 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53016 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            if stor2[stor5[idx]] <= s:
                                                require idx < stor5.length
                                                mem[0] = stor5[idx]
                                                mem[32] = 1
                                                _32380 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32380] = 30
                                                mem[_32380 + 32] = 'SafeMath: subtraction overflow'
                                                if stor1[stor5[idx]] > t:
                                                    _32608 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_32608 + idx + 68] = mem[_32380 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_32608 + 68] = mem[_32608 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _32608 + -mem[64] + 100
                                                require idx < stor5.length
                                                mem[0] = stor5[idx]
                                                mem[32] = 2
                                                _33362 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33362] = 30
                                                mem[_33362 + 32] = 'SafeMath: subtraction overflow'
                                                if stor2[stor5[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor2[stor5[idx]]
                                                    t = t - stor1[stor5[idx]]
                                                    continue 
                                                _33706 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_33706 + idx + 68] = mem[_33362 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33706 + 68] = mem[_33706 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33706 + -mem[64] + 100
                                            _32442 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32442] = 26
                                            mem[_32442 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    _34940 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34940] = 30
                                                    mem[_34940 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _38382 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_38382] = 30
                                                    mem[_38382 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _40383 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_40383 + idx + 68] = mem[_38382 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_40383 + 68] = mem[_40383 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _40383 + -mem[64] + 100
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _48843 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_48843] = 30
                                                    mem[_48843 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _51075 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_51075 + idx + 68] = mem[_48843 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_51075 + 68] = mem[_51075 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _51075 + -mem[64] + 100
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _35601 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35601] = 30
                                                mem[_35601 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    _36438 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_36438 + idx + 68] = mem[_35601 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_36438 + 68] = mem[_36438 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _36438 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _40382 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40382] = 30
                                                mem[_40382 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _42670 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_42670 + idx + 68] = mem[_40382 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42670 + 68] = mem[_42670 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42670 + -mem[64] + 100
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                _51074 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51074] = 30
                                                mem[_51074 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _53028 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_53028 + idx + 68] = mem[_51074 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53028 + 68] = mem[_53028 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53028 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                _35600 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35600] = 30
                                                mem[_35600 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    _36435 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_36435 + idx + 68] = mem[_35600 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_36435 + 68] = mem[_36435 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _36435 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _40381 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40381] = 30
                                                mem[_40381 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _42667 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_42667 + idx + 68] = mem[_40381 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42667 + 68] = mem[_42667 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42667 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                _51073 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51073] = 30
                                                mem[_51073 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _53025 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_53025 + idx + 68] = mem[_51073 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53025 + 68] = mem[_53025 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53025 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _36434 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36434] = 30
                                            mem[_36434 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                _37721 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_37721 + idx + 68] = mem[_36434 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37721 + 68] = mem[_37721 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37721 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _42666 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42666] = 30
                                            mem[_42666 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _45064 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45064 + idx + 68] = mem[_42666 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45064 + 68] = mem[_45064 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45064 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            _53024 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_53024] = 30
                                            mem[_53024 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _55002 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_55002 + idx + 68] = mem[_53024 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_55002 + 68] = mem[_55002 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _55002 + -mem[64] + 100
                                        _31906 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31906] = 26
                                        mem[_31906 + 32] = 'SafeMath: division by zero'
                                        if t < stor6 / 1000 * 10^18:
                                            _32743 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32743] = 26
                                            mem[_32743 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    if 0 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if 0 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    require arg2 / 100 * reflectFees
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            else:
                                                require arg2
                                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not arg2 / 100 * reflectFees:
                                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                    if 0 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    require arg2 / 100 * reflectFees
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        else:
                                            _32742 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32742] = 26
                                            mem[_32742 + 32] = 'SafeMath: division by zero'
                                            if s <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require s
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    if 0 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if 0 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    require arg2 / 100 * reflectFees
                                                    if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if arg2 / 100 * reflectFees * t / s > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                                    if arg2 / 100 * reflectFees * t / s > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                            else:
                                                require arg2
                                                if arg2 * t / s / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not arg2 / 100 * reflectFees:
                                                    if 0 > arg2 * t / s:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] += arg2 * t / s
                                                    if 0 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    require arg2 / 100 * reflectFees
                                                    if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                                    if arg2 / 100 * reflectFees * t / s > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                else:
                                    if not arg2 / 100:
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = 1000 * 10^18
                                        t = stor6
                                        while idx < stor5.length:
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            if stor1[stor5[idx]] > t:
                                                _32307 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32307] = 26
                                                mem[_32307 + 32] = 'SafeMath: division by zero'
                                                if not arg2:
                                                    _34677 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34677] = 30
                                                    mem[_34677 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 2
                                                    _36767 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_36767] = 30
                                                    mem[_36767 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        _38403 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_38403 + idx + 68] = mem[_36767 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_38403 + 68] = mem[_38403 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _38403 + -mem[64] + 100
                                                    stor2[address(msg.sender)] -= arg2
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _41147 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41147] = 30
                                                    mem[_41147 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _43428 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_43428 + idx + 68] = mem[_41147 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_43428 + 68] = mem[_43428 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _43428 + -mem[64] + 100
                                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] += arg2
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _55059 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_55059] = 30
                                                    mem[_55059 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                        return 1
                                                    _56960 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_56960 + idx + 68] = mem[_55059 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_56960 + 68] = mem[_56960 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _56960 + -mem[64] + 100
                                                require arg2
                                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _34946 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34946] = 30
                                                mem[_34946 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    _35621 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_35621 + idx + 68] = mem[_34946 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_35621 + 68] = mem[_35621 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _35621 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _38402 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38402] = 30
                                                mem[_38402 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _40435 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40435 + idx + 68] = mem[_38402 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40435 + 68] = mem[_40435 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40435 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _43425 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43425] = 30
                                                mem[_43425 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _46140 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_46140 + idx + 68] = mem[_43425 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_46140 + 68] = mem[_46140 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _46140 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] += arg2
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                _56959 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56959] = 30
                                                mem[_56959 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _58605 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_58605 + idx + 68] = mem[_56959 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58605 + 68] = mem[_58605 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58605 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            if stor2[stor5[idx]] <= s:
                                                require idx < stor5.length
                                                mem[0] = stor5[idx]
                                                mem[32] = 1
                                                _32383 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32383] = 30
                                                mem[_32383 + 32] = 'SafeMath: subtraction overflow'
                                                if stor1[stor5[idx]] > t:
                                                    _32617 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_32617 + idx + 68] = mem[_32383 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_32617 + 68] = mem[_32617 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _32617 + -mem[64] + 100
                                                require idx < stor5.length
                                                mem[0] = stor5[idx]
                                                mem[32] = 2
                                                _33368 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33368] = 30
                                                mem[_33368 + 32] = 'SafeMath: subtraction overflow'
                                                if stor2[stor5[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor2[stor5[idx]]
                                                    t = t - stor1[stor5[idx]]
                                                    continue 
                                                _33721 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_33721 + idx + 68] = mem[_33368 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33721 + 68] = mem[_33721 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33721 + -mem[64] + 100
                                            _32445 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32445] = 26
                                            mem[_32445 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                _34947 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34947] = 30
                                                mem[_34947 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _38408 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38408] = 30
                                                mem[_38408 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _40442 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_40442 + idx + 68] = mem[_38408 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_40442 + 68] = mem[_40442 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _40442 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _43431 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_43431] = 30
                                                mem[_43431 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _46149 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_46149 + idx + 68] = mem[_43431 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_46149 + 68] = mem[_46149 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _46149 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] += arg2
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _56964 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56964] = 30
                                                mem[_56964 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _58610 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_58610 + idx + 68] = mem[_56964 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58610 + 68] = mem[_58610 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58610 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _35624 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35624] = 30
                                            mem[_35624 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _36469 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_36469 + idx + 68] = mem[_35624 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36469 + 68] = mem[_36469 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36469 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _40441 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40441] = 30
                                            mem[_40441 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _42742 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_42742 + idx + 68] = mem[_40441 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42742 + 68] = mem[_42742 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42742 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _46146 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46146] = 30
                                            mem[_46146 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _48916 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_48916 + idx + 68] = mem[_46146 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48916 + 68] = mem[_48916 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48916 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] += arg2
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                            _58609 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58609] = 30
                                            mem[_58609 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _59720 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_59720 + idx + 68] = mem[_58609 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59720 + 68] = mem[_59720 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59720 + -mem[64] + 100
                                        _31921 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31921] = 26
                                        mem[_31921 + 32] = 'SafeMath: division by zero'
                                        if t < stor6 / 1000 * 10^18:
                                            _32749 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32749] = 26
                                            mem[_32749 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] += arg2
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                require arg2
                                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] += arg2
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                        else:
                                            _32748 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32748] = 26
                                            mem[_32748 + 32] = 'SafeMath: division by zero'
                                            if s <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require s
                                            if not arg2:
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if 0 > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] += arg2
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                require arg2
                                                if arg2 * t / s / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > arg2 * t / s:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor2[address(msg.sender)] -= arg2
                                                if arg2 * t / s > stor1[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] += arg2
                                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        require arg2 / 100
                                        if arg2 / 100 * reflectFees / arg2 / 100 != reflectFees:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if arg2 / 100 * reflectFees > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = 1000 * 10^18
                                        t = stor6
                                        while idx < stor5.length:
                                            mem[0] = stor5[idx]
                                            mem[32] = 1
                                            if stor1[stor5[idx]] > t:
                                                _32304 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32304] = 26
                                                mem[_32304 + 32] = 'SafeMath: division by zero'
                                                if not arg2:
                                                    if not arg2 / 100 * reflectFees:
                                                        _34676 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_34676] = 30
                                                        mem[_34676 + 32] = 'SafeMath: subtraction overflow'
                                                        mem[0] = msg.sender
                                                        mem[32] = 2
                                                        _36764 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_36764] = 30
                                                        mem[_36764 + 32] = 'SafeMath: subtraction overflow'
                                                        if arg2 > stor2[address(msg.sender)]:
                                                            _38394 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_38394 + idx + 68] = mem[_36764 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_38394 + 68] = mem[_38394 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _38394 + -mem[64] + 100
                                                        stor2[address(msg.sender)] -= arg2
                                                        mem[0] = msg.sender
                                                        mem[32] = 1
                                                        _41138 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_41138] = 30
                                                        mem[_41138 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor1[address(msg.sender)]:
                                                            _43419 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[_43419 + idx + 68] = mem[_41138 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_43419 + 68] = mem[_43419 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _43419 + -mem[64] + 100
                                                        if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = arg1
                                                        mem[32] = 1
                                                        _55047 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_55047] = 30
                                                        mem[_55047 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 <= stor6:
                                                            if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += arg2 / 100 * reflectFees
                                                            emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                            return 1
                                                        _56951 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_56951 + idx + 68] = mem[_55047 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_56951 + 68] = mem[_56951 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _56951 + -mem[64] + 100
                                                    require arg2 / 100 * reflectFees
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _34944 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34944] = 30
                                                    mem[_34944 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                        _35614 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_35614 + idx + 68] = mem[_34944 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_35614 + 68] = mem[_35614 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _35614 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    mem[32] = 2
                                                    _38393 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_38393] = 30
                                                    mem[_38393 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        _40416 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_40416 + idx + 68] = mem[_38393 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_40416 + 68] = mem[_40416 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _40416 + -mem[64] + 100
                                                    stor2[address(msg.sender)] -= arg2
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _43416 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_43416] = 30
                                                    mem[_43416 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _46119 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_46119 + idx + 68] = mem[_43416 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_46119 + 68] = mem[_46119 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _46119 + -mem[64] + 100
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    _56950 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_56950] = 30
                                                    mem[_56950 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                        stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _58591 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_58591 + idx + 68] = mem[_56950 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_58591 + 68] = mem[_58591 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _58591 + -mem[64] + 100
                                                require arg2
                                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not arg2 / 100 * reflectFees:
                                                    _34943 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34943] = 30
                                                    mem[_34943 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                                        _35611 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_35611 + idx + 68] = mem[_34943 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_35611 + 68] = mem[_35611 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _35611 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    mem[32] = 2
                                                    _38392 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_38392] = 30
                                                    mem[_38392 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        _40413 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_40413 + idx + 68] = mem[_38392 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_40413 + 68] = mem[_40413 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _40413 + -mem[64] + 100
                                                    stor2[address(msg.sender)] -= arg2
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _43413 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_43413] = 30
                                                    mem[_43413 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                        _46116 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_46116 + idx + 68] = mem[_43413 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_46116 + 68] = mem[_46116 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _46116 + -mem[64] + 100
                                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                    _56949 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_56949] = 30
                                                    mem[_56949 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _58588 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_58588 + idx + 68] = mem[_56949 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_58588 + 68] = mem[_58588 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _58588 + -mem[64] + 100
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _35610 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35610] = 30
                                                mem[_35610 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                    _36452 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_36452 + idx + 68] = mem[_35610 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_36452 + 68] = mem[_36452 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _36452 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _40412 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40412] = 30
                                                mem[_40412 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _42710 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_42710 + idx + 68] = mem[_40412 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42710 + 68] = mem[_42710 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42710 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _46113 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_46113] = 30
                                                mem[_46113 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _48874 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_48874 + idx + 68] = mem[_46113 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_48874 + 68] = mem[_48874 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _48874 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                                _58587 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_58587] = 30
                                                mem[_58587 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _59692 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_59692 + idx + 68] = mem[_58587 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59692 + 68] = mem[_59692 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59692 + -mem[64] + 100
                                            require idx < stor5.length
                                            mem[0] = stor5[idx]
                                            mem[32] = 2
                                            if stor2[stor5[idx]] <= s:
                                                require idx < stor5.length
                                                mem[0] = stor5[idx]
                                                mem[32] = 1
                                                _32382 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32382] = 30
                                                mem[_32382 + 32] = 'SafeMath: subtraction overflow'
                                                if stor1[stor5[idx]] > t:
                                                    _32614 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_32614 + idx + 68] = mem[_32382 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_32614 + 68] = mem[_32614 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _32614 + -mem[64] + 100
                                                require idx < stor5.length
                                                mem[0] = stor5[idx]
                                                mem[32] = 2
                                                _33366 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33366] = 30
                                                mem[_33366 + 32] = 'SafeMath: subtraction overflow'
                                                if stor2[stor5[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor2[stor5[idx]]
                                                    t = t - stor1[stor5[idx]]
                                                    continue 
                                                _33716 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_33716 + idx + 68] = mem[_33366 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33716 + 68] = mem[_33716 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33716 + -mem[64] + 100
                                            _32444 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32444] = 26
                                            mem[_32444 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    _34945 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_34945] = 30
                                                    mem[_34945 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 2
                                                    _38401 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_38401] = 30
                                                    mem[_38401 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        _40426 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_40426 + idx + 68] = mem[_38401 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_40426 + 68] = mem[_40426 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _40426 + -mem[64] + 100
                                                    stor2[address(msg.sender)] -= arg2
                                                    mem[0] = msg.sender
                                                    mem[32] = 1
                                                    _43422 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_43422] = 30
                                                    mem[_43422 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor1[address(msg.sender)]:
                                                        _46131 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[_46131 + idx + 68] = mem[_43422 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_46131 + 68] = mem[_46131 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _46131 + -mem[64] + 100
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 1
                                                    _56956 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_56956] = 30
                                                    mem[_56956 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor6:
                                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += arg2 / 100 * reflectFees
                                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                        return 1
                                                    _58598 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_58598 + idx + 68] = mem[_56956 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_58598 + 68] = mem[_58598 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _58598 + -mem[64] + 100
                                                require arg2 / 100 * reflectFees
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _35618 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35618] = 30
                                                mem[_35618 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                    _36462 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_36462 + idx + 68] = mem[_35618 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_36462 + 68] = mem[_36462 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _36462 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _40425 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40425] = 30
                                                mem[_40425 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _42724 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_42724 + idx + 68] = mem[_40425 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42724 + 68] = mem[_42724 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42724 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _46128 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_46128] = 30
                                                mem[_46128 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _48892 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_48892 + idx + 68] = mem[_46128 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_48892 + 68] = mem[_48892 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _48892 + -mem[64] + 100
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                _58597 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_58597] = 30
                                                mem[_58597 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _59704 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_59704 + idx + 68] = mem[_58597 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59704 + 68] = mem[_59704 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59704 + -mem[64] + 100
                                            require arg2
                                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not arg2 / 100 * reflectFees:
                                                _35617 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35617] = 30
                                                mem[_35617 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                                    _36459 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_36459 + idx + 68] = mem[_35617 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_36459 + 68] = mem[_36459 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _36459 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 2
                                                _40424 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40424] = 30
                                                mem[_40424 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor2[address(msg.sender)]:
                                                    _42721 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_42721 + idx + 68] = mem[_40424 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42721 + 68] = mem[_42721 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42721 + -mem[64] + 100
                                                stor2[address(msg.sender)] -= arg2
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _46125 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_46125] = 30
                                                mem[_46125 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                    _48889 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_48889 + idx + 68] = mem[_46125 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_48889 + 68] = mem[_48889 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _48889 + -mem[64] + 100
                                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                _58596 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_58596] = 30
                                                mem[_58596 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += arg2 / 100 * reflectFees
                                                    emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                    return 1
                                                _59701 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_59701 + idx + 68] = mem[_58596 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59701 + 68] = mem[_59701 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59701 + -mem[64] + 100
                                            require arg2 / 100 * reflectFees
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _36458 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36458] = 30
                                            mem[_36458 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                _37756 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_37756 + idx + 68] = mem[_36458 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_37756 + 68] = mem[_37756 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _37756 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 2
                                            _42720 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42720] = 30
                                            mem[_42720 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor2[address(msg.sender)]:
                                                _45122 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_45122 + idx + 68] = mem[_42720 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45122 + 68] = mem[_45122 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45122 + -mem[64] + 100
                                            stor2[address(msg.sender)] -= arg2
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _48886 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48886] = 30
                                            mem[_48886 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _51123 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_51123 + idx + 68] = mem[_48886 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51123 + 68] = mem[_51123 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51123 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                            _59700 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_59700] = 30
                                            mem[_59700 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 <= stor6:
                                                stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += arg2 / 100 * reflectFees
                                                emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
                                                return 1
                                            _60536 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_60536 + idx + 68] = mem[_59700 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_60536 + 68] = mem[_60536 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _60536 + -mem[64] + 100
                                        _31916 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31916] = 26
                                        mem[_31916 + 32] = 'SafeMath: division by zero'
                                        if t < stor6 / 1000 * 10^18:
                                            _32747 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32747] = 26
                                            mem[_32747 + 32] = 'SafeMath: division by zero'
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor2[address(msg.sender)] -= arg2
                                                    if 0 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if 0 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    require arg2 / 100 * reflectFees
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor2[address(msg.sender)] -= arg2
                                                    if 0 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                            else:
                                                require arg2
                                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not arg2 / 100 * reflectFees:
                                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor2[address(msg.sender)] -= arg2
                                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                                    if 0 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    require arg2 / 100 * reflectFees
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 / arg2 / 100 * reflectFees != stor6 / 1000 * 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor2[address(msg.sender)] -= arg2
                                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (arg2 / 100 * reflectFees * stor6 / 1000 * 10^18)
                                                    if arg2 / 100 * reflectFees * stor6 / 1000 * 10^18 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor6 += -1 * arg2 / 100 * reflectFees * stor6 / 1000 * 10^18
                                        else:
                                            _32746 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32746] = 26
                                            mem[_32746 + 32] = 'SafeMath: division by zero'
                                            if s <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require s
                                            if not arg2:
                                                if not arg2 / 100 * reflectFees:
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor2[address(msg.sender)] -= arg2
                                                    if 0 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if 0 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    require arg2 / 100 * reflectFees
                                                    if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if arg2 / 100 * reflectFees * t / s > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor2[address(msg.sender)] -= arg2
                                                    if 0 > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] += -1 * arg2 / 100 * reflectFees * t / s
                                                    if arg2 / 100 * reflectFees * t / s > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                            else:
                                                require arg2
                                                if arg2 * t / s / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not arg2 / 100 * reflectFees:
                                                    if 0 > arg2 * t / s:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor2[address(msg.sender)] -= arg2
                                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] += arg2 * t / s
                                                    if 0 > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    require arg2 / 100 * reflectFees
                                                    if arg2 / 100 * reflectFees * t / s / arg2 / 100 * reflectFees != t / s:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if arg2 / 100 * reflectFees * t / s > arg2 * t / s:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if arg2 > stor2[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor2[address(msg.sender)] -= arg2
                                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                                    if stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees) < stor2[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (arg2 / 100 * reflectFees)
                                                    if stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s) < stor1[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (arg2 / 100 * reflectFees * t / s)
                                                    if arg2 / 100 * reflectFees * t / s > stor6:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor6 += -1 * arg2 / 100 * reflectFees * t / s
                                        if totalFees + (arg2 / 100 * reflectFees) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += arg2 / 100 * reflectFees
                                        emit Transfer((arg2 - (arg2 / 100 * reflectFees)), msg.sender, arg1);
    return 1
}



}
