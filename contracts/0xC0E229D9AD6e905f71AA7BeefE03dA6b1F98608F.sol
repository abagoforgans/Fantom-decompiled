contract main {




// =====================  Runtime code  =====================


#
#  - leaveStaking(uint256 arg1)
#  - add(uint256 arg1, address arg2, bool arg3)
#  - enterStaking(uint256 arg1)
#  - withdraw(uint256 arg1, uint256 arg2)
#  - emergencyWithdraw(uint256 arg1)
#  - deposit(uint256 arg1, uint256 arg2)
#
address owner;
address brushAddress;
address wftmAddress;
uint256 brushPerSecond;
address artGalleryAddress;
address routerAddress;
array of struct poolInfo;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 startTime;
mapping of uint256 maxBurnAndBuyBackAmounts;
mapping of uint8 stor12;

function poolLength() payable {
    return poolInfo.length
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, poolInfo[arg1].field_256, poolInfo[arg1].field_512, poolInfo[arg1].field_768
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function poolExists(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor12[address(arg1)])
}

function artGallery() payable {
    return artGalleryAddress
}

function brushPerSecond() payable {
    return brushPerSecond
}

function brush() payable {
    return brushAddress
}

function startTime() payable {
    return startTime
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256
}

function wftm() payable {
    return wftmAddress
}

function router() payable {
    return routerAddress
}

function maxBurnAndBuyBackAmounts(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return maxBurnAndBuyBackAmounts[arg1]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_a80d17e2(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(brushAddress)
    call brushAddress.0xf2fde38b with:
         gas gas_remaining wei
        args address(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if arg1 >= poolInfo.length:
        revert with 0, 50
    if block.timestamp > poolInfo[arg1].field_512:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            if poolInfo[arg1].field_256:
                if poolInfo[arg1].field_512 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if block.timestamp < poolInfo[arg1].field_512:
                    revert with 0, 17
                if not block.timestamp - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero', 0
                    require ext_code.size(brushAddress)
                    call brushAddress.mint(address rg1, uint256 rg2) with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero', 0
                        if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                            revert with 0, 17
                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                    else:
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 0, 17
                        if not 0 / totalAllocPoint:
                            revert with 0, 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero', 0
                        if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                            revert with 0, 17
                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                else:
                    if block.timestamp - poolInfo[arg1].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[arg1].field_512:
                        revert with 0, 17
                    if not block.timestamp - poolInfo[arg1].field_512:
                        revert with 0, 18
                    if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) / block.timestamp - poolInfo[arg1].field_512 != brushPerSecond:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero', 0
                        require ext_code.size(brushAddress)
                        call brushAddress.mint(address rg1, uint256 rg2) with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero', 0
                            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                                revert with 0, 17
                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 0, 17
                            if not 0 / totalAllocPoint:
                                revert with 0, 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero', 0
                            if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                                revert with 0, 17
                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) and poolInfo[arg1].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
                            revert with 0, 17
                        if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
                            revert with 0, 18
                        if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) != poolInfo[arg1].field_256:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero', 0
                        require ext_code.size(brushAddress)
                        call brushAddress.mint(address rg1, uint256 rg2) with:
                             gas gas_remaining wei
                            args this.address, (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero', 0
                            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                                revert with 0, 17
                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
                                revert with 0, 17
                            if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
                                revert with 0, 18
                            if 10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero', 0
                            if poolInfo[arg1].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
                                revert with 0, 17
                            if poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
        poolInfo[arg1].field_512 = block.timestamp
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if block.timestamp <= poolInfo[idx].field_512:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _97 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _98 = mem[_97]
        if not mem[_97]:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_256:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _99 = mem[64]
        mem[64] = mem[64] + 64
        mem[_99] = 30
        mem[_99 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_512 > block.timestamp:
            _100 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _100 + 68] = mem[idx + _99 + 32]
                idx = idx + 32
                continue 
            mem[_100 + 98] = 0
            revert with memory
              from mem[64]
               len _100 + -mem[64] + 100
        if block.timestamp < poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            _106 = mem[64]
            mem[64] = mem[64] + 64
            mem[_106] = 26
            mem[_106 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _108 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _108 + 68] = mem[idx + _106 + 32]
                    idx = idx + 32
                    continue 
                mem[_108 + 94] = 0
                revert with memory
                  from mem[64]
                   len _108 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.mint(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _125 = mem[64]
                mem[64] = mem[64] + 64
                mem[_125] = 26
                mem[_125 + 32] = 'SafeMath: division by zero'
                if _98:
                    if poolInfo[idx].field_768 > !(0 / _98):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _98) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _98
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _129 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _129 + 68] = mem[idx + _125 + 32]
                    idx = idx + 32
                    continue 
                mem[_129 + 94] = 0
                revert with memory
                  from mem[64]
                   len _129 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _137 = mem[64]
            mem[64] = mem[64] + 64
            mem[_137] = 26
            mem[_137 + 32] = 'SafeMath: division by zero'
            if _98:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _98):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _98) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _98
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _142 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _142 + 68] = mem[idx + _137 + 32]
                idx = idx + 32
                continue 
            mem[_142 + 94] = 0
            revert with memory
              from mem[64]
               len _142 + -mem[64] + 100
        if block.timestamp - poolInfo[idx].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            revert with 0, 18
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) / block.timestamp - poolInfo[idx].field_512 != brushPerSecond:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            _110 = mem[64]
            mem[64] = mem[64] + 64
            mem[_110] = 26
            mem[_110 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _114 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _114 + 68] = mem[idx + _110 + 32]
                    idx = idx + 32
                    continue 
                mem[_114 + 94] = 0
                revert with memory
                  from mem[64]
                   len _114 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.mint(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_136] = 26
                mem[_136 + 32] = 'SafeMath: division by zero'
                if _98:
                    if poolInfo[idx].field_768 > !(0 / _98):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _98) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _98
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _141 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _141 + 68] = mem[idx + _136 + 32]
                    idx = idx + 32
                    continue 
                mem[_141 + 94] = 0
                revert with memory
                  from mem[64]
                   len _141 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _150 = mem[64]
            mem[64] = mem[64] + 64
            mem[_150] = 26
            mem[_150 + 32] = 'SafeMath: division by zero'
            if _98:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _98):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _98) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _98
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _156 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _156 + 68] = mem[idx + _150 + 32]
                idx = idx + 32
                continue 
            mem[_156 + 94] = 0
            revert with memory
              from mem[64]
               len _156 + -mem[64] + 100
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) and poolInfo[idx].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 17
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 18
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) != poolInfo[idx].field_256:
            revert with 0, 'SafeMath: multiplication overflow'
        _120 = mem[64]
        mem[64] = mem[64] + 64
        mem[_120] = 26
        mem[_120 + 32] = 'SafeMath: division by zero'
        if not totalAllocPoint:
            _124 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _124 + 68] = mem[idx + _120 + 32]
                idx = idx + 32
                continue 
            mem[_124 + 94] = 0
            revert with memory
              from mem[64]
               len _124 + -mem[64] + 100
        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        require ext_code.size(brushAddress)
        call brushAddress.mint(address rg1, uint256 rg2) with:
             gas gas_remaining wei
            args this.address, (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            _149 = mem[64]
            mem[64] = mem[64] + 64
            mem[_149] = 26
            mem[_149 + 32] = 'SafeMath: division by zero'
            if _98:
                if poolInfo[idx].field_768 > !(0 / _98):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (0 / _98) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / _98
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _155 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _155 + 68] = mem[idx + _149 + 32]
                idx = idx + 32
                continue 
            mem[_155 + 94] = 0
            revert with memory
              from mem[64]
               len _155 + -mem[64] + 100
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 17
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 18
        if 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        _165 = mem[64]
        mem[64] = mem[64] + 64
        mem[_165] = 26
        mem[_165 + 32] = 'SafeMath: division by zero'
        if _98:
            if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _98):
                revert with 0, 17
            if poolInfo[idx].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _98) < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _98
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _172 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _172 + 68] = mem[idx + _165 + 32]
            idx = idx + 32
            continue 
        mem[_172 + 94] = 0
        revert with memory
          from mem[64]
           len _172 + -mem[64] + 100
}

function setBrushPerSecondEmissionRate(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if block.timestamp <= poolInfo[idx].field_512:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _99 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _100 = mem[_99]
        if not mem[_99]:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_256:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _101 = mem[64]
        mem[64] = mem[64] + 64
        mem[_101] = 30
        mem[_101 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_512 > block.timestamp:
            _102 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _102 + 68] = mem[idx + _101 + 32]
                idx = idx + 32
                continue 
            mem[_102 + 98] = 0
            revert with memory
              from mem[64]
               len _102 + -mem[64] + 100
        if block.timestamp < poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            _108 = mem[64]
            mem[64] = mem[64] + 64
            mem[_108] = 26
            mem[_108 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _110 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _110 + 68] = mem[idx + _108 + 32]
                    idx = idx + 32
                    continue 
                mem[_110 + 94] = 0
                revert with memory
                  from mem[64]
                   len _110 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.mint(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _127 = mem[64]
                mem[64] = mem[64] + 64
                mem[_127] = 26
                mem[_127 + 32] = 'SafeMath: division by zero'
                if _100:
                    if poolInfo[idx].field_768 > !(0 / _100):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _100) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _100
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _131 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _131 + 68] = mem[idx + _127 + 32]
                    idx = idx + 32
                    continue 
                mem[_131 + 94] = 0
                revert with memory
                  from mem[64]
                   len _131 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _139 = mem[64]
            mem[64] = mem[64] + 64
            mem[_139] = 26
            mem[_139 + 32] = 'SafeMath: division by zero'
            if _100:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _100):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _100) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _100
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _144 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _144 + 68] = mem[idx + _139 + 32]
                idx = idx + 32
                continue 
            mem[_144 + 94] = 0
            revert with memory
              from mem[64]
               len _144 + -mem[64] + 100
        if block.timestamp - poolInfo[idx].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            revert with 0, 18
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) / block.timestamp - poolInfo[idx].field_512 != brushPerSecond:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            _112 = mem[64]
            mem[64] = mem[64] + 64
            mem[_112] = 26
            mem[_112 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _116 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _116 + 68] = mem[idx + _112 + 32]
                    idx = idx + 32
                    continue 
                mem[_116 + 94] = 0
                revert with memory
                  from mem[64]
                   len _116 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.mint(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _138 = mem[64]
                mem[64] = mem[64] + 64
                mem[_138] = 26
                mem[_138 + 32] = 'SafeMath: division by zero'
                if _100:
                    if poolInfo[idx].field_768 > !(0 / _100):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _100) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _100
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _143 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _143 + 68] = mem[idx + _138 + 32]
                    idx = idx + 32
                    continue 
                mem[_143 + 94] = 0
                revert with memory
                  from mem[64]
                   len _143 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _152 = mem[64]
            mem[64] = mem[64] + 64
            mem[_152] = 26
            mem[_152 + 32] = 'SafeMath: division by zero'
            if _100:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _100):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _100) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _100
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _158 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _158 + 68] = mem[idx + _152 + 32]
                idx = idx + 32
                continue 
            mem[_158 + 94] = 0
            revert with memory
              from mem[64]
               len _158 + -mem[64] + 100
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) and poolInfo[idx].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 17
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 18
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) != poolInfo[idx].field_256:
            revert with 0, 'SafeMath: multiplication overflow'
        _122 = mem[64]
        mem[64] = mem[64] + 64
        mem[_122] = 26
        mem[_122 + 32] = 'SafeMath: division by zero'
        if not totalAllocPoint:
            _126 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _126 + 68] = mem[idx + _122 + 32]
                idx = idx + 32
                continue 
            mem[_126 + 94] = 0
            revert with memory
              from mem[64]
               len _126 + -mem[64] + 100
        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        require ext_code.size(brushAddress)
        call brushAddress.mint(address rg1, uint256 rg2) with:
             gas gas_remaining wei
            args this.address, (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            _151 = mem[64]
            mem[64] = mem[64] + 64
            mem[_151] = 26
            mem[_151 + 32] = 'SafeMath: division by zero'
            if _100:
                if poolInfo[idx].field_768 > !(0 / _100):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (0 / _100) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / _100
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _157 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _157 + 68] = mem[idx + _151 + 32]
                idx = idx + 32
                continue 
            mem[_157 + 94] = 0
            revert with memory
              from mem[64]
               len _157 + -mem[64] + 100
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 17
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 18
        if 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        _167 = mem[64]
        mem[64] = mem[64] + 64
        mem[_167] = 26
        mem[_167 + 32] = 'SafeMath: division by zero'
        if _100:
            if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _100):
                revert with 0, 17
            if poolInfo[idx].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _100) < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _100
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _174 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _174 + 68] = mem[idx + _167 + 32]
            idx = idx + 32
            continue 
        mem[_174 + 94] = 0
        revert with memory
          from mem[64]
           len _174 + -mem[64] + 100
    brushPerSecond = arg1
}

function set(uint256 arg1, uint256 arg2, bool arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    require arg3 == arg3
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 >= poolInfo.length:
        revert with 0, 50
    mem[0] = poolInfo[arg1].field_0
    mem[32] = 12
    if not stor12[stor6[arg1].field_0]:
        revert with 0, 'pid does not yet exist'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 6
            if block.timestamp <= poolInfo[idx].field_512:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(poolInfo[idx].field_0)
            staticcall poolInfo[idx].field_0.balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _129 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _131 = mem[_129]
            if not mem[_129]:
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if not poolInfo[idx].field_256:
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _135 = mem[64]
            mem[64] = mem[64] + 64
            mem[_135] = 30
            mem[_135 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_512 > block.timestamp:
                _137 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _137 + 68] = mem[idx + _135 + 32]
                    idx = idx + 32
                    continue 
                mem[_137 + 98] = 0
                revert with memory
                  from mem[64]
                   len _137 + -mem[64] + 100
            if block.timestamp < poolInfo[idx].field_512:
                revert with 0, 17
            if not block.timestamp - poolInfo[idx].field_512:
                _145 = mem[64]
                mem[64] = mem[64] + 64
                mem[_145] = 26
                mem[_145 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _147 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _147 + 68] = mem[idx + _145 + 32]
                        idx = idx + 32
                        continue 
                    mem[_147 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _147 + -mem[64] + 100
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(brushAddress)
                call brushAddress.mint(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _164 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_164] = 26
                    mem[_164 + 32] = 'SafeMath: division by zero'
                    if _131:
                        if poolInfo[idx].field_768 > !(0 / _131):
                            revert with 0, 17
                        if poolInfo[idx].field_768 + (0 / _131) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / _131
                        poolInfo[idx].field_512 = block.timestamp
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _168 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _168 + 68] = mem[idx + _164 + 32]
                        idx = idx + 32
                        continue 
                    mem[_168 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _168 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 0, 17
                if not 0 / totalAllocPoint:
                    revert with 0, 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _176 = mem[64]
                mem[64] = mem[64] + 64
                mem[_176] = 26
                mem[_176 + 32] = 'SafeMath: division by zero'
                if _131:
                    if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _131):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _131) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _131
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _181 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _181 + 68] = mem[idx + _176 + 32]
                    idx = idx + 32
                    continue 
                mem[_181 + 94] = 0
                revert with memory
                  from mem[64]
                   len _181 + -mem[64] + 100
            if block.timestamp - poolInfo[idx].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[idx].field_512:
                revert with 0, 17
            if not block.timestamp - poolInfo[idx].field_512:
                revert with 0, 18
            if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) / block.timestamp - poolInfo[idx].field_512 != brushPerSecond:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
                _149 = mem[64]
                mem[64] = mem[64] + 64
                mem[_149] = 26
                mem[_149 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _153 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _153 + 68] = mem[idx + _149 + 32]
                        idx = idx + 32
                        continue 
                    mem[_153 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _153 + -mem[64] + 100
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(brushAddress)
                call brushAddress.mint(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _175 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_175] = 26
                    mem[_175 + 32] = 'SafeMath: division by zero'
                    if _131:
                        if poolInfo[idx].field_768 > !(0 / _131):
                            revert with 0, 17
                        if poolInfo[idx].field_768 + (0 / _131) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / _131
                        poolInfo[idx].field_512 = block.timestamp
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _180 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _180 + 68] = mem[idx + _175 + 32]
                        idx = idx + 32
                        continue 
                    mem[_180 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _180 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 0, 17
                if not 0 / totalAllocPoint:
                    revert with 0, 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _189 = mem[64]
                mem[64] = mem[64] + 64
                mem[_189] = 26
                mem[_189 + 32] = 'SafeMath: division by zero'
                if _131:
                    if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _131):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _131) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _131
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _195 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _195 + 68] = mem[idx + _189 + 32]
                    idx = idx + 32
                    continue 
                mem[_195 + 94] = 0
                revert with memory
                  from mem[64]
                   len _195 + -mem[64] + 100
            if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) and poolInfo[idx].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
                revert with 0, 17
            if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
                revert with 0, 18
            if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            _159 = mem[64]
            mem[64] = mem[64] + 64
            mem[_159] = 26
            mem[_159 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _163 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _163 + 68] = mem[idx + _159 + 32]
                    idx = idx + 32
                    continue 
                mem[_163 + 94] = 0
                revert with memory
                  from mem[64]
                   len _163 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.mint(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args this.address, (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
                _188 = mem[64]
                mem[64] = mem[64] + 64
                mem[_188] = 26
                mem[_188 + 32] = 'SafeMath: division by zero'
                if _131:
                    if poolInfo[idx].field_768 > !(0 / _131):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _131) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _131
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _194 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _194 + 68] = mem[idx + _188 + 32]
                    idx = idx + 32
                    continue 
                mem[_194 + 94] = 0
                revert with memory
                  from mem[64]
                   len _194 + -mem[64] + 100
            if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 0, 17
            if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 0, 18
            if 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _204 = mem[64]
            mem[64] = mem[64] + 64
            mem[_204] = 26
            mem[_204 + 32] = 'SafeMath: division by zero'
            if _131:
                if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _131):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _131) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _131
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _211 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _211 + 68] = mem[idx + _204 + 32]
                idx = idx + 32
                continue 
            mem[_211 + 94] = 0
            revert with memory
              from mem[64]
               len _211 + -mem[64] + 100
    if arg1 >= poolInfo.length:
        revert with 0, 50
    if poolInfo[arg1].field_256 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if totalAllocPoint < poolInfo[arg1].field_256:
        revert with 0, 17
    if totalAllocPoint - poolInfo[arg1].field_256 > !arg2:
        revert with 0, 17
    if arg2 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = totalAllocPoint - poolInfo[arg1].field_256 + arg2
    if arg1 >= poolInfo.length:
        revert with 0, 50
    poolInfo[arg1].field_256 = arg2
}

function pendingBrush(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 >= poolInfo.length:
        revert with 0, 50
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.balanceOf(address rg1) with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if block.timestamp <= poolInfo[arg1].field_512:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return -userInfo[arg1][address(arg2)].field_256
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if not ext_call.return_data[0]:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return -userInfo[arg1][address(arg2)].field_256
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if poolInfo[arg1].field_512 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if block.timestamp < poolInfo[arg1].field_512:
        revert with 0, 17
    if not block.timestamp - poolInfo[arg1].field_512:
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero', 0
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero', 0
            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                revert with 0, 17
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < userInfo[arg1][address(arg2)].field_256:
                    revert with 0, 17
                return -userInfo[arg1][address(arg2)].field_256
            if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
                revert with 0, 17
            if not userInfo[arg1][address(arg2)].field_0:
                revert with 0, 18
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
            revert with 0, 17
        if not 0 / totalAllocPoint:
            revert with 0, 18
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 17
        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return -userInfo[arg1][address(arg2)].field_256
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if block.timestamp - poolInfo[arg1].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[arg1].field_512:
        revert with 0, 17
    if not block.timestamp - poolInfo[arg1].field_512:
        revert with 0, 18
    if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) / block.timestamp - poolInfo[arg1].field_512 != brushPerSecond:
        revert with 0, 'SafeMath: multiplication overflow'
    if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero', 0
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero', 0
            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                revert with 0, 17
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < userInfo[arg1][address(arg2)].field_256:
                    revert with 0, 17
                return -userInfo[arg1][address(arg2)].field_256
            if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
                revert with 0, 17
            if not userInfo[arg1][address(arg2)].field_0:
                revert with 0, 18
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
            revert with 0, 17
        if not 0 / totalAllocPoint:
            revert with 0, 18
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 17
        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return -userInfo[arg1][address(arg2)].field_256
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) and poolInfo[arg1].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
        revert with 0, 17
    if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
        revert with 0, 18
    if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) != poolInfo[arg1].field_256:
        revert with 0, 'SafeMath: multiplication overflow'
    if not totalAllocPoint:
        revert with 0, 'SafeMath: division by zero', 0
    if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
            revert with 0, 17
        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return -userInfo[arg1][address(arg2)].field_256
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
        revert with 0, 17
    if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
        revert with 0, 18
    if 10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
        revert with 0, 'SafeMath: multiplication overflow'
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero', 0
    if poolInfo[arg1].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
        revert with 0, 17
    if poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if 0 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return -userInfo[arg1][address(arg2)].field_256
    if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
        revert with 0, 17
    if not userInfo[arg1][address(arg2)].field_0:
        revert with 0, 18
    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
        revert with 0, 'SafeMath: multiplication overflow'
    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
        revert with 0, 17
    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
}

function buyBackAndBurn(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 > 0
    mem[0] = arg1
    mem[32] = 10
    require arg2 <= maxBurnAndBuyBackAmounts[address(arg1)]
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(arg1)
    staticcall arg1.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if 60 > !block.timestamp:
        revert with 0, 17
    mem[(2 * ceil32(return_data.size)) + 132] = address(ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 164] = arg2
    mem[(2 * ceil32(return_data.size)) + 196] = 0
    mem[(2 * ceil32(return_data.size)) + 228] = 0
    mem[(2 * ceil32(return_data.size)) + 260] = this.address
    mem[(2 * ceil32(return_data.size)) + 292] = block.timestamp + 60
    require ext_code.size(routerAddress)
    call routerAddress.removeLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, address rg6, uint256 rg7) with:
         gas gas_remaining wei
        args address(ext_call.return_data[0]), address(ext_call.return_data[0]), arg2, 0, 0, address(this.address), block.timestamp + 60
    mem[(2 * ceil32(return_data.size)) + 96 len 64] = ext_call.return_data[0 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    if 10000 > !block.timestamp:
        revert with 0, 17
    if brushAddress == address(ext_call.return_data[0]):
        mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
        mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
        if brushAddress == address(ext_call.return_data[0]):
            if ext_call.return_data[32] > -1:
                revert with 0, 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 388
            t = (4 * ceil32(return_data.size)) + 128
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
            require ext_code.size(routerAddress)
            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _2959 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _2990 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                revert with 0, 65
            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                revert with 0, 65
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            require return_data.size >= _2959 + (32 * _2990) + 32
            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2990] = mem[(4 * ceil32(return_data.size)) + _2959 + 224 len 32 * _2990]
            if 0 >= _2990:
                revert with 0, 50
            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                revert with 0, 17
            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
            if 1 >= _2990:
                revert with 0, 50
        else:
            if wftmAddress == address(ext_call.return_data[0]):
                if ext_call.return_data[32] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2957 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _2988 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                require return_data.size >= _2957 + (32 * _2988) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2988] = mem[(4 * ceil32(return_data.size)) + _2957 + 224 len 32 * _2988]
                if 0 >= _2988:
                    revert with 0, 50
                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                if 1 >= _2988:
                    revert with 0, 50
            else:
                if ext_call.return_data[0] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2958 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _2989 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                require return_data.size >= _2958 + (32 * _2989) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2989] = mem[(4 * ceil32(return_data.size)) + _2958 + 224 len 32 * _2989]
                if 0 >= _2989:
                    revert with 0, 50
                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                if 1 >= _2989:
                    revert with 0, 50
        require ext_code.size(brushAddress)
        call brushAddress.burn(uint256 rg1) with:
             gas gas_remaining wei
            args mem[(6 * ceil32(return_data.size)) + 256]
    else:
        if brushAddress == address(ext_call.return_data[0]):
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
            if brushAddress == address(ext_call.return_data[0]):
                if brushAddress != address(ext_call.return_data[0]):
                    if wftmAddress == address(ext_call.return_data[0]):
                        if ext_call.return_data[32] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2960 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2991 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        require return_data.size >= _2960 + (32 * _2991) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2991] = mem[(4 * ceil32(return_data.size)) + _2960 + 224 len 32 * _2991]
                        if 0 >= _2991:
                            revert with 0, 50
                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                        if 1 >= _2991:
                            revert with 0, 50
                    else:
                        if ext_call.return_data[0] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2961 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2992 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                        require return_data.size >= _2961 + (32 * _2992) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2992] = mem[(4 * ceil32(return_data.size)) + _2961 + 224 len 32 * _2992]
                        if 0 >= _2992:
                            revert with 0, 50
                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                        if 1 >= _2992:
                            revert with 0, 50
                else:
                    if brushAddress == address(ext_call.return_data[0]):
                        if ext_call.return_data[32] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2962 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2993 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        require return_data.size >= _2962 + (32 * _2993) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2993] = mem[(4 * ceil32(return_data.size)) + _2962 + 224 len 32 * _2993]
                        if 0 >= _2993:
                            revert with 0, 50
                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                        if 1 >= _2993:
                            revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[0] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2963 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2994 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            require return_data.size >= _2963 + (32 * _2994) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2994] = mem[(4 * ceil32(return_data.size)) + _2963 + 224 len 32 * _2994]
                            if 0 >= _2994:
                                revert with 0, 50
                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                            if 1 >= _2994:
                                revert with 0, 50
                        else:
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2964 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2995 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2964 + (32 * _2995) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2995] = mem[(4 * ceil32(return_data.size)) + _2964 + 224 len 32 * _2995]
                                if 0 >= _2995:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _2995:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2965 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2996 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2965 + (32 * _2996) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2996] = mem[(4 * ceil32(return_data.size)) + _2965 + 224 len 32 * _2996]
                                if 0 >= _2996:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _2996:
                                    revert with 0, 50
            else:
                if brushAddress == address(ext_call.return_data[0]):
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[32] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2966 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2997 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            require return_data.size >= _2966 + (32 * _2997) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2997] = mem[(4 * ceil32(return_data.size)) + _2966 + 224 len 32 * _2997]
                            if 0 >= _2997:
                                revert with 0, 50
                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                            if 1 >= _2997:
                                revert with 0, 50
                        else:
                            if ext_call.return_data[0] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2967 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2998 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            require return_data.size >= _2967 + (32 * _2998) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2998] = mem[(4 * ceil32(return_data.size)) + _2967 + 224 len 32 * _2998]
                            if 0 >= _2998:
                                revert with 0, 50
                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                            if 1 >= _2998:
                                revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[32] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2968 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2999 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            require return_data.size >= _2968 + (32 * _2999) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2999] = mem[(4 * ceil32(return_data.size)) + _2968 + 224 len 32 * _2999]
                            if 0 >= _2999:
                                revert with 0, 50
                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                            if 1 >= _2999:
                                revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2969 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3000 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2969 + (32 * _3000) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3000] = mem[(4 * ceil32(return_data.size)) + _2969 + 224 len 32 * _3000]
                                if 0 >= _3000:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3000:
                                    revert with 0, 50
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2970 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3001 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _2970 + (32 * _3001) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3001] = mem[(4 * ceil32(return_data.size)) + _2970 + 224 len 32 * _3001]
                                    if 0 >= _3001:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                    if 1 >= _3001:
                                        revert with 0, 50
                                else:
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2971 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3002 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2971 + (32 * _3002) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3002] = mem[(4 * ceil32(return_data.size)) + _2971 + 224 len 32 * _3002]
                                    if 0 >= _3002:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                    if 1 >= _3002:
                                        revert with 0, 50
                else:
                    if wftmAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2972 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3003 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2972 + (32 * _3003) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3003] = mem[(4 * ceil32(return_data.size)) + _2972 + 224 len 32 * _3003]
                                if 0 >= _3003:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3003:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2973 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3004 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2973 + (32 * _3004) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3004] = mem[(4 * ceil32(return_data.size)) + _2973 + 224 len 32 * _3004]
                                if 0 >= _3004:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3004:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2974 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3005 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2974 + (32 * _3005) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3005] = mem[(4 * ceil32(return_data.size)) + _2974 + 224 len 32 * _3005]
                                if 0 >= _3005:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3005:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2975 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3006 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2975 + (32 * _3006) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3006] = mem[(4 * ceil32(return_data.size)) + _2975 + 224 len 32 * _3006]
                                    if 0 >= _3006:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                    if 1 >= _3006:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2976 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3007 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _2976 + (32 * _3007) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3007] = mem[(4 * ceil32(return_data.size)) + _2976 + 224 len 32 * _3007]
                                        if 0 >= _3007:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                        if 1 >= _3007:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2977 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3008 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _2977 + (32 * _3008) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3008] = mem[(4 * ceil32(return_data.size)) + _2977 + 224 len 32 * _3008]
                                        if 0 >= _3008:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                        if 1 >= _3008:
                                            revert with 0, 50
                    else:
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2978 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3009 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2978 + (32 * _3009) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3009] = mem[(4 * ceil32(return_data.size)) + _2978 + 224 len 32 * _3009]
                                if 0 >= _3009:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3009:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2979 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3010 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2979 + (32 * _3010) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3010] = mem[(4 * ceil32(return_data.size)) + _2979 + 224 len 32 * _3010]
                                if 0 >= _3010:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3010:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2980 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3011 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2980 + (32 * _3011) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3011] = mem[(4 * ceil32(return_data.size)) + _2980 + 224 len 32 * _3011]
                                if 0 >= _3011:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3011:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2981 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3012 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2981 + (32 * _3012) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3012] = mem[(4 * ceil32(return_data.size)) + _2981 + 224 len 32 * _3012]
                                    if 0 >= _3012:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                    if 1 >= _3012:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2982 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3013 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _2982 + (32 * _3013) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3013] = mem[(4 * ceil32(return_data.size)) + _2982 + 224 len 32 * _3013]
                                        if 0 >= _3013:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                        if 1 >= _3013:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2983 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3014 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _2983 + (32 * _3014) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3014] = mem[(4 * ceil32(return_data.size)) + _2983 + 224 len 32 * _3014]
                                        if 0 >= _3014:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                        if 1 >= _3014:
                                            revert with 0, 50
            require ext_code.size(brushAddress)
            call brushAddress.burn(uint256 rg1) with:
                 gas gas_remaining wei
                args mem[(6 * ceil32(return_data.size)) + 256]
        else:
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = wftmAddress
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            if wftmAddress == address(ext_call.return_data[0]):
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2984 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3015 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3015
                    require return_data.size >= _2984 + (32 * _3015) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3015] = mem[(4 * ceil32(return_data.size)) + _2984 + 224 len 32 * _3015]
                    if 1 >= _3015:
                        revert with 0, 50
                    _5750 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5754 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5754]:
                        revert with 0, 50
                    mem[_5754 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5754]:
                        revert with 0, 50
                    mem[_5754 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5750:
                                        revert with 0, 17
                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                    mem[_5754 + 132] = 0
                                    mem[_5754 + 164] = 160
                                    mem[_5754 + 260] = mem[_5754]
                                    idx = 0
                                    s = _5754 + 292
                                    t = _5754 + 32
                                    while idx < mem[_5754]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5754 + 196] = this.address
                                    mem[_5754 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8506 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8650 = mem[_8506]
                                    require mem[_8506] <= test266151307()
                                    require _8506 + mem[_8506] + 31 < _8506 + return_data.size
                                    _8794 = mem[_8506 + mem[_8506]]
                                    if mem[_8506 + mem[_8506]] > test266151307():
                                        revert with 0, 65
                                    if _8506 + ceil32(return_data.size) + ceil32(32 * mem[_8506 + mem[_8506]]) + 1 > test266151307() or ceil32(32 * mem[_8506 + mem[_8506]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8506 + ceil32(return_data.size) + ceil32(32 * mem[_8506 + mem[_8506]]) + 1
                                    mem[_8506 + ceil32(return_data.size)] = _8794
                                    require return_data.size >= _8650 + (32 * _8794) + 32
                                    mem[_8506 + ceil32(return_data.size) + 32 len 32 * _8794] = mem[_8506 + _8650 + 32 len 32 * _8794]
                                    if 0 >= _8794:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8506 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8506 + ceil32(return_data.size) + 32]
                                    if 1 >= _8794:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8506 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5750:
                                        revert with 0, 17
                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                    mem[_5754 + 132] = 0
                                    mem[_5754 + 164] = 160
                                    mem[_5754 + 260] = mem[_5754]
                                    idx = 0
                                    s = _5754 + 292
                                    t = _5754 + 32
                                    while idx < mem[_5754]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5754 + 196] = this.address
                                    mem[_5754 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8507 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8651 = mem[_8507]
                                    require mem[_8507] <= test266151307()
                                    require _8507 + mem[_8507] + 31 < _8507 + return_data.size
                                    _8795 = mem[_8507 + mem[_8507]]
                                    if mem[_8507 + mem[_8507]] > test266151307():
                                        revert with 0, 65
                                    if _8507 + ceil32(return_data.size) + ceil32(32 * mem[_8507 + mem[_8507]]) + 1 > test266151307() or ceil32(32 * mem[_8507 + mem[_8507]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8507 + ceil32(return_data.size) + ceil32(32 * mem[_8507 + mem[_8507]]) + 1
                                    mem[_8507 + ceil32(return_data.size)] = _8795
                                    require return_data.size >= _8651 + (32 * _8795) + 32
                                    mem[_8507 + ceil32(return_data.size) + 32 len 32 * _8795] = mem[_8507 + _8651 + 32 len 32 * _8795]
                                    if 0 >= _8795:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8507 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8507 + ceil32(return_data.size) + 32]
                                    if 1 >= _8795:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8507 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5750:
                                        revert with 0, 17
                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                    mem[_5754 + 132] = 0
                                    mem[_5754 + 164] = 160
                                    mem[_5754 + 260] = mem[_5754]
                                    idx = 0
                                    s = _5754 + 292
                                    t = _5754 + 32
                                    while idx < mem[_5754]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5754 + 196] = this.address
                                    mem[_5754 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8508 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8652 = mem[_8508]
                                    require mem[_8508] <= test266151307()
                                    require _8508 + mem[_8508] + 31 < _8508 + return_data.size
                                    _8796 = mem[_8508 + mem[_8508]]
                                    if mem[_8508 + mem[_8508]] > test266151307():
                                        revert with 0, 65
                                    if _8508 + ceil32(return_data.size) + ceil32(32 * mem[_8508 + mem[_8508]]) + 1 > test266151307() or ceil32(32 * mem[_8508 + mem[_8508]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8508 + ceil32(return_data.size) + ceil32(32 * mem[_8508 + mem[_8508]]) + 1
                                    mem[_8508 + ceil32(return_data.size)] = _8796
                                    require return_data.size >= _8652 + (32 * _8796) + 32
                                    mem[_8508 + ceil32(return_data.size) + 32 len 32 * _8796] = mem[_8508 + _8652 + 32 len 32 * _8796]
                                    if 0 >= _8796:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8508 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8508 + ceil32(return_data.size) + 32]
                                    if 1 >= _8796:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8508 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5750:
                                            revert with 0, 17
                                        mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                        mem[_5754 + 132] = 0
                                        mem[_5754 + 164] = 160
                                        mem[_5754 + 260] = mem[_5754]
                                        idx = 0
                                        s = _5754 + 292
                                        t = _5754 + 32
                                        while idx < mem[_5754]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5754 + 196] = this.address
                                        mem[_5754 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8509 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8653 = mem[_8509]
                                        require mem[_8509] <= test266151307()
                                        require _8509 + mem[_8509] + 31 < _8509 + return_data.size
                                        _8797 = mem[_8509 + mem[_8509]]
                                        if mem[_8509 + mem[_8509]] > test266151307():
                                            revert with 0, 65
                                        if _8509 + ceil32(return_data.size) + ceil32(32 * mem[_8509 + mem[_8509]]) + 1 > test266151307() or ceil32(32 * mem[_8509 + mem[_8509]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8509 + ceil32(return_data.size) + ceil32(32 * mem[_8509 + mem[_8509]]) + 1
                                        mem[_8509 + ceil32(return_data.size)] = _8797
                                        require return_data.size >= _8653 + (32 * _8797) + 32
                                        mem[_8509 + ceil32(return_data.size) + 32 len 32 * _8797] = mem[_8509 + _8653 + 32 len 32 * _8797]
                                        if 0 >= _8797:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8509 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8509 + ceil32(return_data.size) + 32]
                                        if 1 >= _8797:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8509 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8510 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8654 = mem[_8510]
                                            require mem[_8510] <= test266151307()
                                            require _8510 + mem[_8510] + 31 < _8510 + return_data.size
                                            _8798 = mem[_8510 + mem[_8510]]
                                            if mem[_8510 + mem[_8510]] > test266151307():
                                                revert with 0, 65
                                            if _8510 + ceil32(return_data.size) + ceil32(32 * mem[_8510 + mem[_8510]]) + 1 > test266151307() or ceil32(32 * mem[_8510 + mem[_8510]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8510 + ceil32(return_data.size) + ceil32(32 * mem[_8510 + mem[_8510]]) + 1
                                            mem[_8510 + ceil32(return_data.size)] = _8798
                                            require return_data.size >= _8654 + (32 * _8798) + 32
                                            mem[_8510 + ceil32(return_data.size) + 32 len 32 * _8798] = mem[_8510 + _8654 + 32 len 32 * _8798]
                                            if 0 >= _8798:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8510 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8510 + ceil32(return_data.size) + 32]
                                            if 1 >= _8798:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8510 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8511 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8655 = mem[_8511]
                                            require mem[_8511] <= test266151307()
                                            require _8511 + mem[_8511] + 31 < _8511 + return_data.size
                                            _8799 = mem[_8511 + mem[_8511]]
                                            if mem[_8511 + mem[_8511]] > test266151307():
                                                revert with 0, 65
                                            if _8511 + ceil32(return_data.size) + ceil32(32 * mem[_8511 + mem[_8511]]) + 1 > test266151307() or ceil32(32 * mem[_8511 + mem[_8511]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8511 + ceil32(return_data.size) + ceil32(32 * mem[_8511 + mem[_8511]]) + 1
                                            mem[_8511 + ceil32(return_data.size)] = _8799
                                            require return_data.size >= _8655 + (32 * _8799) + 32
                                            mem[_8511 + ceil32(return_data.size) + 32 len 32 * _8799] = mem[_8511 + _8655 + 32 len 32 * _8799]
                                            if 0 >= _8799:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8511 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8511 + ceil32(return_data.size) + 32]
                                            if 1 >= _8799:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8511 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5750:
                                        revert with 0, 17
                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                    mem[_5754 + 132] = 0
                                    mem[_5754 + 164] = 160
                                    mem[_5754 + 260] = mem[_5754]
                                    idx = 0
                                    s = _5754 + 292
                                    t = _5754 + 32
                                    while idx < mem[_5754]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5754 + 196] = this.address
                                    mem[_5754 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8512 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8656 = mem[_8512]
                                    require mem[_8512] <= test266151307()
                                    require _8512 + mem[_8512] + 31 < _8512 + return_data.size
                                    _8800 = mem[_8512 + mem[_8512]]
                                    if mem[_8512 + mem[_8512]] > test266151307():
                                        revert with 0, 65
                                    if _8512 + ceil32(return_data.size) + ceil32(32 * mem[_8512 + mem[_8512]]) + 1 > test266151307() or ceil32(32 * mem[_8512 + mem[_8512]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8512 + ceil32(return_data.size) + ceil32(32 * mem[_8512 + mem[_8512]]) + 1
                                    mem[_8512 + ceil32(return_data.size)] = _8800
                                    require return_data.size >= _8656 + (32 * _8800) + 32
                                    mem[_8512 + ceil32(return_data.size) + 32 len 32 * _8800] = mem[_8512 + _8656 + 32 len 32 * _8800]
                                    if 0 >= _8800:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8512 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8512 + ceil32(return_data.size) + 32]
                                    if 1 >= _8800:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8512 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5750:
                                        revert with 0, 17
                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                    mem[_5754 + 132] = 0
                                    mem[_5754 + 164] = 160
                                    mem[_5754 + 260] = mem[_5754]
                                    idx = 0
                                    s = _5754 + 292
                                    t = _5754 + 32
                                    while idx < mem[_5754]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5754 + 196] = this.address
                                    mem[_5754 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8513 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8657 = mem[_8513]
                                    require mem[_8513] <= test266151307()
                                    require _8513 + mem[_8513] + 31 < _8513 + return_data.size
                                    _8801 = mem[_8513 + mem[_8513]]
                                    if mem[_8513 + mem[_8513]] > test266151307():
                                        revert with 0, 65
                                    if _8513 + ceil32(return_data.size) + ceil32(32 * mem[_8513 + mem[_8513]]) + 1 > test266151307() or ceil32(32 * mem[_8513 + mem[_8513]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8513 + ceil32(return_data.size) + ceil32(32 * mem[_8513 + mem[_8513]]) + 1
                                    mem[_8513 + ceil32(return_data.size)] = _8801
                                    require return_data.size >= _8657 + (32 * _8801) + 32
                                    mem[_8513 + ceil32(return_data.size) + 32 len 32 * _8801] = mem[_8513 + _8657 + 32 len 32 * _8801]
                                    if 0 >= _8801:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8513 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8513 + ceil32(return_data.size) + 32]
                                    if 1 >= _8801:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8513 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5750:
                                        revert with 0, 17
                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                    mem[_5754 + 132] = 0
                                    mem[_5754 + 164] = 160
                                    mem[_5754 + 260] = mem[_5754]
                                    idx = 0
                                    s = _5754 + 292
                                    t = _5754 + 32
                                    while idx < mem[_5754]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5754 + 196] = this.address
                                    mem[_5754 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8514 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8658 = mem[_8514]
                                    require mem[_8514] <= test266151307()
                                    require _8514 + mem[_8514] + 31 < _8514 + return_data.size
                                    _8802 = mem[_8514 + mem[_8514]]
                                    if mem[_8514 + mem[_8514]] > test266151307():
                                        revert with 0, 65
                                    if _8514 + ceil32(return_data.size) + ceil32(32 * mem[_8514 + mem[_8514]]) + 1 > test266151307() or ceil32(32 * mem[_8514 + mem[_8514]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8514 + ceil32(return_data.size) + ceil32(32 * mem[_8514 + mem[_8514]]) + 1
                                    mem[_8514 + ceil32(return_data.size)] = _8802
                                    require return_data.size >= _8658 + (32 * _8802) + 32
                                    mem[_8514 + ceil32(return_data.size) + 32 len 32 * _8802] = mem[_8514 + _8658 + 32 len 32 * _8802]
                                    if 0 >= _8802:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8514 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8514 + ceil32(return_data.size) + 32]
                                    if 1 >= _8802:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8514 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5750:
                                            revert with 0, 17
                                        mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                        mem[_5754 + 132] = 0
                                        mem[_5754 + 164] = 160
                                        mem[_5754 + 260] = mem[_5754]
                                        idx = 0
                                        s = _5754 + 292
                                        t = _5754 + 32
                                        while idx < mem[_5754]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5754 + 196] = this.address
                                        mem[_5754 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8515 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8659 = mem[_8515]
                                        require mem[_8515] <= test266151307()
                                        require _8515 + mem[_8515] + 31 < _8515 + return_data.size
                                        _8803 = mem[_8515 + mem[_8515]]
                                        if mem[_8515 + mem[_8515]] > test266151307():
                                            revert with 0, 65
                                        if _8515 + ceil32(return_data.size) + ceil32(32 * mem[_8515 + mem[_8515]]) + 1 > test266151307() or ceil32(32 * mem[_8515 + mem[_8515]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8515 + ceil32(return_data.size) + ceil32(32 * mem[_8515 + mem[_8515]]) + 1
                                        mem[_8515 + ceil32(return_data.size)] = _8803
                                        require return_data.size >= _8659 + (32 * _8803) + 32
                                        mem[_8515 + ceil32(return_data.size) + 32 len 32 * _8803] = mem[_8515 + _8659 + 32 len 32 * _8803]
                                        if 0 >= _8803:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8515 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8515 + ceil32(return_data.size) + 32]
                                        if 1 >= _8803:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8515 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8516 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8660 = mem[_8516]
                                            require mem[_8516] <= test266151307()
                                            require _8516 + mem[_8516] + 31 < _8516 + return_data.size
                                            _8804 = mem[_8516 + mem[_8516]]
                                            if mem[_8516 + mem[_8516]] > test266151307():
                                                revert with 0, 65
                                            if _8516 + ceil32(return_data.size) + ceil32(32 * mem[_8516 + mem[_8516]]) + 1 > test266151307() or ceil32(32 * mem[_8516 + mem[_8516]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8516 + ceil32(return_data.size) + ceil32(32 * mem[_8516 + mem[_8516]]) + 1
                                            mem[_8516 + ceil32(return_data.size)] = _8804
                                            require return_data.size >= _8660 + (32 * _8804) + 32
                                            mem[_8516 + ceil32(return_data.size) + 32 len 32 * _8804] = mem[_8516 + _8660 + 32 len 32 * _8804]
                                            if 0 >= _8804:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8516 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8516 + ceil32(return_data.size) + 32]
                                            if 1 >= _8804:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8516 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8517 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8661 = mem[_8517]
                                            require mem[_8517] <= test266151307()
                                            require _8517 + mem[_8517] + 31 < _8517 + return_data.size
                                            _8805 = mem[_8517 + mem[_8517]]
                                            if mem[_8517 + mem[_8517]] > test266151307():
                                                revert with 0, 65
                                            if _8517 + ceil32(return_data.size) + ceil32(32 * mem[_8517 + mem[_8517]]) + 1 > test266151307() or ceil32(32 * mem[_8517 + mem[_8517]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8517 + ceil32(return_data.size) + ceil32(32 * mem[_8517 + mem[_8517]]) + 1
                                            mem[_8517 + ceil32(return_data.size)] = _8805
                                            require return_data.size >= _8661 + (32 * _8805) + 32
                                            mem[_8517 + ceil32(return_data.size) + 32 len 32 * _8805] = mem[_8517 + _8661 + 32 len 32 * _8805]
                                            if 0 >= _8805:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8517 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8517 + ceil32(return_data.size) + 32]
                                            if 1 >= _8805:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8517 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5750:
                                        revert with 0, 17
                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                    mem[_5754 + 132] = 0
                                    mem[_5754 + 164] = 160
                                    mem[_5754 + 260] = mem[_5754]
                                    idx = 0
                                    s = _5754 + 292
                                    t = _5754 + 32
                                    while idx < mem[_5754]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5754 + 196] = this.address
                                    mem[_5754 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8518 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8662 = mem[_8518]
                                    require mem[_8518] <= test266151307()
                                    require _8518 + mem[_8518] + 31 < _8518 + return_data.size
                                    _8806 = mem[_8518 + mem[_8518]]
                                    if mem[_8518 + mem[_8518]] > test266151307():
                                        revert with 0, 65
                                    if _8518 + ceil32(return_data.size) + ceil32(32 * mem[_8518 + mem[_8518]]) + 1 > test266151307() or ceil32(32 * mem[_8518 + mem[_8518]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8518 + ceil32(return_data.size) + ceil32(32 * mem[_8518 + mem[_8518]]) + 1
                                    mem[_8518 + ceil32(return_data.size)] = _8806
                                    require return_data.size >= _8662 + (32 * _8806) + 32
                                    mem[_8518 + ceil32(return_data.size) + 32 len 32 * _8806] = mem[_8518 + _8662 + 32 len 32 * _8806]
                                    if 0 >= _8806:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8518 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8518 + ceil32(return_data.size) + 32]
                                    if 1 >= _8806:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8518 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5750:
                                        revert with 0, 17
                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                    mem[_5754 + 132] = 0
                                    mem[_5754 + 164] = 160
                                    mem[_5754 + 260] = mem[_5754]
                                    idx = 0
                                    s = _5754 + 292
                                    t = _5754 + 32
                                    while idx < mem[_5754]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5754 + 196] = this.address
                                    mem[_5754 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8519 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8663 = mem[_8519]
                                    require mem[_8519] <= test266151307()
                                    require _8519 + mem[_8519] + 31 < _8519 + return_data.size
                                    _8807 = mem[_8519 + mem[_8519]]
                                    if mem[_8519 + mem[_8519]] > test266151307():
                                        revert with 0, 65
                                    if _8519 + ceil32(return_data.size) + ceil32(32 * mem[_8519 + mem[_8519]]) + 1 > test266151307() or ceil32(32 * mem[_8519 + mem[_8519]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8519 + ceil32(return_data.size) + ceil32(32 * mem[_8519 + mem[_8519]]) + 1
                                    mem[_8519 + ceil32(return_data.size)] = _8807
                                    require return_data.size >= _8663 + (32 * _8807) + 32
                                    mem[_8519 + ceil32(return_data.size) + 32 len 32 * _8807] = mem[_8519 + _8663 + 32 len 32 * _8807]
                                    if 0 >= _8807:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8519 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8519 + ceil32(return_data.size) + 32]
                                    if 1 >= _8807:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8519 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5750:
                                        revert with 0, 17
                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                    mem[_5754 + 132] = 0
                                    mem[_5754 + 164] = 160
                                    mem[_5754 + 260] = mem[_5754]
                                    idx = 0
                                    s = _5754 + 292
                                    t = _5754 + 32
                                    while idx < mem[_5754]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5754 + 196] = this.address
                                    mem[_5754 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8520 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8664 = mem[_8520]
                                    require mem[_8520] <= test266151307()
                                    require _8520 + mem[_8520] + 31 < _8520 + return_data.size
                                    _8808 = mem[_8520 + mem[_8520]]
                                    if mem[_8520 + mem[_8520]] > test266151307():
                                        revert with 0, 65
                                    if _8520 + ceil32(return_data.size) + ceil32(32 * mem[_8520 + mem[_8520]]) + 1 > test266151307() or ceil32(32 * mem[_8520 + mem[_8520]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8520 + ceil32(return_data.size) + ceil32(32 * mem[_8520 + mem[_8520]]) + 1
                                    mem[_8520 + ceil32(return_data.size)] = _8808
                                    require return_data.size >= _8664 + (32 * _8808) + 32
                                    mem[_8520 + ceil32(return_data.size) + 32 len 32 * _8808] = mem[_8520 + _8664 + 32 len 32 * _8808]
                                    if 0 >= _8808:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8520 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8520 + ceil32(return_data.size) + 32]
                                    if 1 >= _8808:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8520 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5750:
                                            revert with 0, 17
                                        mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                        mem[_5754 + 132] = 0
                                        mem[_5754 + 164] = 160
                                        mem[_5754 + 260] = mem[_5754]
                                        idx = 0
                                        s = _5754 + 292
                                        t = _5754 + 32
                                        while idx < mem[_5754]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5754 + 196] = this.address
                                        mem[_5754 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8521 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8665 = mem[_8521]
                                        require mem[_8521] <= test266151307()
                                        require _8521 + mem[_8521] + 31 < _8521 + return_data.size
                                        _8809 = mem[_8521 + mem[_8521]]
                                        if mem[_8521 + mem[_8521]] > test266151307():
                                            revert with 0, 65
                                        if _8521 + ceil32(return_data.size) + ceil32(32 * mem[_8521 + mem[_8521]]) + 1 > test266151307() or ceil32(32 * mem[_8521 + mem[_8521]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8521 + ceil32(return_data.size) + ceil32(32 * mem[_8521 + mem[_8521]]) + 1
                                        mem[_8521 + ceil32(return_data.size)] = _8809
                                        require return_data.size >= _8665 + (32 * _8809) + 32
                                        mem[_8521 + ceil32(return_data.size) + 32 len 32 * _8809] = mem[_8521 + _8665 + 32 len 32 * _8809]
                                        if 0 >= _8809:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8521 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8521 + ceil32(return_data.size) + 32]
                                        if 1 >= _8809:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8521 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8522 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8666 = mem[_8522]
                                            require mem[_8522] <= test266151307()
                                            require _8522 + mem[_8522] + 31 < _8522 + return_data.size
                                            _8810 = mem[_8522 + mem[_8522]]
                                            if mem[_8522 + mem[_8522]] > test266151307():
                                                revert with 0, 65
                                            if _8522 + ceil32(return_data.size) + ceil32(32 * mem[_8522 + mem[_8522]]) + 1 > test266151307() or ceil32(32 * mem[_8522 + mem[_8522]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8522 + ceil32(return_data.size) + ceil32(32 * mem[_8522 + mem[_8522]]) + 1
                                            mem[_8522 + ceil32(return_data.size)] = _8810
                                            require return_data.size >= _8666 + (32 * _8810) + 32
                                            mem[_8522 + ceil32(return_data.size) + 32 len 32 * _8810] = mem[_8522 + _8666 + 32 len 32 * _8810]
                                            if 0 >= _8810:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8522 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8522 + ceil32(return_data.size) + 32]
                                            if 1 >= _8810:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8522 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8523 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8667 = mem[_8523]
                                            require mem[_8523] <= test266151307()
                                            require _8523 + mem[_8523] + 31 < _8523 + return_data.size
                                            _8811 = mem[_8523 + mem[_8523]]
                                            if mem[_8523 + mem[_8523]] > test266151307():
                                                revert with 0, 65
                                            if _8523 + ceil32(return_data.size) + ceil32(32 * mem[_8523 + mem[_8523]]) + 1 > test266151307() or ceil32(32 * mem[_8523 + mem[_8523]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8523 + ceil32(return_data.size) + ceil32(32 * mem[_8523 + mem[_8523]]) + 1
                                            mem[_8523 + ceil32(return_data.size)] = _8811
                                            require return_data.size >= _8667 + (32 * _8811) + 32
                                            mem[_8523 + ceil32(return_data.size) + 32 len 32 * _8811] = mem[_8523 + _8667 + 32 len 32 * _8811]
                                            if 0 >= _8811:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8523 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8523 + ceil32(return_data.size) + 32]
                                            if 1 >= _8811:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8523 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5750:
                                            revert with 0, 17
                                        mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                        mem[_5754 + 132] = 0
                                        mem[_5754 + 164] = 160
                                        mem[_5754 + 260] = mem[_5754]
                                        idx = 0
                                        s = _5754 + 292
                                        t = _5754 + 32
                                        while idx < mem[_5754]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5754 + 196] = this.address
                                        mem[_5754 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8524 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8668 = mem[_8524]
                                        require mem[_8524] <= test266151307()
                                        require _8524 + mem[_8524] + 31 < _8524 + return_data.size
                                        _8812 = mem[_8524 + mem[_8524]]
                                        if mem[_8524 + mem[_8524]] > test266151307():
                                            revert with 0, 65
                                        if _8524 + ceil32(return_data.size) + ceil32(32 * mem[_8524 + mem[_8524]]) + 1 > test266151307() or ceil32(32 * mem[_8524 + mem[_8524]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8524 + ceil32(return_data.size) + ceil32(32 * mem[_8524 + mem[_8524]]) + 1
                                        mem[_8524 + ceil32(return_data.size)] = _8812
                                        require return_data.size >= _8668 + (32 * _8812) + 32
                                        mem[_8524 + ceil32(return_data.size) + 32 len 32 * _8812] = mem[_8524 + _8668 + 32 len 32 * _8812]
                                        if 0 >= _8812:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8524 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8524 + ceil32(return_data.size) + 32]
                                        if 1 >= _8812:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8524 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5750:
                                            revert with 0, 17
                                        mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                        mem[_5754 + 132] = 0
                                        mem[_5754 + 164] = 160
                                        mem[_5754 + 260] = mem[_5754]
                                        idx = 0
                                        s = _5754 + 292
                                        t = _5754 + 32
                                        while idx < mem[_5754]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5754 + 196] = this.address
                                        mem[_5754 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8525 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8669 = mem[_8525]
                                        require mem[_8525] <= test266151307()
                                        require _8525 + mem[_8525] + 31 < _8525 + return_data.size
                                        _8813 = mem[_8525 + mem[_8525]]
                                        if mem[_8525 + mem[_8525]] > test266151307():
                                            revert with 0, 65
                                        if _8525 + ceil32(return_data.size) + ceil32(32 * mem[_8525 + mem[_8525]]) + 1 > test266151307() or ceil32(32 * mem[_8525 + mem[_8525]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8525 + ceil32(return_data.size) + ceil32(32 * mem[_8525 + mem[_8525]]) + 1
                                        mem[_8525 + ceil32(return_data.size)] = _8813
                                        require return_data.size >= _8669 + (32 * _8813) + 32
                                        mem[_8525 + ceil32(return_data.size) + 32 len 32 * _8813] = mem[_8525 + _8669 + 32 len 32 * _8813]
                                        if 0 >= _8813:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8525 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8525 + ceil32(return_data.size) + 32]
                                        if 1 >= _8813:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8525 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5750:
                                            revert with 0, 17
                                        mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                        mem[_5754 + 132] = 0
                                        mem[_5754 + 164] = 160
                                        mem[_5754 + 260] = mem[_5754]
                                        idx = 0
                                        s = _5754 + 292
                                        t = _5754 + 32
                                        while idx < mem[_5754]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5754 + 196] = this.address
                                        mem[_5754 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8526 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8670 = mem[_8526]
                                        require mem[_8526] <= test266151307()
                                        require _8526 + mem[_8526] + 31 < _8526 + return_data.size
                                        _8814 = mem[_8526 + mem[_8526]]
                                        if mem[_8526 + mem[_8526]] > test266151307():
                                            revert with 0, 65
                                        if _8526 + ceil32(return_data.size) + ceil32(32 * mem[_8526 + mem[_8526]]) + 1 > test266151307() or ceil32(32 * mem[_8526 + mem[_8526]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8526 + ceil32(return_data.size) + ceil32(32 * mem[_8526 + mem[_8526]]) + 1
                                        mem[_8526 + ceil32(return_data.size)] = _8814
                                        require return_data.size >= _8670 + (32 * _8814) + 32
                                        mem[_8526 + ceil32(return_data.size) + 32 len 32 * _8814] = mem[_8526 + _8670 + 32 len 32 * _8814]
                                        if 0 >= _8814:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8526 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8526 + ceil32(return_data.size) + 32]
                                        if 1 >= _8814:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8526 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8527 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8671 = mem[_8527]
                                            require mem[_8527] <= test266151307()
                                            require _8527 + mem[_8527] + 31 < _8527 + return_data.size
                                            _8815 = mem[_8527 + mem[_8527]]
                                            if mem[_8527 + mem[_8527]] > test266151307():
                                                revert with 0, 65
                                            if _8527 + ceil32(return_data.size) + ceil32(32 * mem[_8527 + mem[_8527]]) + 1 > test266151307() or ceil32(32 * mem[_8527 + mem[_8527]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8527 + ceil32(return_data.size) + ceil32(32 * mem[_8527 + mem[_8527]]) + 1
                                            mem[_8527 + ceil32(return_data.size)] = _8815
                                            require return_data.size >= _8671 + (32 * _8815) + 32
                                            mem[_8527 + ceil32(return_data.size) + 32 len 32 * _8815] = mem[_8527 + _8671 + 32 len 32 * _8815]
                                            if 0 >= _8815:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8527 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8527 + ceil32(return_data.size) + 32]
                                            if 1 >= _8815:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8527 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5750:
                                                    revert with 0, 17
                                                mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                                mem[_5754 + 132] = 0
                                                mem[_5754 + 164] = 160
                                                mem[_5754 + 260] = mem[_5754]
                                                idx = 0
                                                s = _5754 + 292
                                                t = _5754 + 32
                                                while idx < mem[_5754]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5754 + 196] = this.address
                                                mem[_5754 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8528 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8672 = mem[_8528]
                                                require mem[_8528] <= test266151307()
                                                require _8528 + mem[_8528] + 31 < _8528 + return_data.size
                                                _8816 = mem[_8528 + mem[_8528]]
                                                if mem[_8528 + mem[_8528]] > test266151307():
                                                    revert with 0, 65
                                                if _8528 + ceil32(return_data.size) + ceil32(32 * mem[_8528 + mem[_8528]]) + 1 > test266151307() or ceil32(32 * mem[_8528 + mem[_8528]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8528 + ceil32(return_data.size) + ceil32(32 * mem[_8528 + mem[_8528]]) + 1
                                                mem[_8528 + ceil32(return_data.size)] = _8816
                                                require return_data.size >= _8672 + (32 * _8816) + 32
                                                mem[_8528 + ceil32(return_data.size) + 32 len 32 * _8816] = mem[_8528 + _8672 + 32 len 32 * _8816]
                                                if 0 >= _8816:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8528 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8528 + ceil32(return_data.size) + 32]
                                                if 1 >= _8816:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8528 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5750:
                                                    revert with 0, 17
                                                mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                                mem[_5754 + 132] = 0
                                                mem[_5754 + 164] = 160
                                                mem[_5754 + 260] = mem[_5754]
                                                idx = 0
                                                s = _5754 + 292
                                                t = _5754 + 32
                                                while idx < mem[_5754]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5754 + 196] = this.address
                                                mem[_5754 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8529 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8673 = mem[_8529]
                                                require mem[_8529] <= test266151307()
                                                require _8529 + mem[_8529] + 31 < _8529 + return_data.size
                                                _8817 = mem[_8529 + mem[_8529]]
                                                if mem[_8529 + mem[_8529]] > test266151307():
                                                    revert with 0, 65
                                                if _8529 + ceil32(return_data.size) + ceil32(32 * mem[_8529 + mem[_8529]]) + 1 > test266151307() or ceil32(32 * mem[_8529 + mem[_8529]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8529 + ceil32(return_data.size) + ceil32(32 * mem[_8529 + mem[_8529]]) + 1
                                                mem[_8529 + ceil32(return_data.size)] = _8817
                                                require return_data.size >= _8673 + (32 * _8817) + 32
                                                mem[_8529 + ceil32(return_data.size) + 32 len 32 * _8817] = mem[_8529 + _8673 + 32 len 32 * _8817]
                                                if 0 >= _8817:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8529 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8529 + ceil32(return_data.size) + 32]
                                                if 1 >= _8817:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8529 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8530 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8674 = mem[_8530]
                                            require mem[_8530] <= test266151307()
                                            require _8530 + mem[_8530] + 31 < _8530 + return_data.size
                                            _8818 = mem[_8530 + mem[_8530]]
                                            if mem[_8530 + mem[_8530]] > test266151307():
                                                revert with 0, 65
                                            if _8530 + ceil32(return_data.size) + ceil32(32 * mem[_8530 + mem[_8530]]) + 1 > test266151307() or ceil32(32 * mem[_8530 + mem[_8530]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8530 + ceil32(return_data.size) + ceil32(32 * mem[_8530 + mem[_8530]]) + 1
                                            mem[_8530 + ceil32(return_data.size)] = _8818
                                            require return_data.size >= _8674 + (32 * _8818) + 32
                                            mem[_8530 + ceil32(return_data.size) + 32 len 32 * _8818] = mem[_8530 + _8674 + 32 len 32 * _8818]
                                            if 0 >= _8818:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8530 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8530 + ceil32(return_data.size) + 32]
                                            if 1 >= _8818:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8530 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8531 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8675 = mem[_8531]
                                            require mem[_8531] <= test266151307()
                                            require _8531 + mem[_8531] + 31 < _8531 + return_data.size
                                            _8819 = mem[_8531 + mem[_8531]]
                                            if mem[_8531 + mem[_8531]] > test266151307():
                                                revert with 0, 65
                                            if _8531 + ceil32(return_data.size) + ceil32(32 * mem[_8531 + mem[_8531]]) + 1 > test266151307() or ceil32(32 * mem[_8531 + mem[_8531]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8531 + ceil32(return_data.size) + ceil32(32 * mem[_8531 + mem[_8531]]) + 1
                                            mem[_8531 + ceil32(return_data.size)] = _8819
                                            require return_data.size >= _8675 + (32 * _8819) + 32
                                            mem[_8531 + ceil32(return_data.size) + 32 len 32 * _8819] = mem[_8531 + _8675 + 32 len 32 * _8819]
                                            if 0 >= _8819:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8531 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8531 + ceil32(return_data.size) + 32]
                                            if 1 >= _8819:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8531 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8532 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8676 = mem[_8532]
                                            require mem[_8532] <= test266151307()
                                            require _8532 + mem[_8532] + 31 < _8532 + return_data.size
                                            _8820 = mem[_8532 + mem[_8532]]
                                            if mem[_8532 + mem[_8532]] > test266151307():
                                                revert with 0, 65
                                            if _8532 + ceil32(return_data.size) + ceil32(32 * mem[_8532 + mem[_8532]]) + 1 > test266151307() or ceil32(32 * mem[_8532 + mem[_8532]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8532 + ceil32(return_data.size) + ceil32(32 * mem[_8532 + mem[_8532]]) + 1
                                            mem[_8532 + ceil32(return_data.size)] = _8820
                                            require return_data.size >= _8676 + (32 * _8820) + 32
                                            mem[_8532 + ceil32(return_data.size) + 32 len 32 * _8820] = mem[_8532 + _8676 + 32 len 32 * _8820]
                                            if 0 >= _8820:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8532 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8532 + ceil32(return_data.size) + 32]
                                            if 1 >= _8820:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8532 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5750:
                                                    revert with 0, 17
                                                mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                                mem[_5754 + 132] = 0
                                                mem[_5754 + 164] = 160
                                                mem[_5754 + 260] = mem[_5754]
                                                idx = 0
                                                s = _5754 + 292
                                                t = _5754 + 32
                                                while idx < mem[_5754]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5754 + 196] = this.address
                                                mem[_5754 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8533 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8677 = mem[_8533]
                                                require mem[_8533] <= test266151307()
                                                require _8533 + mem[_8533] + 31 < _8533 + return_data.size
                                                _8821 = mem[_8533 + mem[_8533]]
                                                if mem[_8533 + mem[_8533]] > test266151307():
                                                    revert with 0, 65
                                                if _8533 + ceil32(return_data.size) + ceil32(32 * mem[_8533 + mem[_8533]]) + 1 > test266151307() or ceil32(32 * mem[_8533 + mem[_8533]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8533 + ceil32(return_data.size) + ceil32(32 * mem[_8533 + mem[_8533]]) + 1
                                                mem[_8533 + ceil32(return_data.size)] = _8821
                                                require return_data.size >= _8677 + (32 * _8821) + 32
                                                mem[_8533 + ceil32(return_data.size) + 32 len 32 * _8821] = mem[_8533 + _8677 + 32 len 32 * _8821]
                                                if 0 >= _8821:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8533 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8533 + ceil32(return_data.size) + 32]
                                                if 1 >= _8821:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8533 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5750:
                                                        revert with 0, 17
                                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                                    mem[_5754 + 132] = 0
                                                    mem[_5754 + 164] = 160
                                                    mem[_5754 + 260] = mem[_5754]
                                                    idx = 0
                                                    s = _5754 + 292
                                                    t = _5754 + 32
                                                    while idx < mem[_5754]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5754 + 196] = this.address
                                                    mem[_5754 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8534 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8678 = mem[_8534]
                                                    require mem[_8534] <= test266151307()
                                                    require _8534 + mem[_8534] + 31 < _8534 + return_data.size
                                                    _8822 = mem[_8534 + mem[_8534]]
                                                    if mem[_8534 + mem[_8534]] > test266151307():
                                                        revert with 0, 65
                                                    if _8534 + ceil32(return_data.size) + ceil32(32 * mem[_8534 + mem[_8534]]) + 1 > test266151307() or ceil32(32 * mem[_8534 + mem[_8534]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8534 + ceil32(return_data.size) + ceil32(32 * mem[_8534 + mem[_8534]]) + 1
                                                    mem[_8534 + ceil32(return_data.size)] = _8822
                                                    require return_data.size >= _8678 + (32 * _8822) + 32
                                                    mem[_8534 + ceil32(return_data.size) + 32 len 32 * _8822] = mem[_8534 + _8678 + 32 len 32 * _8822]
                                                    if 0 >= _8822:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8534 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8534 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8822:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8534 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5750:
                                                        revert with 0, 17
                                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                                    mem[_5754 + 132] = 0
                                                    mem[_5754 + 164] = 160
                                                    mem[_5754 + 260] = mem[_5754]
                                                    idx = 0
                                                    s = _5754 + 292
                                                    t = _5754 + 32
                                                    while idx < mem[_5754]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5754 + 196] = this.address
                                                    mem[_5754 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8535 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8679 = mem[_8535]
                                                    require mem[_8535] <= test266151307()
                                                    require _8535 + mem[_8535] + 31 < _8535 + return_data.size
                                                    _8823 = mem[_8535 + mem[_8535]]
                                                    if mem[_8535 + mem[_8535]] > test266151307():
                                                        revert with 0, 65
                                                    if _8535 + ceil32(return_data.size) + ceil32(32 * mem[_8535 + mem[_8535]]) + 1 > test266151307() or ceil32(32 * mem[_8535 + mem[_8535]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8535 + ceil32(return_data.size) + ceil32(32 * mem[_8535 + mem[_8535]]) + 1
                                                    mem[_8535 + ceil32(return_data.size)] = _8823
                                                    require return_data.size >= _8679 + (32 * _8823) + 32
                                                    mem[_8535 + ceil32(return_data.size) + 32 len 32 * _8823] = mem[_8535 + _8679 + 32 len 32 * _8823]
                                                    if 0 >= _8823:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8535 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8535 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8823:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8535 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8536 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8680 = mem[_8536]
                                            require mem[_8536] <= test266151307()
                                            require _8536 + mem[_8536] + 31 < _8536 + return_data.size
                                            _8824 = mem[_8536 + mem[_8536]]
                                            if mem[_8536 + mem[_8536]] > test266151307():
                                                revert with 0, 65
                                            if _8536 + ceil32(return_data.size) + ceil32(32 * mem[_8536 + mem[_8536]]) + 1 > test266151307() or ceil32(32 * mem[_8536 + mem[_8536]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8536 + ceil32(return_data.size) + ceil32(32 * mem[_8536 + mem[_8536]]) + 1
                                            mem[_8536 + ceil32(return_data.size)] = _8824
                                            require return_data.size >= _8680 + (32 * _8824) + 32
                                            mem[_8536 + ceil32(return_data.size) + 32 len 32 * _8824] = mem[_8536 + _8680 + 32 len 32 * _8824]
                                            if 0 >= _8824:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8536 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8536 + ceil32(return_data.size) + 32]
                                            if 1 >= _8824:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8536 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8537 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8681 = mem[_8537]
                                            require mem[_8537] <= test266151307()
                                            require _8537 + mem[_8537] + 31 < _8537 + return_data.size
                                            _8825 = mem[_8537 + mem[_8537]]
                                            if mem[_8537 + mem[_8537]] > test266151307():
                                                revert with 0, 65
                                            if _8537 + ceil32(return_data.size) + ceil32(32 * mem[_8537 + mem[_8537]]) + 1 > test266151307() or ceil32(32 * mem[_8537 + mem[_8537]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8537 + ceil32(return_data.size) + ceil32(32 * mem[_8537 + mem[_8537]]) + 1
                                            mem[_8537 + ceil32(return_data.size)] = _8825
                                            require return_data.size >= _8681 + (32 * _8825) + 32
                                            mem[_8537 + ceil32(return_data.size) + 32 len 32 * _8825] = mem[_8537 + _8681 + 32 len 32 * _8825]
                                            if 0 >= _8825:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8537 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8537 + ceil32(return_data.size) + 32]
                                            if 1 >= _8825:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8537 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5750:
                                                revert with 0, 17
                                            mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                            mem[_5754 + 132] = 0
                                            mem[_5754 + 164] = 160
                                            mem[_5754 + 260] = mem[_5754]
                                            idx = 0
                                            s = _5754 + 292
                                            t = _5754 + 32
                                            while idx < mem[_5754]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5754 + 196] = this.address
                                            mem[_5754 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8538 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8682 = mem[_8538]
                                            require mem[_8538] <= test266151307()
                                            require _8538 + mem[_8538] + 31 < _8538 + return_data.size
                                            _8826 = mem[_8538 + mem[_8538]]
                                            if mem[_8538 + mem[_8538]] > test266151307():
                                                revert with 0, 65
                                            if _8538 + ceil32(return_data.size) + ceil32(32 * mem[_8538 + mem[_8538]]) + 1 > test266151307() or ceil32(32 * mem[_8538 + mem[_8538]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8538 + ceil32(return_data.size) + ceil32(32 * mem[_8538 + mem[_8538]]) + 1
                                            mem[_8538 + ceil32(return_data.size)] = _8826
                                            require return_data.size >= _8682 + (32 * _8826) + 32
                                            mem[_8538 + ceil32(return_data.size) + 32 len 32 * _8826] = mem[_8538 + _8682 + 32 len 32 * _8826]
                                            if 0 >= _8826:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8538 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8538 + ceil32(return_data.size) + 32]
                                            if 1 >= _8826:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8538 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5750:
                                                    revert with 0, 17
                                                mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                                mem[_5754 + 132] = 0
                                                mem[_5754 + 164] = 160
                                                mem[_5754 + 260] = mem[_5754]
                                                idx = 0
                                                s = _5754 + 292
                                                t = _5754 + 32
                                                while idx < mem[_5754]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5754 + 196] = this.address
                                                mem[_5754 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8539 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8683 = mem[_8539]
                                                require mem[_8539] <= test266151307()
                                                require _8539 + mem[_8539] + 31 < _8539 + return_data.size
                                                _8827 = mem[_8539 + mem[_8539]]
                                                if mem[_8539 + mem[_8539]] > test266151307():
                                                    revert with 0, 65
                                                if _8539 + ceil32(return_data.size) + ceil32(32 * mem[_8539 + mem[_8539]]) + 1 > test266151307() or ceil32(32 * mem[_8539 + mem[_8539]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8539 + ceil32(return_data.size) + ceil32(32 * mem[_8539 + mem[_8539]]) + 1
                                                mem[_8539 + ceil32(return_data.size)] = _8827
                                                require return_data.size >= _8683 + (32 * _8827) + 32
                                                mem[_8539 + ceil32(return_data.size) + 32 len 32 * _8827] = mem[_8539 + _8683 + 32 len 32 * _8827]
                                                if 0 >= _8827:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8539 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8539 + ceil32(return_data.size) + 32]
                                                if 1 >= _8827:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8539 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5750:
                                                        revert with 0, 17
                                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5754 + 100] = ext_call.return_data[32] + _5750
                                                    mem[_5754 + 132] = 0
                                                    mem[_5754 + 164] = 160
                                                    mem[_5754 + 260] = mem[_5754]
                                                    idx = 0
                                                    s = _5754 + 292
                                                    t = _5754 + 32
                                                    while idx < mem[_5754]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5754 + 196] = this.address
                                                    mem[_5754 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8540 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8684 = mem[_8540]
                                                    require mem[_8540] <= test266151307()
                                                    require _8540 + mem[_8540] + 31 < _8540 + return_data.size
                                                    _8828 = mem[_8540 + mem[_8540]]
                                                    if mem[_8540 + mem[_8540]] > test266151307():
                                                        revert with 0, 65
                                                    if _8540 + ceil32(return_data.size) + ceil32(32 * mem[_8540 + mem[_8540]]) + 1 > test266151307() or ceil32(32 * mem[_8540 + mem[_8540]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8540 + ceil32(return_data.size) + ceil32(32 * mem[_8540 + mem[_8540]]) + 1
                                                    mem[_8540 + ceil32(return_data.size)] = _8828
                                                    require return_data.size >= _8684 + (32 * _8828) + 32
                                                    mem[_8540 + ceil32(return_data.size) + 32 len 32 * _8828] = mem[_8540 + _8684 + 32 len 32 * _8828]
                                                    if 0 >= _8828:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8540 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8540 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8828:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8540 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5750:
                                                        revert with 0, 17
                                                    mem[_5754 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5754 + 100] = ext_call.return_data[0] + _5750
                                                    mem[_5754 + 132] = 0
                                                    mem[_5754 + 164] = 160
                                                    mem[_5754 + 260] = mem[_5754]
                                                    idx = 0
                                                    s = _5754 + 292
                                                    t = _5754 + 32
                                                    while idx < mem[_5754]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5754 + 196] = this.address
                                                    mem[_5754 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5754 + (32 * mem[_5754]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8541 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8685 = mem[_8541]
                                                    require mem[_8541] <= test266151307()
                                                    require _8541 + mem[_8541] + 31 < _8541 + return_data.size
                                                    _8829 = mem[_8541 + mem[_8541]]
                                                    if mem[_8541 + mem[_8541]] > test266151307():
                                                        revert with 0, 65
                                                    if _8541 + ceil32(return_data.size) + ceil32(32 * mem[_8541 + mem[_8541]]) + 1 > test266151307() or ceil32(32 * mem[_8541 + mem[_8541]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8541 + ceil32(return_data.size) + ceil32(32 * mem[_8541 + mem[_8541]]) + 1
                                                    mem[_8541 + ceil32(return_data.size)] = _8829
                                                    require return_data.size >= _8685 + (32 * _8829) + 32
                                                    mem[_8541 + ceil32(return_data.size) + 32 len 32 * _8829] = mem[_8541 + _8685 + 32 len 32 * _8829]
                                                    if 0 >= _8829:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8541 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8541 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8829:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8541 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2985 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3016 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3016
                    require return_data.size >= _2985 + (32 * _3016) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3016] = mem[(4 * ceil32(return_data.size)) + _2985 + 224 len 32 * _3016]
                    if 1 >= _3016:
                        revert with 0, 50
                    _5751 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5755 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5755]:
                        revert with 0, 50
                    mem[_5755 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5755]:
                        revert with 0, 50
                    mem[_5755 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8542 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8686 = mem[_8542]
                                    require mem[_8542] <= test266151307()
                                    require _8542 + mem[_8542] + 31 < _8542 + return_data.size
                                    _8830 = mem[_8542 + mem[_8542]]
                                    if mem[_8542 + mem[_8542]] > test266151307():
                                        revert with 0, 65
                                    if _8542 + ceil32(return_data.size) + ceil32(32 * mem[_8542 + mem[_8542]]) + 1 > test266151307() or ceil32(32 * mem[_8542 + mem[_8542]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8542 + ceil32(return_data.size) + ceil32(32 * mem[_8542 + mem[_8542]]) + 1
                                    mem[_8542 + ceil32(return_data.size)] = _8830
                                    require return_data.size >= _8686 + (32 * _8830) + 32
                                    mem[_8542 + ceil32(return_data.size) + 32 len 32 * _8830] = mem[_8542 + _8686 + 32 len 32 * _8830]
                                    if 0 >= _8830:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8542 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8542 + ceil32(return_data.size) + 32]
                                    if 1 >= _8830:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8542 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8543 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8687 = mem[_8543]
                                    require mem[_8543] <= test266151307()
                                    require _8543 + mem[_8543] + 31 < _8543 + return_data.size
                                    _8831 = mem[_8543 + mem[_8543]]
                                    if mem[_8543 + mem[_8543]] > test266151307():
                                        revert with 0, 65
                                    if _8543 + ceil32(return_data.size) + ceil32(32 * mem[_8543 + mem[_8543]]) + 1 > test266151307() or ceil32(32 * mem[_8543 + mem[_8543]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8543 + ceil32(return_data.size) + ceil32(32 * mem[_8543 + mem[_8543]]) + 1
                                    mem[_8543 + ceil32(return_data.size)] = _8831
                                    require return_data.size >= _8687 + (32 * _8831) + 32
                                    mem[_8543 + ceil32(return_data.size) + 32 len 32 * _8831] = mem[_8543 + _8687 + 32 len 32 * _8831]
                                    if 0 >= _8831:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8543 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8543 + ceil32(return_data.size) + 32]
                                    if 1 >= _8831:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8543 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8544 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8688 = mem[_8544]
                                    require mem[_8544] <= test266151307()
                                    require _8544 + mem[_8544] + 31 < _8544 + return_data.size
                                    _8832 = mem[_8544 + mem[_8544]]
                                    if mem[_8544 + mem[_8544]] > test266151307():
                                        revert with 0, 65
                                    if _8544 + ceil32(return_data.size) + ceil32(32 * mem[_8544 + mem[_8544]]) + 1 > test266151307() or ceil32(32 * mem[_8544 + mem[_8544]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8544 + ceil32(return_data.size) + ceil32(32 * mem[_8544 + mem[_8544]]) + 1
                                    mem[_8544 + ceil32(return_data.size)] = _8832
                                    require return_data.size >= _8688 + (32 * _8832) + 32
                                    mem[_8544 + ceil32(return_data.size) + 32 len 32 * _8832] = mem[_8544 + _8688 + 32 len 32 * _8832]
                                    if 0 >= _8832:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8544 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8544 + ceil32(return_data.size) + 32]
                                    if 1 >= _8832:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8544 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8545 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8689 = mem[_8545]
                                        require mem[_8545] <= test266151307()
                                        require _8545 + mem[_8545] + 31 < _8545 + return_data.size
                                        _8833 = mem[_8545 + mem[_8545]]
                                        if mem[_8545 + mem[_8545]] > test266151307():
                                            revert with 0, 65
                                        if _8545 + ceil32(return_data.size) + ceil32(32 * mem[_8545 + mem[_8545]]) + 1 > test266151307() or ceil32(32 * mem[_8545 + mem[_8545]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8545 + ceil32(return_data.size) + ceil32(32 * mem[_8545 + mem[_8545]]) + 1
                                        mem[_8545 + ceil32(return_data.size)] = _8833
                                        require return_data.size >= _8689 + (32 * _8833) + 32
                                        mem[_8545 + ceil32(return_data.size) + 32 len 32 * _8833] = mem[_8545 + _8689 + 32 len 32 * _8833]
                                        if 0 >= _8833:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8545 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8545 + ceil32(return_data.size) + 32]
                                        if 1 >= _8833:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8545 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8546 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8690 = mem[_8546]
                                            require mem[_8546] <= test266151307()
                                            require _8546 + mem[_8546] + 31 < _8546 + return_data.size
                                            _8834 = mem[_8546 + mem[_8546]]
                                            if mem[_8546 + mem[_8546]] > test266151307():
                                                revert with 0, 65
                                            if _8546 + ceil32(return_data.size) + ceil32(32 * mem[_8546 + mem[_8546]]) + 1 > test266151307() or ceil32(32 * mem[_8546 + mem[_8546]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8546 + ceil32(return_data.size) + ceil32(32 * mem[_8546 + mem[_8546]]) + 1
                                            mem[_8546 + ceil32(return_data.size)] = _8834
                                            require return_data.size >= _8690 + (32 * _8834) + 32
                                            mem[_8546 + ceil32(return_data.size) + 32 len 32 * _8834] = mem[_8546 + _8690 + 32 len 32 * _8834]
                                            if 0 >= _8834:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8546 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8546 + ceil32(return_data.size) + 32]
                                            if 1 >= _8834:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8546 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8547 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8691 = mem[_8547]
                                            require mem[_8547] <= test266151307()
                                            require _8547 + mem[_8547] + 31 < _8547 + return_data.size
                                            _8835 = mem[_8547 + mem[_8547]]
                                            if mem[_8547 + mem[_8547]] > test266151307():
                                                revert with 0, 65
                                            if _8547 + ceil32(return_data.size) + ceil32(32 * mem[_8547 + mem[_8547]]) + 1 > test266151307() or ceil32(32 * mem[_8547 + mem[_8547]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8547 + ceil32(return_data.size) + ceil32(32 * mem[_8547 + mem[_8547]]) + 1
                                            mem[_8547 + ceil32(return_data.size)] = _8835
                                            require return_data.size >= _8691 + (32 * _8835) + 32
                                            mem[_8547 + ceil32(return_data.size) + 32 len 32 * _8835] = mem[_8547 + _8691 + 32 len 32 * _8835]
                                            if 0 >= _8835:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8547 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8547 + ceil32(return_data.size) + 32]
                                            if 1 >= _8835:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8547 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8548 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8692 = mem[_8548]
                                    require mem[_8548] <= test266151307()
                                    require _8548 + mem[_8548] + 31 < _8548 + return_data.size
                                    _8836 = mem[_8548 + mem[_8548]]
                                    if mem[_8548 + mem[_8548]] > test266151307():
                                        revert with 0, 65
                                    if _8548 + ceil32(return_data.size) + ceil32(32 * mem[_8548 + mem[_8548]]) + 1 > test266151307() or ceil32(32 * mem[_8548 + mem[_8548]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8548 + ceil32(return_data.size) + ceil32(32 * mem[_8548 + mem[_8548]]) + 1
                                    mem[_8548 + ceil32(return_data.size)] = _8836
                                    require return_data.size >= _8692 + (32 * _8836) + 32
                                    mem[_8548 + ceil32(return_data.size) + 32 len 32 * _8836] = mem[_8548 + _8692 + 32 len 32 * _8836]
                                    if 0 >= _8836:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8548 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8548 + ceil32(return_data.size) + 32]
                                    if 1 >= _8836:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8548 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8549 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8693 = mem[_8549]
                                    require mem[_8549] <= test266151307()
                                    require _8549 + mem[_8549] + 31 < _8549 + return_data.size
                                    _8837 = mem[_8549 + mem[_8549]]
                                    if mem[_8549 + mem[_8549]] > test266151307():
                                        revert with 0, 65
                                    if _8549 + ceil32(return_data.size) + ceil32(32 * mem[_8549 + mem[_8549]]) + 1 > test266151307() or ceil32(32 * mem[_8549 + mem[_8549]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8549 + ceil32(return_data.size) + ceil32(32 * mem[_8549 + mem[_8549]]) + 1
                                    mem[_8549 + ceil32(return_data.size)] = _8837
                                    require return_data.size >= _8693 + (32 * _8837) + 32
                                    mem[_8549 + ceil32(return_data.size) + 32 len 32 * _8837] = mem[_8549 + _8693 + 32 len 32 * _8837]
                                    if 0 >= _8837:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8549 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8549 + ceil32(return_data.size) + 32]
                                    if 1 >= _8837:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8549 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8550 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8694 = mem[_8550]
                                    require mem[_8550] <= test266151307()
                                    require _8550 + mem[_8550] + 31 < _8550 + return_data.size
                                    _8838 = mem[_8550 + mem[_8550]]
                                    if mem[_8550 + mem[_8550]] > test266151307():
                                        revert with 0, 65
                                    if _8550 + ceil32(return_data.size) + ceil32(32 * mem[_8550 + mem[_8550]]) + 1 > test266151307() or ceil32(32 * mem[_8550 + mem[_8550]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8550 + ceil32(return_data.size) + ceil32(32 * mem[_8550 + mem[_8550]]) + 1
                                    mem[_8550 + ceil32(return_data.size)] = _8838
                                    require return_data.size >= _8694 + (32 * _8838) + 32
                                    mem[_8550 + ceil32(return_data.size) + 32 len 32 * _8838] = mem[_8550 + _8694 + 32 len 32 * _8838]
                                    if 0 >= _8838:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8550 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8550 + ceil32(return_data.size) + 32]
                                    if 1 >= _8838:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8550 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8551 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8695 = mem[_8551]
                                        require mem[_8551] <= test266151307()
                                        require _8551 + mem[_8551] + 31 < _8551 + return_data.size
                                        _8839 = mem[_8551 + mem[_8551]]
                                        if mem[_8551 + mem[_8551]] > test266151307():
                                            revert with 0, 65
                                        if _8551 + ceil32(return_data.size) + ceil32(32 * mem[_8551 + mem[_8551]]) + 1 > test266151307() or ceil32(32 * mem[_8551 + mem[_8551]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8551 + ceil32(return_data.size) + ceil32(32 * mem[_8551 + mem[_8551]]) + 1
                                        mem[_8551 + ceil32(return_data.size)] = _8839
                                        require return_data.size >= _8695 + (32 * _8839) + 32
                                        mem[_8551 + ceil32(return_data.size) + 32 len 32 * _8839] = mem[_8551 + _8695 + 32 len 32 * _8839]
                                        if 0 >= _8839:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8551 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8551 + ceil32(return_data.size) + 32]
                                        if 1 >= _8839:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8551 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8552 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8696 = mem[_8552]
                                            require mem[_8552] <= test266151307()
                                            require _8552 + mem[_8552] + 31 < _8552 + return_data.size
                                            _8840 = mem[_8552 + mem[_8552]]
                                            if mem[_8552 + mem[_8552]] > test266151307():
                                                revert with 0, 65
                                            if _8552 + ceil32(return_data.size) + ceil32(32 * mem[_8552 + mem[_8552]]) + 1 > test266151307() or ceil32(32 * mem[_8552 + mem[_8552]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8552 + ceil32(return_data.size) + ceil32(32 * mem[_8552 + mem[_8552]]) + 1
                                            mem[_8552 + ceil32(return_data.size)] = _8840
                                            require return_data.size >= _8696 + (32 * _8840) + 32
                                            mem[_8552 + ceil32(return_data.size) + 32 len 32 * _8840] = mem[_8552 + _8696 + 32 len 32 * _8840]
                                            if 0 >= _8840:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8552 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8552 + ceil32(return_data.size) + 32]
                                            if 1 >= _8840:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8552 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8553 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8697 = mem[_8553]
                                            require mem[_8553] <= test266151307()
                                            require _8553 + mem[_8553] + 31 < _8553 + return_data.size
                                            _8841 = mem[_8553 + mem[_8553]]
                                            if mem[_8553 + mem[_8553]] > test266151307():
                                                revert with 0, 65
                                            if _8553 + ceil32(return_data.size) + ceil32(32 * mem[_8553 + mem[_8553]]) + 1 > test266151307() or ceil32(32 * mem[_8553 + mem[_8553]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8553 + ceil32(return_data.size) + ceil32(32 * mem[_8553 + mem[_8553]]) + 1
                                            mem[_8553 + ceil32(return_data.size)] = _8841
                                            require return_data.size >= _8697 + (32 * _8841) + 32
                                            mem[_8553 + ceil32(return_data.size) + 32 len 32 * _8841] = mem[_8553 + _8697 + 32 len 32 * _8841]
                                            if 0 >= _8841:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8553 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8553 + ceil32(return_data.size) + 32]
                                            if 1 >= _8841:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8553 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8554 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8698 = mem[_8554]
                                    require mem[_8554] <= test266151307()
                                    require _8554 + mem[_8554] + 31 < _8554 + return_data.size
                                    _8842 = mem[_8554 + mem[_8554]]
                                    if mem[_8554 + mem[_8554]] > test266151307():
                                        revert with 0, 65
                                    if _8554 + ceil32(return_data.size) + ceil32(32 * mem[_8554 + mem[_8554]]) + 1 > test266151307() or ceil32(32 * mem[_8554 + mem[_8554]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8554 + ceil32(return_data.size) + ceil32(32 * mem[_8554 + mem[_8554]]) + 1
                                    mem[_8554 + ceil32(return_data.size)] = _8842
                                    require return_data.size >= _8698 + (32 * _8842) + 32
                                    mem[_8554 + ceil32(return_data.size) + 32 len 32 * _8842] = mem[_8554 + _8698 + 32 len 32 * _8842]
                                    if 0 >= _8842:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8554 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8554 + ceil32(return_data.size) + 32]
                                    if 1 >= _8842:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8554 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8555 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8699 = mem[_8555]
                                    require mem[_8555] <= test266151307()
                                    require _8555 + mem[_8555] + 31 < _8555 + return_data.size
                                    _8843 = mem[_8555 + mem[_8555]]
                                    if mem[_8555 + mem[_8555]] > test266151307():
                                        revert with 0, 65
                                    if _8555 + ceil32(return_data.size) + ceil32(32 * mem[_8555 + mem[_8555]]) + 1 > test266151307() or ceil32(32 * mem[_8555 + mem[_8555]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8555 + ceil32(return_data.size) + ceil32(32 * mem[_8555 + mem[_8555]]) + 1
                                    mem[_8555 + ceil32(return_data.size)] = _8843
                                    require return_data.size >= _8699 + (32 * _8843) + 32
                                    mem[_8555 + ceil32(return_data.size) + 32 len 32 * _8843] = mem[_8555 + _8699 + 32 len 32 * _8843]
                                    if 0 >= _8843:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8555 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8555 + ceil32(return_data.size) + 32]
                                    if 1 >= _8843:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8555 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8556 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8700 = mem[_8556]
                                    require mem[_8556] <= test266151307()
                                    require _8556 + mem[_8556] + 31 < _8556 + return_data.size
                                    _8844 = mem[_8556 + mem[_8556]]
                                    if mem[_8556 + mem[_8556]] > test266151307():
                                        revert with 0, 65
                                    if _8556 + ceil32(return_data.size) + ceil32(32 * mem[_8556 + mem[_8556]]) + 1 > test266151307() or ceil32(32 * mem[_8556 + mem[_8556]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8556 + ceil32(return_data.size) + ceil32(32 * mem[_8556 + mem[_8556]]) + 1
                                    mem[_8556 + ceil32(return_data.size)] = _8844
                                    require return_data.size >= _8700 + (32 * _8844) + 32
                                    mem[_8556 + ceil32(return_data.size) + 32 len 32 * _8844] = mem[_8556 + _8700 + 32 len 32 * _8844]
                                    if 0 >= _8844:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8556 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8556 + ceil32(return_data.size) + 32]
                                    if 1 >= _8844:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8556 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8557 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8701 = mem[_8557]
                                        require mem[_8557] <= test266151307()
                                        require _8557 + mem[_8557] + 31 < _8557 + return_data.size
                                        _8845 = mem[_8557 + mem[_8557]]
                                        if mem[_8557 + mem[_8557]] > test266151307():
                                            revert with 0, 65
                                        if _8557 + ceil32(return_data.size) + ceil32(32 * mem[_8557 + mem[_8557]]) + 1 > test266151307() or ceil32(32 * mem[_8557 + mem[_8557]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8557 + ceil32(return_data.size) + ceil32(32 * mem[_8557 + mem[_8557]]) + 1
                                        mem[_8557 + ceil32(return_data.size)] = _8845
                                        require return_data.size >= _8701 + (32 * _8845) + 32
                                        mem[_8557 + ceil32(return_data.size) + 32 len 32 * _8845] = mem[_8557 + _8701 + 32 len 32 * _8845]
                                        if 0 >= _8845:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8557 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8557 + ceil32(return_data.size) + 32]
                                        if 1 >= _8845:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8557 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8558 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8702 = mem[_8558]
                                            require mem[_8558] <= test266151307()
                                            require _8558 + mem[_8558] + 31 < _8558 + return_data.size
                                            _8846 = mem[_8558 + mem[_8558]]
                                            if mem[_8558 + mem[_8558]] > test266151307():
                                                revert with 0, 65
                                            if _8558 + ceil32(return_data.size) + ceil32(32 * mem[_8558 + mem[_8558]]) + 1 > test266151307() or ceil32(32 * mem[_8558 + mem[_8558]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8558 + ceil32(return_data.size) + ceil32(32 * mem[_8558 + mem[_8558]]) + 1
                                            mem[_8558 + ceil32(return_data.size)] = _8846
                                            require return_data.size >= _8702 + (32 * _8846) + 32
                                            mem[_8558 + ceil32(return_data.size) + 32 len 32 * _8846] = mem[_8558 + _8702 + 32 len 32 * _8846]
                                            if 0 >= _8846:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8558 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8558 + ceil32(return_data.size) + 32]
                                            if 1 >= _8846:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8558 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8559 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8703 = mem[_8559]
                                            require mem[_8559] <= test266151307()
                                            require _8559 + mem[_8559] + 31 < _8559 + return_data.size
                                            _8847 = mem[_8559 + mem[_8559]]
                                            if mem[_8559 + mem[_8559]] > test266151307():
                                                revert with 0, 65
                                            if _8559 + ceil32(return_data.size) + ceil32(32 * mem[_8559 + mem[_8559]]) + 1 > test266151307() or ceil32(32 * mem[_8559 + mem[_8559]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8559 + ceil32(return_data.size) + ceil32(32 * mem[_8559 + mem[_8559]]) + 1
                                            mem[_8559 + ceil32(return_data.size)] = _8847
                                            require return_data.size >= _8703 + (32 * _8847) + 32
                                            mem[_8559 + ceil32(return_data.size) + 32 len 32 * _8847] = mem[_8559 + _8703 + 32 len 32 * _8847]
                                            if 0 >= _8847:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8559 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8559 + ceil32(return_data.size) + 32]
                                            if 1 >= _8847:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8559 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8560 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8704 = mem[_8560]
                                        require mem[_8560] <= test266151307()
                                        require _8560 + mem[_8560] + 31 < _8560 + return_data.size
                                        _8848 = mem[_8560 + mem[_8560]]
                                        if mem[_8560 + mem[_8560]] > test266151307():
                                            revert with 0, 65
                                        if _8560 + ceil32(return_data.size) + ceil32(32 * mem[_8560 + mem[_8560]]) + 1 > test266151307() or ceil32(32 * mem[_8560 + mem[_8560]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8560 + ceil32(return_data.size) + ceil32(32 * mem[_8560 + mem[_8560]]) + 1
                                        mem[_8560 + ceil32(return_data.size)] = _8848
                                        require return_data.size >= _8704 + (32 * _8848) + 32
                                        mem[_8560 + ceil32(return_data.size) + 32 len 32 * _8848] = mem[_8560 + _8704 + 32 len 32 * _8848]
                                        if 0 >= _8848:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8560 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8560 + ceil32(return_data.size) + 32]
                                        if 1 >= _8848:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8560 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8561 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8705 = mem[_8561]
                                        require mem[_8561] <= test266151307()
                                        require _8561 + mem[_8561] + 31 < _8561 + return_data.size
                                        _8849 = mem[_8561 + mem[_8561]]
                                        if mem[_8561 + mem[_8561]] > test266151307():
                                            revert with 0, 65
                                        if _8561 + ceil32(return_data.size) + ceil32(32 * mem[_8561 + mem[_8561]]) + 1 > test266151307() or ceil32(32 * mem[_8561 + mem[_8561]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8561 + ceil32(return_data.size) + ceil32(32 * mem[_8561 + mem[_8561]]) + 1
                                        mem[_8561 + ceil32(return_data.size)] = _8849
                                        require return_data.size >= _8705 + (32 * _8849) + 32
                                        mem[_8561 + ceil32(return_data.size) + 32 len 32 * _8849] = mem[_8561 + _8705 + 32 len 32 * _8849]
                                        if 0 >= _8849:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8561 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8561 + ceil32(return_data.size) + 32]
                                        if 1 >= _8849:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8561 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8562 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8706 = mem[_8562]
                                        require mem[_8562] <= test266151307()
                                        require _8562 + mem[_8562] + 31 < _8562 + return_data.size
                                        _8850 = mem[_8562 + mem[_8562]]
                                        if mem[_8562 + mem[_8562]] > test266151307():
                                            revert with 0, 65
                                        if _8562 + ceil32(return_data.size) + ceil32(32 * mem[_8562 + mem[_8562]]) + 1 > test266151307() or ceil32(32 * mem[_8562 + mem[_8562]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8562 + ceil32(return_data.size) + ceil32(32 * mem[_8562 + mem[_8562]]) + 1
                                        mem[_8562 + ceil32(return_data.size)] = _8850
                                        require return_data.size >= _8706 + (32 * _8850) + 32
                                        mem[_8562 + ceil32(return_data.size) + 32 len 32 * _8850] = mem[_8562 + _8706 + 32 len 32 * _8850]
                                        if 0 >= _8850:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8562 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8562 + ceil32(return_data.size) + 32]
                                        if 1 >= _8850:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8562 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8563 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8707 = mem[_8563]
                                            require mem[_8563] <= test266151307()
                                            require _8563 + mem[_8563] + 31 < _8563 + return_data.size
                                            _8851 = mem[_8563 + mem[_8563]]
                                            if mem[_8563 + mem[_8563]] > test266151307():
                                                revert with 0, 65
                                            if _8563 + ceil32(return_data.size) + ceil32(32 * mem[_8563 + mem[_8563]]) + 1 > test266151307() or ceil32(32 * mem[_8563 + mem[_8563]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8563 + ceil32(return_data.size) + ceil32(32 * mem[_8563 + mem[_8563]]) + 1
                                            mem[_8563 + ceil32(return_data.size)] = _8851
                                            require return_data.size >= _8707 + (32 * _8851) + 32
                                            mem[_8563 + ceil32(return_data.size) + 32 len 32 * _8851] = mem[_8563 + _8707 + 32 len 32 * _8851]
                                            if 0 >= _8851:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8563 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8563 + ceil32(return_data.size) + 32]
                                            if 1 >= _8851:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8563 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5751:
                                                    revert with 0, 17
                                                mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                                mem[_5755 + 132] = 0
                                                mem[_5755 + 164] = 160
                                                mem[_5755 + 260] = mem[_5755]
                                                idx = 0
                                                s = _5755 + 292
                                                t = _5755 + 32
                                                while idx < mem[_5755]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5755 + 196] = this.address
                                                mem[_5755 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8564 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8708 = mem[_8564]
                                                require mem[_8564] <= test266151307()
                                                require _8564 + mem[_8564] + 31 < _8564 + return_data.size
                                                _8852 = mem[_8564 + mem[_8564]]
                                                if mem[_8564 + mem[_8564]] > test266151307():
                                                    revert with 0, 65
                                                if _8564 + ceil32(return_data.size) + ceil32(32 * mem[_8564 + mem[_8564]]) + 1 > test266151307() or ceil32(32 * mem[_8564 + mem[_8564]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8564 + ceil32(return_data.size) + ceil32(32 * mem[_8564 + mem[_8564]]) + 1
                                                mem[_8564 + ceil32(return_data.size)] = _8852
                                                require return_data.size >= _8708 + (32 * _8852) + 32
                                                mem[_8564 + ceil32(return_data.size) + 32 len 32 * _8852] = mem[_8564 + _8708 + 32 len 32 * _8852]
                                                if 0 >= _8852:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8564 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8564 + ceil32(return_data.size) + 32]
                                                if 1 >= _8852:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8564 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5751:
                                                    revert with 0, 17
                                                mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                                mem[_5755 + 132] = 0
                                                mem[_5755 + 164] = 160
                                                mem[_5755 + 260] = mem[_5755]
                                                idx = 0
                                                s = _5755 + 292
                                                t = _5755 + 32
                                                while idx < mem[_5755]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5755 + 196] = this.address
                                                mem[_5755 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8565 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8709 = mem[_8565]
                                                require mem[_8565] <= test266151307()
                                                require _8565 + mem[_8565] + 31 < _8565 + return_data.size
                                                _8853 = mem[_8565 + mem[_8565]]
                                                if mem[_8565 + mem[_8565]] > test266151307():
                                                    revert with 0, 65
                                                if _8565 + ceil32(return_data.size) + ceil32(32 * mem[_8565 + mem[_8565]]) + 1 > test266151307() or ceil32(32 * mem[_8565 + mem[_8565]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8565 + ceil32(return_data.size) + ceil32(32 * mem[_8565 + mem[_8565]]) + 1
                                                mem[_8565 + ceil32(return_data.size)] = _8853
                                                require return_data.size >= _8709 + (32 * _8853) + 32
                                                mem[_8565 + ceil32(return_data.size) + 32 len 32 * _8853] = mem[_8565 + _8709 + 32 len 32 * _8853]
                                                if 0 >= _8853:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8565 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8565 + ceil32(return_data.size) + 32]
                                                if 1 >= _8853:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8565 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8566 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8710 = mem[_8566]
                                            require mem[_8566] <= test266151307()
                                            require _8566 + mem[_8566] + 31 < _8566 + return_data.size
                                            _8854 = mem[_8566 + mem[_8566]]
                                            if mem[_8566 + mem[_8566]] > test266151307():
                                                revert with 0, 65
                                            if _8566 + ceil32(return_data.size) + ceil32(32 * mem[_8566 + mem[_8566]]) + 1 > test266151307() or ceil32(32 * mem[_8566 + mem[_8566]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8566 + ceil32(return_data.size) + ceil32(32 * mem[_8566 + mem[_8566]]) + 1
                                            mem[_8566 + ceil32(return_data.size)] = _8854
                                            require return_data.size >= _8710 + (32 * _8854) + 32
                                            mem[_8566 + ceil32(return_data.size) + 32 len 32 * _8854] = mem[_8566 + _8710 + 32 len 32 * _8854]
                                            if 0 >= _8854:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8566 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8566 + ceil32(return_data.size) + 32]
                                            if 1 >= _8854:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8566 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8567 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8711 = mem[_8567]
                                            require mem[_8567] <= test266151307()
                                            require _8567 + mem[_8567] + 31 < _8567 + return_data.size
                                            _8855 = mem[_8567 + mem[_8567]]
                                            if mem[_8567 + mem[_8567]] > test266151307():
                                                revert with 0, 65
                                            if _8567 + ceil32(return_data.size) + ceil32(32 * mem[_8567 + mem[_8567]]) + 1 > test266151307() or ceil32(32 * mem[_8567 + mem[_8567]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8567 + ceil32(return_data.size) + ceil32(32 * mem[_8567 + mem[_8567]]) + 1
                                            mem[_8567 + ceil32(return_data.size)] = _8855
                                            require return_data.size >= _8711 + (32 * _8855) + 32
                                            mem[_8567 + ceil32(return_data.size) + 32 len 32 * _8855] = mem[_8567 + _8711 + 32 len 32 * _8855]
                                            if 0 >= _8855:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8567 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8567 + ceil32(return_data.size) + 32]
                                            if 1 >= _8855:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8567 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8568 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8712 = mem[_8568]
                                            require mem[_8568] <= test266151307()
                                            require _8568 + mem[_8568] + 31 < _8568 + return_data.size
                                            _8856 = mem[_8568 + mem[_8568]]
                                            if mem[_8568 + mem[_8568]] > test266151307():
                                                revert with 0, 65
                                            if _8568 + ceil32(return_data.size) + ceil32(32 * mem[_8568 + mem[_8568]]) + 1 > test266151307() or ceil32(32 * mem[_8568 + mem[_8568]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8568 + ceil32(return_data.size) + ceil32(32 * mem[_8568 + mem[_8568]]) + 1
                                            mem[_8568 + ceil32(return_data.size)] = _8856
                                            require return_data.size >= _8712 + (32 * _8856) + 32
                                            mem[_8568 + ceil32(return_data.size) + 32 len 32 * _8856] = mem[_8568 + _8712 + 32 len 32 * _8856]
                                            if 0 >= _8856:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8568 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8568 + ceil32(return_data.size) + 32]
                                            if 1 >= _8856:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8568 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5751:
                                                    revert with 0, 17
                                                mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                                mem[_5755 + 132] = 0
                                                mem[_5755 + 164] = 160
                                                mem[_5755 + 260] = mem[_5755]
                                                idx = 0
                                                s = _5755 + 292
                                                t = _5755 + 32
                                                while idx < mem[_5755]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5755 + 196] = this.address
                                                mem[_5755 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8569 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8713 = mem[_8569]
                                                require mem[_8569] <= test266151307()
                                                require _8569 + mem[_8569] + 31 < _8569 + return_data.size
                                                _8857 = mem[_8569 + mem[_8569]]
                                                if mem[_8569 + mem[_8569]] > test266151307():
                                                    revert with 0, 65
                                                if _8569 + ceil32(return_data.size) + ceil32(32 * mem[_8569 + mem[_8569]]) + 1 > test266151307() or ceil32(32 * mem[_8569 + mem[_8569]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8569 + ceil32(return_data.size) + ceil32(32 * mem[_8569 + mem[_8569]]) + 1
                                                mem[_8569 + ceil32(return_data.size)] = _8857
                                                require return_data.size >= _8713 + (32 * _8857) + 32
                                                mem[_8569 + ceil32(return_data.size) + 32 len 32 * _8857] = mem[_8569 + _8713 + 32 len 32 * _8857]
                                                if 0 >= _8857:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8569 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8569 + ceil32(return_data.size) + 32]
                                                if 1 >= _8857:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8569 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5751:
                                                        revert with 0, 17
                                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                                    mem[_5755 + 132] = 0
                                                    mem[_5755 + 164] = 160
                                                    mem[_5755 + 260] = mem[_5755]
                                                    idx = 0
                                                    s = _5755 + 292
                                                    t = _5755 + 32
                                                    while idx < mem[_5755]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5755 + 196] = this.address
                                                    mem[_5755 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8570 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8714 = mem[_8570]
                                                    require mem[_8570] <= test266151307()
                                                    require _8570 + mem[_8570] + 31 < _8570 + return_data.size
                                                    _8858 = mem[_8570 + mem[_8570]]
                                                    if mem[_8570 + mem[_8570]] > test266151307():
                                                        revert with 0, 65
                                                    if _8570 + ceil32(return_data.size) + ceil32(32 * mem[_8570 + mem[_8570]]) + 1 > test266151307() or ceil32(32 * mem[_8570 + mem[_8570]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8570 + ceil32(return_data.size) + ceil32(32 * mem[_8570 + mem[_8570]]) + 1
                                                    mem[_8570 + ceil32(return_data.size)] = _8858
                                                    require return_data.size >= _8714 + (32 * _8858) + 32
                                                    mem[_8570 + ceil32(return_data.size) + 32 len 32 * _8858] = mem[_8570 + _8714 + 32 len 32 * _8858]
                                                    if 0 >= _8858:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8570 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8570 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8858:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8570 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5751:
                                                        revert with 0, 17
                                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                                    mem[_5755 + 132] = 0
                                                    mem[_5755 + 164] = 160
                                                    mem[_5755 + 260] = mem[_5755]
                                                    idx = 0
                                                    s = _5755 + 292
                                                    t = _5755 + 32
                                                    while idx < mem[_5755]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5755 + 196] = this.address
                                                    mem[_5755 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8571 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8715 = mem[_8571]
                                                    require mem[_8571] <= test266151307()
                                                    require _8571 + mem[_8571] + 31 < _8571 + return_data.size
                                                    _8859 = mem[_8571 + mem[_8571]]
                                                    if mem[_8571 + mem[_8571]] > test266151307():
                                                        revert with 0, 65
                                                    if _8571 + ceil32(return_data.size) + ceil32(32 * mem[_8571 + mem[_8571]]) + 1 > test266151307() or ceil32(32 * mem[_8571 + mem[_8571]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8571 + ceil32(return_data.size) + ceil32(32 * mem[_8571 + mem[_8571]]) + 1
                                                    mem[_8571 + ceil32(return_data.size)] = _8859
                                                    require return_data.size >= _8715 + (32 * _8859) + 32
                                                    mem[_8571 + ceil32(return_data.size) + 32 len 32 * _8859] = mem[_8571 + _8715 + 32 len 32 * _8859]
                                                    if 0 >= _8859:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8571 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8571 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8859:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8571 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8572 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8716 = mem[_8572]
                                            require mem[_8572] <= test266151307()
                                            require _8572 + mem[_8572] + 31 < _8572 + return_data.size
                                            _8860 = mem[_8572 + mem[_8572]]
                                            if mem[_8572 + mem[_8572]] > test266151307():
                                                revert with 0, 65
                                            if _8572 + ceil32(return_data.size) + ceil32(32 * mem[_8572 + mem[_8572]]) + 1 > test266151307() or ceil32(32 * mem[_8572 + mem[_8572]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8572 + ceil32(return_data.size) + ceil32(32 * mem[_8572 + mem[_8572]]) + 1
                                            mem[_8572 + ceil32(return_data.size)] = _8860
                                            require return_data.size >= _8716 + (32 * _8860) + 32
                                            mem[_8572 + ceil32(return_data.size) + 32 len 32 * _8860] = mem[_8572 + _8716 + 32 len 32 * _8860]
                                            if 0 >= _8860:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8572 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8572 + ceil32(return_data.size) + 32]
                                            if 1 >= _8860:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8572 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8573 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8717 = mem[_8573]
                                            require mem[_8573] <= test266151307()
                                            require _8573 + mem[_8573] + 31 < _8573 + return_data.size
                                            _8861 = mem[_8573 + mem[_8573]]
                                            if mem[_8573 + mem[_8573]] > test266151307():
                                                revert with 0, 65
                                            if _8573 + ceil32(return_data.size) + ceil32(32 * mem[_8573 + mem[_8573]]) + 1 > test266151307() or ceil32(32 * mem[_8573 + mem[_8573]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8573 + ceil32(return_data.size) + ceil32(32 * mem[_8573 + mem[_8573]]) + 1
                                            mem[_8573 + ceil32(return_data.size)] = _8861
                                            require return_data.size >= _8717 + (32 * _8861) + 32
                                            mem[_8573 + ceil32(return_data.size) + 32 len 32 * _8861] = mem[_8573 + _8717 + 32 len 32 * _8861]
                                            if 0 >= _8861:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8573 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8573 + ceil32(return_data.size) + 32]
                                            if 1 >= _8861:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8573 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8574 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8718 = mem[_8574]
                                            require mem[_8574] <= test266151307()
                                            require _8574 + mem[_8574] + 31 < _8574 + return_data.size
                                            _8862 = mem[_8574 + mem[_8574]]
                                            if mem[_8574 + mem[_8574]] > test266151307():
                                                revert with 0, 65
                                            if _8574 + ceil32(return_data.size) + ceil32(32 * mem[_8574 + mem[_8574]]) + 1 > test266151307() or ceil32(32 * mem[_8574 + mem[_8574]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8574 + ceil32(return_data.size) + ceil32(32 * mem[_8574 + mem[_8574]]) + 1
                                            mem[_8574 + ceil32(return_data.size)] = _8862
                                            require return_data.size >= _8718 + (32 * _8862) + 32
                                            mem[_8574 + ceil32(return_data.size) + 32 len 32 * _8862] = mem[_8574 + _8718 + 32 len 32 * _8862]
                                            if 0 >= _8862:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8574 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8574 + ceil32(return_data.size) + 32]
                                            if 1 >= _8862:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8574 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5751:
                                                    revert with 0, 17
                                                mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                                mem[_5755 + 132] = 0
                                                mem[_5755 + 164] = 160
                                                mem[_5755 + 260] = mem[_5755]
                                                idx = 0
                                                s = _5755 + 292
                                                t = _5755 + 32
                                                while idx < mem[_5755]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5755 + 196] = this.address
                                                mem[_5755 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8575 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8719 = mem[_8575]
                                                require mem[_8575] <= test266151307()
                                                require _8575 + mem[_8575] + 31 < _8575 + return_data.size
                                                _8863 = mem[_8575 + mem[_8575]]
                                                if mem[_8575 + mem[_8575]] > test266151307():
                                                    revert with 0, 65
                                                if _8575 + ceil32(return_data.size) + ceil32(32 * mem[_8575 + mem[_8575]]) + 1 > test266151307() or ceil32(32 * mem[_8575 + mem[_8575]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8575 + ceil32(return_data.size) + ceil32(32 * mem[_8575 + mem[_8575]]) + 1
                                                mem[_8575 + ceil32(return_data.size)] = _8863
                                                require return_data.size >= _8719 + (32 * _8863) + 32
                                                mem[_8575 + ceil32(return_data.size) + 32 len 32 * _8863] = mem[_8575 + _8719 + 32 len 32 * _8863]
                                                if 0 >= _8863:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8575 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8575 + ceil32(return_data.size) + 32]
                                                if 1 >= _8863:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8575 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5751:
                                                        revert with 0, 17
                                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                                    mem[_5755 + 132] = 0
                                                    mem[_5755 + 164] = 160
                                                    mem[_5755 + 260] = mem[_5755]
                                                    idx = 0
                                                    s = _5755 + 292
                                                    t = _5755 + 32
                                                    while idx < mem[_5755]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5755 + 196] = this.address
                                                    mem[_5755 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8576 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8720 = mem[_8576]
                                                    require mem[_8576] <= test266151307()
                                                    require _8576 + mem[_8576] + 31 < _8576 + return_data.size
                                                    _8864 = mem[_8576 + mem[_8576]]
                                                    if mem[_8576 + mem[_8576]] > test266151307():
                                                        revert with 0, 65
                                                    if _8576 + ceil32(return_data.size) + ceil32(32 * mem[_8576 + mem[_8576]]) + 1 > test266151307() or ceil32(32 * mem[_8576 + mem[_8576]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8576 + ceil32(return_data.size) + ceil32(32 * mem[_8576 + mem[_8576]]) + 1
                                                    mem[_8576 + ceil32(return_data.size)] = _8864
                                                    require return_data.size >= _8720 + (32 * _8864) + 32
                                                    mem[_8576 + ceil32(return_data.size) + 32 len 32 * _8864] = mem[_8576 + _8720 + 32 len 32 * _8864]
                                                    if 0 >= _8864:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8576 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8576 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8864:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8576 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5751:
                                                        revert with 0, 17
                                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                                    mem[_5755 + 132] = 0
                                                    mem[_5755 + 164] = 160
                                                    mem[_5755 + 260] = mem[_5755]
                                                    idx = 0
                                                    s = _5755 + 292
                                                    t = _5755 + 32
                                                    while idx < mem[_5755]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5755 + 196] = this.address
                                                    mem[_5755 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8577 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8721 = mem[_8577]
                                                    require mem[_8577] <= test266151307()
                                                    require _8577 + mem[_8577] + 31 < _8577 + return_data.size
                                                    _8865 = mem[_8577 + mem[_8577]]
                                                    if mem[_8577 + mem[_8577]] > test266151307():
                                                        revert with 0, 65
                                                    if _8577 + ceil32(return_data.size) + ceil32(32 * mem[_8577 + mem[_8577]]) + 1 > test266151307() or ceil32(32 * mem[_8577 + mem[_8577]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8577 + ceil32(return_data.size) + ceil32(32 * mem[_8577 + mem[_8577]]) + 1
                                                    mem[_8577 + ceil32(return_data.size)] = _8865
                                                    require return_data.size >= _8721 + (32 * _8865) + 32
                                                    mem[_8577 + ceil32(return_data.size) + 32 len 32 * _8865] = mem[_8577 + _8721 + 32 len 32 * _8865]
                                                    if 0 >= _8865:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8577 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8577 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8865:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8577 + ceil32(return_data.size) + 64]
            else:
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2986 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3017 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3017
                    require return_data.size >= _2986 + (32 * _3017) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3017] = mem[(4 * ceil32(return_data.size)) + _2986 + 224 len 32 * _3017]
                    if 1 >= _3017:
                        revert with 0, 50
                    _5752 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5756 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5756]:
                        revert with 0, 50
                    mem[_5756 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5756]:
                        revert with 0, 50
                    mem[_5756 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8578 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8722 = mem[_8578]
                                    require mem[_8578] <= test266151307()
                                    require _8578 + mem[_8578] + 31 < _8578 + return_data.size
                                    _8866 = mem[_8578 + mem[_8578]]
                                    if mem[_8578 + mem[_8578]] > test266151307():
                                        revert with 0, 65
                                    if _8578 + ceil32(return_data.size) + ceil32(32 * mem[_8578 + mem[_8578]]) + 1 > test266151307() or ceil32(32 * mem[_8578 + mem[_8578]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8578 + ceil32(return_data.size) + ceil32(32 * mem[_8578 + mem[_8578]]) + 1
                                    mem[_8578 + ceil32(return_data.size)] = _8866
                                    require return_data.size >= _8722 + (32 * _8866) + 32
                                    mem[_8578 + ceil32(return_data.size) + 32 len 32 * _8866] = mem[_8578 + _8722 + 32 len 32 * _8866]
                                    if 0 >= _8866:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8578 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8578 + ceil32(return_data.size) + 32]
                                    if 1 >= _8866:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8578 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8579 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8723 = mem[_8579]
                                    require mem[_8579] <= test266151307()
                                    require _8579 + mem[_8579] + 31 < _8579 + return_data.size
                                    _8867 = mem[_8579 + mem[_8579]]
                                    if mem[_8579 + mem[_8579]] > test266151307():
                                        revert with 0, 65
                                    if _8579 + ceil32(return_data.size) + ceil32(32 * mem[_8579 + mem[_8579]]) + 1 > test266151307() or ceil32(32 * mem[_8579 + mem[_8579]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8579 + ceil32(return_data.size) + ceil32(32 * mem[_8579 + mem[_8579]]) + 1
                                    mem[_8579 + ceil32(return_data.size)] = _8867
                                    require return_data.size >= _8723 + (32 * _8867) + 32
                                    mem[_8579 + ceil32(return_data.size) + 32 len 32 * _8867] = mem[_8579 + _8723 + 32 len 32 * _8867]
                                    if 0 >= _8867:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8579 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8579 + ceil32(return_data.size) + 32]
                                    if 1 >= _8867:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8579 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8580 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8724 = mem[_8580]
                                    require mem[_8580] <= test266151307()
                                    require _8580 + mem[_8580] + 31 < _8580 + return_data.size
                                    _8868 = mem[_8580 + mem[_8580]]
                                    if mem[_8580 + mem[_8580]] > test266151307():
                                        revert with 0, 65
                                    if _8580 + ceil32(return_data.size) + ceil32(32 * mem[_8580 + mem[_8580]]) + 1 > test266151307() or ceil32(32 * mem[_8580 + mem[_8580]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8580 + ceil32(return_data.size) + ceil32(32 * mem[_8580 + mem[_8580]]) + 1
                                    mem[_8580 + ceil32(return_data.size)] = _8868
                                    require return_data.size >= _8724 + (32 * _8868) + 32
                                    mem[_8580 + ceil32(return_data.size) + 32 len 32 * _8868] = mem[_8580 + _8724 + 32 len 32 * _8868]
                                    if 0 >= _8868:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8580 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8580 + ceil32(return_data.size) + 32]
                                    if 1 >= _8868:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8580 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8581 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8725 = mem[_8581]
                                        require mem[_8581] <= test266151307()
                                        require _8581 + mem[_8581] + 31 < _8581 + return_data.size
                                        _8869 = mem[_8581 + mem[_8581]]
                                        if mem[_8581 + mem[_8581]] > test266151307():
                                            revert with 0, 65
                                        if _8581 + ceil32(return_data.size) + ceil32(32 * mem[_8581 + mem[_8581]]) + 1 > test266151307() or ceil32(32 * mem[_8581 + mem[_8581]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8581 + ceil32(return_data.size) + ceil32(32 * mem[_8581 + mem[_8581]]) + 1
                                        mem[_8581 + ceil32(return_data.size)] = _8869
                                        require return_data.size >= _8725 + (32 * _8869) + 32
                                        mem[_8581 + ceil32(return_data.size) + 32 len 32 * _8869] = mem[_8581 + _8725 + 32 len 32 * _8869]
                                        if 0 >= _8869:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8581 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8581 + ceil32(return_data.size) + 32]
                                        if 1 >= _8869:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8581 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8582 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8726 = mem[_8582]
                                            require mem[_8582] <= test266151307()
                                            require _8582 + mem[_8582] + 31 < _8582 + return_data.size
                                            _8870 = mem[_8582 + mem[_8582]]
                                            if mem[_8582 + mem[_8582]] > test266151307():
                                                revert with 0, 65
                                            if _8582 + ceil32(return_data.size) + ceil32(32 * mem[_8582 + mem[_8582]]) + 1 > test266151307() or ceil32(32 * mem[_8582 + mem[_8582]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8582 + ceil32(return_data.size) + ceil32(32 * mem[_8582 + mem[_8582]]) + 1
                                            mem[_8582 + ceil32(return_data.size)] = _8870
                                            require return_data.size >= _8726 + (32 * _8870) + 32
                                            mem[_8582 + ceil32(return_data.size) + 32 len 32 * _8870] = mem[_8582 + _8726 + 32 len 32 * _8870]
                                            if 0 >= _8870:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8582 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8582 + ceil32(return_data.size) + 32]
                                            if 1 >= _8870:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8582 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8583 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8727 = mem[_8583]
                                            require mem[_8583] <= test266151307()
                                            require _8583 + mem[_8583] + 31 < _8583 + return_data.size
                                            _8871 = mem[_8583 + mem[_8583]]
                                            if mem[_8583 + mem[_8583]] > test266151307():
                                                revert with 0, 65
                                            if _8583 + ceil32(return_data.size) + ceil32(32 * mem[_8583 + mem[_8583]]) + 1 > test266151307() or ceil32(32 * mem[_8583 + mem[_8583]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8583 + ceil32(return_data.size) + ceil32(32 * mem[_8583 + mem[_8583]]) + 1
                                            mem[_8583 + ceil32(return_data.size)] = _8871
                                            require return_data.size >= _8727 + (32 * _8871) + 32
                                            mem[_8583 + ceil32(return_data.size) + 32 len 32 * _8871] = mem[_8583 + _8727 + 32 len 32 * _8871]
                                            if 0 >= _8871:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8583 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8583 + ceil32(return_data.size) + 32]
                                            if 1 >= _8871:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8583 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8584 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8728 = mem[_8584]
                                    require mem[_8584] <= test266151307()
                                    require _8584 + mem[_8584] + 31 < _8584 + return_data.size
                                    _8872 = mem[_8584 + mem[_8584]]
                                    if mem[_8584 + mem[_8584]] > test266151307():
                                        revert with 0, 65
                                    if _8584 + ceil32(return_data.size) + ceil32(32 * mem[_8584 + mem[_8584]]) + 1 > test266151307() or ceil32(32 * mem[_8584 + mem[_8584]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8584 + ceil32(return_data.size) + ceil32(32 * mem[_8584 + mem[_8584]]) + 1
                                    mem[_8584 + ceil32(return_data.size)] = _8872
                                    require return_data.size >= _8728 + (32 * _8872) + 32
                                    mem[_8584 + ceil32(return_data.size) + 32 len 32 * _8872] = mem[_8584 + _8728 + 32 len 32 * _8872]
                                    if 0 >= _8872:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8584 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8584 + ceil32(return_data.size) + 32]
                                    if 1 >= _8872:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8584 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8585 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8729 = mem[_8585]
                                    require mem[_8585] <= test266151307()
                                    require _8585 + mem[_8585] + 31 < _8585 + return_data.size
                                    _8873 = mem[_8585 + mem[_8585]]
                                    if mem[_8585 + mem[_8585]] > test266151307():
                                        revert with 0, 65
                                    if _8585 + ceil32(return_data.size) + ceil32(32 * mem[_8585 + mem[_8585]]) + 1 > test266151307() or ceil32(32 * mem[_8585 + mem[_8585]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8585 + ceil32(return_data.size) + ceil32(32 * mem[_8585 + mem[_8585]]) + 1
                                    mem[_8585 + ceil32(return_data.size)] = _8873
                                    require return_data.size >= _8729 + (32 * _8873) + 32
                                    mem[_8585 + ceil32(return_data.size) + 32 len 32 * _8873] = mem[_8585 + _8729 + 32 len 32 * _8873]
                                    if 0 >= _8873:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8585 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8585 + ceil32(return_data.size) + 32]
                                    if 1 >= _8873:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8585 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8586 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8730 = mem[_8586]
                                    require mem[_8586] <= test266151307()
                                    require _8586 + mem[_8586] + 31 < _8586 + return_data.size
                                    _8874 = mem[_8586 + mem[_8586]]
                                    if mem[_8586 + mem[_8586]] > test266151307():
                                        revert with 0, 65
                                    if _8586 + ceil32(return_data.size) + ceil32(32 * mem[_8586 + mem[_8586]]) + 1 > test266151307() or ceil32(32 * mem[_8586 + mem[_8586]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8586 + ceil32(return_data.size) + ceil32(32 * mem[_8586 + mem[_8586]]) + 1
                                    mem[_8586 + ceil32(return_data.size)] = _8874
                                    require return_data.size >= _8730 + (32 * _8874) + 32
                                    mem[_8586 + ceil32(return_data.size) + 32 len 32 * _8874] = mem[_8586 + _8730 + 32 len 32 * _8874]
                                    if 0 >= _8874:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8586 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8586 + ceil32(return_data.size) + 32]
                                    if 1 >= _8874:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8586 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8587 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8731 = mem[_8587]
                                        require mem[_8587] <= test266151307()
                                        require _8587 + mem[_8587] + 31 < _8587 + return_data.size
                                        _8875 = mem[_8587 + mem[_8587]]
                                        if mem[_8587 + mem[_8587]] > test266151307():
                                            revert with 0, 65
                                        if _8587 + ceil32(return_data.size) + ceil32(32 * mem[_8587 + mem[_8587]]) + 1 > test266151307() or ceil32(32 * mem[_8587 + mem[_8587]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8587 + ceil32(return_data.size) + ceil32(32 * mem[_8587 + mem[_8587]]) + 1
                                        mem[_8587 + ceil32(return_data.size)] = _8875
                                        require return_data.size >= _8731 + (32 * _8875) + 32
                                        mem[_8587 + ceil32(return_data.size) + 32 len 32 * _8875] = mem[_8587 + _8731 + 32 len 32 * _8875]
                                        if 0 >= _8875:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8587 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8587 + ceil32(return_data.size) + 32]
                                        if 1 >= _8875:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8587 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8588 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8732 = mem[_8588]
                                            require mem[_8588] <= test266151307()
                                            require _8588 + mem[_8588] + 31 < _8588 + return_data.size
                                            _8876 = mem[_8588 + mem[_8588]]
                                            if mem[_8588 + mem[_8588]] > test266151307():
                                                revert with 0, 65
                                            if _8588 + ceil32(return_data.size) + ceil32(32 * mem[_8588 + mem[_8588]]) + 1 > test266151307() or ceil32(32 * mem[_8588 + mem[_8588]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8588 + ceil32(return_data.size) + ceil32(32 * mem[_8588 + mem[_8588]]) + 1
                                            mem[_8588 + ceil32(return_data.size)] = _8876
                                            require return_data.size >= _8732 + (32 * _8876) + 32
                                            mem[_8588 + ceil32(return_data.size) + 32 len 32 * _8876] = mem[_8588 + _8732 + 32 len 32 * _8876]
                                            if 0 >= _8876:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8588 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8588 + ceil32(return_data.size) + 32]
                                            if 1 >= _8876:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8588 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8589 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8733 = mem[_8589]
                                            require mem[_8589] <= test266151307()
                                            require _8589 + mem[_8589] + 31 < _8589 + return_data.size
                                            _8877 = mem[_8589 + mem[_8589]]
                                            if mem[_8589 + mem[_8589]] > test266151307():
                                                revert with 0, 65
                                            if _8589 + ceil32(return_data.size) + ceil32(32 * mem[_8589 + mem[_8589]]) + 1 > test266151307() or ceil32(32 * mem[_8589 + mem[_8589]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8589 + ceil32(return_data.size) + ceil32(32 * mem[_8589 + mem[_8589]]) + 1
                                            mem[_8589 + ceil32(return_data.size)] = _8877
                                            require return_data.size >= _8733 + (32 * _8877) + 32
                                            mem[_8589 + ceil32(return_data.size) + 32 len 32 * _8877] = mem[_8589 + _8733 + 32 len 32 * _8877]
                                            if 0 >= _8877:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8589 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8589 + ceil32(return_data.size) + 32]
                                            if 1 >= _8877:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8589 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8590 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8734 = mem[_8590]
                                    require mem[_8590] <= test266151307()
                                    require _8590 + mem[_8590] + 31 < _8590 + return_data.size
                                    _8878 = mem[_8590 + mem[_8590]]
                                    if mem[_8590 + mem[_8590]] > test266151307():
                                        revert with 0, 65
                                    if _8590 + ceil32(return_data.size) + ceil32(32 * mem[_8590 + mem[_8590]]) + 1 > test266151307() or ceil32(32 * mem[_8590 + mem[_8590]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8590 + ceil32(return_data.size) + ceil32(32 * mem[_8590 + mem[_8590]]) + 1
                                    mem[_8590 + ceil32(return_data.size)] = _8878
                                    require return_data.size >= _8734 + (32 * _8878) + 32
                                    mem[_8590 + ceil32(return_data.size) + 32 len 32 * _8878] = mem[_8590 + _8734 + 32 len 32 * _8878]
                                    if 0 >= _8878:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8590 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8590 + ceil32(return_data.size) + 32]
                                    if 1 >= _8878:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8590 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8591 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8735 = mem[_8591]
                                    require mem[_8591] <= test266151307()
                                    require _8591 + mem[_8591] + 31 < _8591 + return_data.size
                                    _8879 = mem[_8591 + mem[_8591]]
                                    if mem[_8591 + mem[_8591]] > test266151307():
                                        revert with 0, 65
                                    if _8591 + ceil32(return_data.size) + ceil32(32 * mem[_8591 + mem[_8591]]) + 1 > test266151307() or ceil32(32 * mem[_8591 + mem[_8591]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8591 + ceil32(return_data.size) + ceil32(32 * mem[_8591 + mem[_8591]]) + 1
                                    mem[_8591 + ceil32(return_data.size)] = _8879
                                    require return_data.size >= _8735 + (32 * _8879) + 32
                                    mem[_8591 + ceil32(return_data.size) + 32 len 32 * _8879] = mem[_8591 + _8735 + 32 len 32 * _8879]
                                    if 0 >= _8879:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8591 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8591 + ceil32(return_data.size) + 32]
                                    if 1 >= _8879:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8591 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8592 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8736 = mem[_8592]
                                    require mem[_8592] <= test266151307()
                                    require _8592 + mem[_8592] + 31 < _8592 + return_data.size
                                    _8880 = mem[_8592 + mem[_8592]]
                                    if mem[_8592 + mem[_8592]] > test266151307():
                                        revert with 0, 65
                                    if _8592 + ceil32(return_data.size) + ceil32(32 * mem[_8592 + mem[_8592]]) + 1 > test266151307() or ceil32(32 * mem[_8592 + mem[_8592]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8592 + ceil32(return_data.size) + ceil32(32 * mem[_8592 + mem[_8592]]) + 1
                                    mem[_8592 + ceil32(return_data.size)] = _8880
                                    require return_data.size >= _8736 + (32 * _8880) + 32
                                    mem[_8592 + ceil32(return_data.size) + 32 len 32 * _8880] = mem[_8592 + _8736 + 32 len 32 * _8880]
                                    if 0 >= _8880:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8592 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8592 + ceil32(return_data.size) + 32]
                                    if 1 >= _8880:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8592 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8593 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8737 = mem[_8593]
                                        require mem[_8593] <= test266151307()
                                        require _8593 + mem[_8593] + 31 < _8593 + return_data.size
                                        _8881 = mem[_8593 + mem[_8593]]
                                        if mem[_8593 + mem[_8593]] > test266151307():
                                            revert with 0, 65
                                        if _8593 + ceil32(return_data.size) + ceil32(32 * mem[_8593 + mem[_8593]]) + 1 > test266151307() or ceil32(32 * mem[_8593 + mem[_8593]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8593 + ceil32(return_data.size) + ceil32(32 * mem[_8593 + mem[_8593]]) + 1
                                        mem[_8593 + ceil32(return_data.size)] = _8881
                                        require return_data.size >= _8737 + (32 * _8881) + 32
                                        mem[_8593 + ceil32(return_data.size) + 32 len 32 * _8881] = mem[_8593 + _8737 + 32 len 32 * _8881]
                                        if 0 >= _8881:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8593 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8593 + ceil32(return_data.size) + 32]
                                        if 1 >= _8881:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8593 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8594 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8738 = mem[_8594]
                                            require mem[_8594] <= test266151307()
                                            require _8594 + mem[_8594] + 31 < _8594 + return_data.size
                                            _8882 = mem[_8594 + mem[_8594]]
                                            if mem[_8594 + mem[_8594]] > test266151307():
                                                revert with 0, 65
                                            if _8594 + ceil32(return_data.size) + ceil32(32 * mem[_8594 + mem[_8594]]) + 1 > test266151307() or ceil32(32 * mem[_8594 + mem[_8594]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8594 + ceil32(return_data.size) + ceil32(32 * mem[_8594 + mem[_8594]]) + 1
                                            mem[_8594 + ceil32(return_data.size)] = _8882
                                            require return_data.size >= _8738 + (32 * _8882) + 32
                                            mem[_8594 + ceil32(return_data.size) + 32 len 32 * _8882] = mem[_8594 + _8738 + 32 len 32 * _8882]
                                            if 0 >= _8882:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8594 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8594 + ceil32(return_data.size) + 32]
                                            if 1 >= _8882:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8594 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8595 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8739 = mem[_8595]
                                            require mem[_8595] <= test266151307()
                                            require _8595 + mem[_8595] + 31 < _8595 + return_data.size
                                            _8883 = mem[_8595 + mem[_8595]]
                                            if mem[_8595 + mem[_8595]] > test266151307():
                                                revert with 0, 65
                                            if _8595 + ceil32(return_data.size) + ceil32(32 * mem[_8595 + mem[_8595]]) + 1 > test266151307() or ceil32(32 * mem[_8595 + mem[_8595]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8595 + ceil32(return_data.size) + ceil32(32 * mem[_8595 + mem[_8595]]) + 1
                                            mem[_8595 + ceil32(return_data.size)] = _8883
                                            require return_data.size >= _8739 + (32 * _8883) + 32
                                            mem[_8595 + ceil32(return_data.size) + 32 len 32 * _8883] = mem[_8595 + _8739 + 32 len 32 * _8883]
                                            if 0 >= _8883:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8595 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8595 + ceil32(return_data.size) + 32]
                                            if 1 >= _8883:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8595 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8596 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8740 = mem[_8596]
                                        require mem[_8596] <= test266151307()
                                        require _8596 + mem[_8596] + 31 < _8596 + return_data.size
                                        _8884 = mem[_8596 + mem[_8596]]
                                        if mem[_8596 + mem[_8596]] > test266151307():
                                            revert with 0, 65
                                        if _8596 + ceil32(return_data.size) + ceil32(32 * mem[_8596 + mem[_8596]]) + 1 > test266151307() or ceil32(32 * mem[_8596 + mem[_8596]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8596 + ceil32(return_data.size) + ceil32(32 * mem[_8596 + mem[_8596]]) + 1
                                        mem[_8596 + ceil32(return_data.size)] = _8884
                                        require return_data.size >= _8740 + (32 * _8884) + 32
                                        mem[_8596 + ceil32(return_data.size) + 32 len 32 * _8884] = mem[_8596 + _8740 + 32 len 32 * _8884]
                                        if 0 >= _8884:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8596 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8596 + ceil32(return_data.size) + 32]
                                        if 1 >= _8884:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8596 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8597 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8741 = mem[_8597]
                                        require mem[_8597] <= test266151307()
                                        require _8597 + mem[_8597] + 31 < _8597 + return_data.size
                                        _8885 = mem[_8597 + mem[_8597]]
                                        if mem[_8597 + mem[_8597]] > test266151307():
                                            revert with 0, 65
                                        if _8597 + ceil32(return_data.size) + ceil32(32 * mem[_8597 + mem[_8597]]) + 1 > test266151307() or ceil32(32 * mem[_8597 + mem[_8597]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8597 + ceil32(return_data.size) + ceil32(32 * mem[_8597 + mem[_8597]]) + 1
                                        mem[_8597 + ceil32(return_data.size)] = _8885
                                        require return_data.size >= _8741 + (32 * _8885) + 32
                                        mem[_8597 + ceil32(return_data.size) + 32 len 32 * _8885] = mem[_8597 + _8741 + 32 len 32 * _8885]
                                        if 0 >= _8885:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8597 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8597 + ceil32(return_data.size) + 32]
                                        if 1 >= _8885:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8597 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8598 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8742 = mem[_8598]
                                        require mem[_8598] <= test266151307()
                                        require _8598 + mem[_8598] + 31 < _8598 + return_data.size
                                        _8886 = mem[_8598 + mem[_8598]]
                                        if mem[_8598 + mem[_8598]] > test266151307():
                                            revert with 0, 65
                                        if _8598 + ceil32(return_data.size) + ceil32(32 * mem[_8598 + mem[_8598]]) + 1 > test266151307() or ceil32(32 * mem[_8598 + mem[_8598]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8598 + ceil32(return_data.size) + ceil32(32 * mem[_8598 + mem[_8598]]) + 1
                                        mem[_8598 + ceil32(return_data.size)] = _8886
                                        require return_data.size >= _8742 + (32 * _8886) + 32
                                        mem[_8598 + ceil32(return_data.size) + 32 len 32 * _8886] = mem[_8598 + _8742 + 32 len 32 * _8886]
                                        if 0 >= _8886:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8598 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8598 + ceil32(return_data.size) + 32]
                                        if 1 >= _8886:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8598 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8599 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8743 = mem[_8599]
                                            require mem[_8599] <= test266151307()
                                            require _8599 + mem[_8599] + 31 < _8599 + return_data.size
                                            _8887 = mem[_8599 + mem[_8599]]
                                            if mem[_8599 + mem[_8599]] > test266151307():
                                                revert with 0, 65
                                            if _8599 + ceil32(return_data.size) + ceil32(32 * mem[_8599 + mem[_8599]]) + 1 > test266151307() or ceil32(32 * mem[_8599 + mem[_8599]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8599 + ceil32(return_data.size) + ceil32(32 * mem[_8599 + mem[_8599]]) + 1
                                            mem[_8599 + ceil32(return_data.size)] = _8887
                                            require return_data.size >= _8743 + (32 * _8887) + 32
                                            mem[_8599 + ceil32(return_data.size) + 32 len 32 * _8887] = mem[_8599 + _8743 + 32 len 32 * _8887]
                                            if 0 >= _8887:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8599 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8599 + ceil32(return_data.size) + 32]
                                            if 1 >= _8887:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8599 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5752:
                                                    revert with 0, 17
                                                mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                                mem[_5756 + 132] = 0
                                                mem[_5756 + 164] = 160
                                                mem[_5756 + 260] = mem[_5756]
                                                idx = 0
                                                s = _5756 + 292
                                                t = _5756 + 32
                                                while idx < mem[_5756]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5756 + 196] = this.address
                                                mem[_5756 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8600 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8744 = mem[_8600]
                                                require mem[_8600] <= test266151307()
                                                require _8600 + mem[_8600] + 31 < _8600 + return_data.size
                                                _8888 = mem[_8600 + mem[_8600]]
                                                if mem[_8600 + mem[_8600]] > test266151307():
                                                    revert with 0, 65
                                                if _8600 + ceil32(return_data.size) + ceil32(32 * mem[_8600 + mem[_8600]]) + 1 > test266151307() or ceil32(32 * mem[_8600 + mem[_8600]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8600 + ceil32(return_data.size) + ceil32(32 * mem[_8600 + mem[_8600]]) + 1
                                                mem[_8600 + ceil32(return_data.size)] = _8888
                                                require return_data.size >= _8744 + (32 * _8888) + 32
                                                mem[_8600 + ceil32(return_data.size) + 32 len 32 * _8888] = mem[_8600 + _8744 + 32 len 32 * _8888]
                                                if 0 >= _8888:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8600 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8600 + ceil32(return_data.size) + 32]
                                                if 1 >= _8888:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8600 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5752:
                                                    revert with 0, 17
                                                mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                                mem[_5756 + 132] = 0
                                                mem[_5756 + 164] = 160
                                                mem[_5756 + 260] = mem[_5756]
                                                idx = 0
                                                s = _5756 + 292
                                                t = _5756 + 32
                                                while idx < mem[_5756]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5756 + 196] = this.address
                                                mem[_5756 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8601 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8745 = mem[_8601]
                                                require mem[_8601] <= test266151307()
                                                require _8601 + mem[_8601] + 31 < _8601 + return_data.size
                                                _8889 = mem[_8601 + mem[_8601]]
                                                if mem[_8601 + mem[_8601]] > test266151307():
                                                    revert with 0, 65
                                                if _8601 + ceil32(return_data.size) + ceil32(32 * mem[_8601 + mem[_8601]]) + 1 > test266151307() or ceil32(32 * mem[_8601 + mem[_8601]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8601 + ceil32(return_data.size) + ceil32(32 * mem[_8601 + mem[_8601]]) + 1
                                                mem[_8601 + ceil32(return_data.size)] = _8889
                                                require return_data.size >= _8745 + (32 * _8889) + 32
                                                mem[_8601 + ceil32(return_data.size) + 32 len 32 * _8889] = mem[_8601 + _8745 + 32 len 32 * _8889]
                                                if 0 >= _8889:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8601 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8601 + ceil32(return_data.size) + 32]
                                                if 1 >= _8889:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8601 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8602 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8746 = mem[_8602]
                                            require mem[_8602] <= test266151307()
                                            require _8602 + mem[_8602] + 31 < _8602 + return_data.size
                                            _8890 = mem[_8602 + mem[_8602]]
                                            if mem[_8602 + mem[_8602]] > test266151307():
                                                revert with 0, 65
                                            if _8602 + ceil32(return_data.size) + ceil32(32 * mem[_8602 + mem[_8602]]) + 1 > test266151307() or ceil32(32 * mem[_8602 + mem[_8602]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8602 + ceil32(return_data.size) + ceil32(32 * mem[_8602 + mem[_8602]]) + 1
                                            mem[_8602 + ceil32(return_data.size)] = _8890
                                            require return_data.size >= _8746 + (32 * _8890) + 32
                                            mem[_8602 + ceil32(return_data.size) + 32 len 32 * _8890] = mem[_8602 + _8746 + 32 len 32 * _8890]
                                            if 0 >= _8890:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8602 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8602 + ceil32(return_data.size) + 32]
                                            if 1 >= _8890:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8602 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8603 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8747 = mem[_8603]
                                            require mem[_8603] <= test266151307()
                                            require _8603 + mem[_8603] + 31 < _8603 + return_data.size
                                            _8891 = mem[_8603 + mem[_8603]]
                                            if mem[_8603 + mem[_8603]] > test266151307():
                                                revert with 0, 65
                                            if _8603 + ceil32(return_data.size) + ceil32(32 * mem[_8603 + mem[_8603]]) + 1 > test266151307() or ceil32(32 * mem[_8603 + mem[_8603]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8603 + ceil32(return_data.size) + ceil32(32 * mem[_8603 + mem[_8603]]) + 1
                                            mem[_8603 + ceil32(return_data.size)] = _8891
                                            require return_data.size >= _8747 + (32 * _8891) + 32
                                            mem[_8603 + ceil32(return_data.size) + 32 len 32 * _8891] = mem[_8603 + _8747 + 32 len 32 * _8891]
                                            if 0 >= _8891:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8603 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8603 + ceil32(return_data.size) + 32]
                                            if 1 >= _8891:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8603 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8604 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8748 = mem[_8604]
                                            require mem[_8604] <= test266151307()
                                            require _8604 + mem[_8604] + 31 < _8604 + return_data.size
                                            _8892 = mem[_8604 + mem[_8604]]
                                            if mem[_8604 + mem[_8604]] > test266151307():
                                                revert with 0, 65
                                            if _8604 + ceil32(return_data.size) + ceil32(32 * mem[_8604 + mem[_8604]]) + 1 > test266151307() or ceil32(32 * mem[_8604 + mem[_8604]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8604 + ceil32(return_data.size) + ceil32(32 * mem[_8604 + mem[_8604]]) + 1
                                            mem[_8604 + ceil32(return_data.size)] = _8892
                                            require return_data.size >= _8748 + (32 * _8892) + 32
                                            mem[_8604 + ceil32(return_data.size) + 32 len 32 * _8892] = mem[_8604 + _8748 + 32 len 32 * _8892]
                                            if 0 >= _8892:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8604 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8604 + ceil32(return_data.size) + 32]
                                            if 1 >= _8892:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8604 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5752:
                                                    revert with 0, 17
                                                mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                                mem[_5756 + 132] = 0
                                                mem[_5756 + 164] = 160
                                                mem[_5756 + 260] = mem[_5756]
                                                idx = 0
                                                s = _5756 + 292
                                                t = _5756 + 32
                                                while idx < mem[_5756]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5756 + 196] = this.address
                                                mem[_5756 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8605 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8749 = mem[_8605]
                                                require mem[_8605] <= test266151307()
                                                require _8605 + mem[_8605] + 31 < _8605 + return_data.size
                                                _8893 = mem[_8605 + mem[_8605]]
                                                if mem[_8605 + mem[_8605]] > test266151307():
                                                    revert with 0, 65
                                                if _8605 + ceil32(return_data.size) + ceil32(32 * mem[_8605 + mem[_8605]]) + 1 > test266151307() or ceil32(32 * mem[_8605 + mem[_8605]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8605 + ceil32(return_data.size) + ceil32(32 * mem[_8605 + mem[_8605]]) + 1
                                                mem[_8605 + ceil32(return_data.size)] = _8893
                                                require return_data.size >= _8749 + (32 * _8893) + 32
                                                mem[_8605 + ceil32(return_data.size) + 32 len 32 * _8893] = mem[_8605 + _8749 + 32 len 32 * _8893]
                                                if 0 >= _8893:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8605 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8605 + ceil32(return_data.size) + 32]
                                                if 1 >= _8893:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8605 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5752:
                                                        revert with 0, 17
                                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                                    mem[_5756 + 132] = 0
                                                    mem[_5756 + 164] = 160
                                                    mem[_5756 + 260] = mem[_5756]
                                                    idx = 0
                                                    s = _5756 + 292
                                                    t = _5756 + 32
                                                    while idx < mem[_5756]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5756 + 196] = this.address
                                                    mem[_5756 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8606 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8750 = mem[_8606]
                                                    require mem[_8606] <= test266151307()
                                                    require _8606 + mem[_8606] + 31 < _8606 + return_data.size
                                                    _8894 = mem[_8606 + mem[_8606]]
                                                    if mem[_8606 + mem[_8606]] > test266151307():
                                                        revert with 0, 65
                                                    if _8606 + ceil32(return_data.size) + ceil32(32 * mem[_8606 + mem[_8606]]) + 1 > test266151307() or ceil32(32 * mem[_8606 + mem[_8606]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8606 + ceil32(return_data.size) + ceil32(32 * mem[_8606 + mem[_8606]]) + 1
                                                    mem[_8606 + ceil32(return_data.size)] = _8894
                                                    require return_data.size >= _8750 + (32 * _8894) + 32
                                                    mem[_8606 + ceil32(return_data.size) + 32 len 32 * _8894] = mem[_8606 + _8750 + 32 len 32 * _8894]
                                                    if 0 >= _8894:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8606 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8606 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8894:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8606 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5752:
                                                        revert with 0, 17
                                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                                    mem[_5756 + 132] = 0
                                                    mem[_5756 + 164] = 160
                                                    mem[_5756 + 260] = mem[_5756]
                                                    idx = 0
                                                    s = _5756 + 292
                                                    t = _5756 + 32
                                                    while idx < mem[_5756]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5756 + 196] = this.address
                                                    mem[_5756 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8607 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8751 = mem[_8607]
                                                    require mem[_8607] <= test266151307()
                                                    require _8607 + mem[_8607] + 31 < _8607 + return_data.size
                                                    _8895 = mem[_8607 + mem[_8607]]
                                                    if mem[_8607 + mem[_8607]] > test266151307():
                                                        revert with 0, 65
                                                    if _8607 + ceil32(return_data.size) + ceil32(32 * mem[_8607 + mem[_8607]]) + 1 > test266151307() or ceil32(32 * mem[_8607 + mem[_8607]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8607 + ceil32(return_data.size) + ceil32(32 * mem[_8607 + mem[_8607]]) + 1
                                                    mem[_8607 + ceil32(return_data.size)] = _8895
                                                    require return_data.size >= _8751 + (32 * _8895) + 32
                                                    mem[_8607 + ceil32(return_data.size) + 32 len 32 * _8895] = mem[_8607 + _8751 + 32 len 32 * _8895]
                                                    if 0 >= _8895:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8607 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8607 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8895:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8607 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8608 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8752 = mem[_8608]
                                            require mem[_8608] <= test266151307()
                                            require _8608 + mem[_8608] + 31 < _8608 + return_data.size
                                            _8896 = mem[_8608 + mem[_8608]]
                                            if mem[_8608 + mem[_8608]] > test266151307():
                                                revert with 0, 65
                                            if _8608 + ceil32(return_data.size) + ceil32(32 * mem[_8608 + mem[_8608]]) + 1 > test266151307() or ceil32(32 * mem[_8608 + mem[_8608]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8608 + ceil32(return_data.size) + ceil32(32 * mem[_8608 + mem[_8608]]) + 1
                                            mem[_8608 + ceil32(return_data.size)] = _8896
                                            require return_data.size >= _8752 + (32 * _8896) + 32
                                            mem[_8608 + ceil32(return_data.size) + 32 len 32 * _8896] = mem[_8608 + _8752 + 32 len 32 * _8896]
                                            if 0 >= _8896:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8608 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8608 + ceil32(return_data.size) + 32]
                                            if 1 >= _8896:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8608 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8609 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8753 = mem[_8609]
                                            require mem[_8609] <= test266151307()
                                            require _8609 + mem[_8609] + 31 < _8609 + return_data.size
                                            _8897 = mem[_8609 + mem[_8609]]
                                            if mem[_8609 + mem[_8609]] > test266151307():
                                                revert with 0, 65
                                            if _8609 + ceil32(return_data.size) + ceil32(32 * mem[_8609 + mem[_8609]]) + 1 > test266151307() or ceil32(32 * mem[_8609 + mem[_8609]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8609 + ceil32(return_data.size) + ceil32(32 * mem[_8609 + mem[_8609]]) + 1
                                            mem[_8609 + ceil32(return_data.size)] = _8897
                                            require return_data.size >= _8753 + (32 * _8897) + 32
                                            mem[_8609 + ceil32(return_data.size) + 32 len 32 * _8897] = mem[_8609 + _8753 + 32 len 32 * _8897]
                                            if 0 >= _8897:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8609 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8609 + ceil32(return_data.size) + 32]
                                            if 1 >= _8897:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8609 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8610 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8754 = mem[_8610]
                                            require mem[_8610] <= test266151307()
                                            require _8610 + mem[_8610] + 31 < _8610 + return_data.size
                                            _8898 = mem[_8610 + mem[_8610]]
                                            if mem[_8610 + mem[_8610]] > test266151307():
                                                revert with 0, 65
                                            if _8610 + ceil32(return_data.size) + ceil32(32 * mem[_8610 + mem[_8610]]) + 1 > test266151307() or ceil32(32 * mem[_8610 + mem[_8610]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8610 + ceil32(return_data.size) + ceil32(32 * mem[_8610 + mem[_8610]]) + 1
                                            mem[_8610 + ceil32(return_data.size)] = _8898
                                            require return_data.size >= _8754 + (32 * _8898) + 32
                                            mem[_8610 + ceil32(return_data.size) + 32 len 32 * _8898] = mem[_8610 + _8754 + 32 len 32 * _8898]
                                            if 0 >= _8898:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8610 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8610 + ceil32(return_data.size) + 32]
                                            if 1 >= _8898:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8610 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5752:
                                                    revert with 0, 17
                                                mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                                mem[_5756 + 132] = 0
                                                mem[_5756 + 164] = 160
                                                mem[_5756 + 260] = mem[_5756]
                                                idx = 0
                                                s = _5756 + 292
                                                t = _5756 + 32
                                                while idx < mem[_5756]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5756 + 196] = this.address
                                                mem[_5756 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8611 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8755 = mem[_8611]
                                                require mem[_8611] <= test266151307()
                                                require _8611 + mem[_8611] + 31 < _8611 + return_data.size
                                                _8899 = mem[_8611 + mem[_8611]]
                                                if mem[_8611 + mem[_8611]] > test266151307():
                                                    revert with 0, 65
                                                if _8611 + ceil32(return_data.size) + ceil32(32 * mem[_8611 + mem[_8611]]) + 1 > test266151307() or ceil32(32 * mem[_8611 + mem[_8611]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8611 + ceil32(return_data.size) + ceil32(32 * mem[_8611 + mem[_8611]]) + 1
                                                mem[_8611 + ceil32(return_data.size)] = _8899
                                                require return_data.size >= _8755 + (32 * _8899) + 32
                                                mem[_8611 + ceil32(return_data.size) + 32 len 32 * _8899] = mem[_8611 + _8755 + 32 len 32 * _8899]
                                                if 0 >= _8899:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8611 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8611 + ceil32(return_data.size) + 32]
                                                if 1 >= _8899:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8611 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5752:
                                                        revert with 0, 17
                                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                                    mem[_5756 + 132] = 0
                                                    mem[_5756 + 164] = 160
                                                    mem[_5756 + 260] = mem[_5756]
                                                    idx = 0
                                                    s = _5756 + 292
                                                    t = _5756 + 32
                                                    while idx < mem[_5756]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5756 + 196] = this.address
                                                    mem[_5756 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8612 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8756 = mem[_8612]
                                                    require mem[_8612] <= test266151307()
                                                    require _8612 + mem[_8612] + 31 < _8612 + return_data.size
                                                    _8900 = mem[_8612 + mem[_8612]]
                                                    if mem[_8612 + mem[_8612]] > test266151307():
                                                        revert with 0, 65
                                                    if _8612 + ceil32(return_data.size) + ceil32(32 * mem[_8612 + mem[_8612]]) + 1 > test266151307() or ceil32(32 * mem[_8612 + mem[_8612]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8612 + ceil32(return_data.size) + ceil32(32 * mem[_8612 + mem[_8612]]) + 1
                                                    mem[_8612 + ceil32(return_data.size)] = _8900
                                                    require return_data.size >= _8756 + (32 * _8900) + 32
                                                    mem[_8612 + ceil32(return_data.size) + 32 len 32 * _8900] = mem[_8612 + _8756 + 32 len 32 * _8900]
                                                    if 0 >= _8900:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8612 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8612 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8900:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8612 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5752:
                                                        revert with 0, 17
                                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                                    mem[_5756 + 132] = 0
                                                    mem[_5756 + 164] = 160
                                                    mem[_5756 + 260] = mem[_5756]
                                                    idx = 0
                                                    s = _5756 + 292
                                                    t = _5756 + 32
                                                    while idx < mem[_5756]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5756 + 196] = this.address
                                                    mem[_5756 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8613 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8757 = mem[_8613]
                                                    require mem[_8613] <= test266151307()
                                                    require _8613 + mem[_8613] + 31 < _8613 + return_data.size
                                                    _8901 = mem[_8613 + mem[_8613]]
                                                    if mem[_8613 + mem[_8613]] > test266151307():
                                                        revert with 0, 65
                                                    if _8613 + ceil32(return_data.size) + ceil32(32 * mem[_8613 + mem[_8613]]) + 1 > test266151307() or ceil32(32 * mem[_8613 + mem[_8613]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8613 + ceil32(return_data.size) + ceil32(32 * mem[_8613 + mem[_8613]]) + 1
                                                    mem[_8613 + ceil32(return_data.size)] = _8901
                                                    require return_data.size >= _8757 + (32 * _8901) + 32
                                                    mem[_8613 + ceil32(return_data.size) + 32 len 32 * _8901] = mem[_8613 + _8757 + 32 len 32 * _8901]
                                                    if 0 >= _8901:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8613 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8613 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8901:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8613 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2987 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3018 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3018
                    require return_data.size >= _2987 + (32 * _3018) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3018] = mem[(4 * ceil32(return_data.size)) + _2987 + 224 len 32 * _3018]
                    if 1 >= _3018:
                        revert with 0, 50
                    _5753 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5757 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5757]:
                        revert with 0, 50
                    mem[_5757 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5757]:
                        revert with 0, 50
                    mem[_5757 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8614 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8758 = mem[_8614]
                                    require mem[_8614] <= test266151307()
                                    require _8614 + mem[_8614] + 31 < _8614 + return_data.size
                                    _8902 = mem[_8614 + mem[_8614]]
                                    if mem[_8614 + mem[_8614]] > test266151307():
                                        revert with 0, 65
                                    if _8614 + ceil32(return_data.size) + ceil32(32 * mem[_8614 + mem[_8614]]) + 1 > test266151307() or ceil32(32 * mem[_8614 + mem[_8614]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8614 + ceil32(return_data.size) + ceil32(32 * mem[_8614 + mem[_8614]]) + 1
                                    mem[_8614 + ceil32(return_data.size)] = _8902
                                    require return_data.size >= _8758 + (32 * _8902) + 32
                                    mem[_8614 + ceil32(return_data.size) + 32 len 32 * _8902] = mem[_8614 + _8758 + 32 len 32 * _8902]
                                    if 0 >= _8902:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8614 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8614 + ceil32(return_data.size) + 32]
                                    if 1 >= _8902:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8614 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8615 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8759 = mem[_8615]
                                    require mem[_8615] <= test266151307()
                                    require _8615 + mem[_8615] + 31 < _8615 + return_data.size
                                    _8903 = mem[_8615 + mem[_8615]]
                                    if mem[_8615 + mem[_8615]] > test266151307():
                                        revert with 0, 65
                                    if _8615 + ceil32(return_data.size) + ceil32(32 * mem[_8615 + mem[_8615]]) + 1 > test266151307() or ceil32(32 * mem[_8615 + mem[_8615]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8615 + ceil32(return_data.size) + ceil32(32 * mem[_8615 + mem[_8615]]) + 1
                                    mem[_8615 + ceil32(return_data.size)] = _8903
                                    require return_data.size >= _8759 + (32 * _8903) + 32
                                    mem[_8615 + ceil32(return_data.size) + 32 len 32 * _8903] = mem[_8615 + _8759 + 32 len 32 * _8903]
                                    if 0 >= _8903:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8615 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8615 + ceil32(return_data.size) + 32]
                                    if 1 >= _8903:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8615 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8616 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8760 = mem[_8616]
                                    require mem[_8616] <= test266151307()
                                    require _8616 + mem[_8616] + 31 < _8616 + return_data.size
                                    _8904 = mem[_8616 + mem[_8616]]
                                    if mem[_8616 + mem[_8616]] > test266151307():
                                        revert with 0, 65
                                    if _8616 + ceil32(return_data.size) + ceil32(32 * mem[_8616 + mem[_8616]]) + 1 > test266151307() or ceil32(32 * mem[_8616 + mem[_8616]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8616 + ceil32(return_data.size) + ceil32(32 * mem[_8616 + mem[_8616]]) + 1
                                    mem[_8616 + ceil32(return_data.size)] = _8904
                                    require return_data.size >= _8760 + (32 * _8904) + 32
                                    mem[_8616 + ceil32(return_data.size) + 32 len 32 * _8904] = mem[_8616 + _8760 + 32 len 32 * _8904]
                                    if 0 >= _8904:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8616 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8616 + ceil32(return_data.size) + 32]
                                    if 1 >= _8904:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8616 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8617 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8761 = mem[_8617]
                                        require mem[_8617] <= test266151307()
                                        require _8617 + mem[_8617] + 31 < _8617 + return_data.size
                                        _8905 = mem[_8617 + mem[_8617]]
                                        if mem[_8617 + mem[_8617]] > test266151307():
                                            revert with 0, 65
                                        if _8617 + ceil32(return_data.size) + ceil32(32 * mem[_8617 + mem[_8617]]) + 1 > test266151307() or ceil32(32 * mem[_8617 + mem[_8617]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8617 + ceil32(return_data.size) + ceil32(32 * mem[_8617 + mem[_8617]]) + 1
                                        mem[_8617 + ceil32(return_data.size)] = _8905
                                        require return_data.size >= _8761 + (32 * _8905) + 32
                                        mem[_8617 + ceil32(return_data.size) + 32 len 32 * _8905] = mem[_8617 + _8761 + 32 len 32 * _8905]
                                        if 0 >= _8905:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8617 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8617 + ceil32(return_data.size) + 32]
                                        if 1 >= _8905:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8617 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8618 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8762 = mem[_8618]
                                            require mem[_8618] <= test266151307()
                                            require _8618 + mem[_8618] + 31 < _8618 + return_data.size
                                            _8906 = mem[_8618 + mem[_8618]]
                                            if mem[_8618 + mem[_8618]] > test266151307():
                                                revert with 0, 65
                                            if _8618 + ceil32(return_data.size) + ceil32(32 * mem[_8618 + mem[_8618]]) + 1 > test266151307() or ceil32(32 * mem[_8618 + mem[_8618]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8618 + ceil32(return_data.size) + ceil32(32 * mem[_8618 + mem[_8618]]) + 1
                                            mem[_8618 + ceil32(return_data.size)] = _8906
                                            require return_data.size >= _8762 + (32 * _8906) + 32
                                            mem[_8618 + ceil32(return_data.size) + 32 len 32 * _8906] = mem[_8618 + _8762 + 32 len 32 * _8906]
                                            if 0 >= _8906:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8618 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8618 + ceil32(return_data.size) + 32]
                                            if 1 >= _8906:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8618 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8619 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8763 = mem[_8619]
                                            require mem[_8619] <= test266151307()
                                            require _8619 + mem[_8619] + 31 < _8619 + return_data.size
                                            _8907 = mem[_8619 + mem[_8619]]
                                            if mem[_8619 + mem[_8619]] > test266151307():
                                                revert with 0, 65
                                            if _8619 + ceil32(return_data.size) + ceil32(32 * mem[_8619 + mem[_8619]]) + 1 > test266151307() or ceil32(32 * mem[_8619 + mem[_8619]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8619 + ceil32(return_data.size) + ceil32(32 * mem[_8619 + mem[_8619]]) + 1
                                            mem[_8619 + ceil32(return_data.size)] = _8907
                                            require return_data.size >= _8763 + (32 * _8907) + 32
                                            mem[_8619 + ceil32(return_data.size) + 32 len 32 * _8907] = mem[_8619 + _8763 + 32 len 32 * _8907]
                                            if 0 >= _8907:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8619 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8619 + ceil32(return_data.size) + 32]
                                            if 1 >= _8907:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8619 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8620 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8764 = mem[_8620]
                                    require mem[_8620] <= test266151307()
                                    require _8620 + mem[_8620] + 31 < _8620 + return_data.size
                                    _8908 = mem[_8620 + mem[_8620]]
                                    if mem[_8620 + mem[_8620]] > test266151307():
                                        revert with 0, 65
                                    if _8620 + ceil32(return_data.size) + ceil32(32 * mem[_8620 + mem[_8620]]) + 1 > test266151307() or ceil32(32 * mem[_8620 + mem[_8620]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8620 + ceil32(return_data.size) + ceil32(32 * mem[_8620 + mem[_8620]]) + 1
                                    mem[_8620 + ceil32(return_data.size)] = _8908
                                    require return_data.size >= _8764 + (32 * _8908) + 32
                                    mem[_8620 + ceil32(return_data.size) + 32 len 32 * _8908] = mem[_8620 + _8764 + 32 len 32 * _8908]
                                    if 0 >= _8908:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8620 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8620 + ceil32(return_data.size) + 32]
                                    if 1 >= _8908:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8620 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8621 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8765 = mem[_8621]
                                    require mem[_8621] <= test266151307()
                                    require _8621 + mem[_8621] + 31 < _8621 + return_data.size
                                    _8909 = mem[_8621 + mem[_8621]]
                                    if mem[_8621 + mem[_8621]] > test266151307():
                                        revert with 0, 65
                                    if _8621 + ceil32(return_data.size) + ceil32(32 * mem[_8621 + mem[_8621]]) + 1 > test266151307() or ceil32(32 * mem[_8621 + mem[_8621]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8621 + ceil32(return_data.size) + ceil32(32 * mem[_8621 + mem[_8621]]) + 1
                                    mem[_8621 + ceil32(return_data.size)] = _8909
                                    require return_data.size >= _8765 + (32 * _8909) + 32
                                    mem[_8621 + ceil32(return_data.size) + 32 len 32 * _8909] = mem[_8621 + _8765 + 32 len 32 * _8909]
                                    if 0 >= _8909:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8621 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8621 + ceil32(return_data.size) + 32]
                                    if 1 >= _8909:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8621 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8622 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8766 = mem[_8622]
                                    require mem[_8622] <= test266151307()
                                    require _8622 + mem[_8622] + 31 < _8622 + return_data.size
                                    _8910 = mem[_8622 + mem[_8622]]
                                    if mem[_8622 + mem[_8622]] > test266151307():
                                        revert with 0, 65
                                    if _8622 + ceil32(return_data.size) + ceil32(32 * mem[_8622 + mem[_8622]]) + 1 > test266151307() or ceil32(32 * mem[_8622 + mem[_8622]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8622 + ceil32(return_data.size) + ceil32(32 * mem[_8622 + mem[_8622]]) + 1
                                    mem[_8622 + ceil32(return_data.size)] = _8910
                                    require return_data.size >= _8766 + (32 * _8910) + 32
                                    mem[_8622 + ceil32(return_data.size) + 32 len 32 * _8910] = mem[_8622 + _8766 + 32 len 32 * _8910]
                                    if 0 >= _8910:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8622 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8622 + ceil32(return_data.size) + 32]
                                    if 1 >= _8910:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8622 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8623 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8767 = mem[_8623]
                                        require mem[_8623] <= test266151307()
                                        require _8623 + mem[_8623] + 31 < _8623 + return_data.size
                                        _8911 = mem[_8623 + mem[_8623]]
                                        if mem[_8623 + mem[_8623]] > test266151307():
                                            revert with 0, 65
                                        if _8623 + ceil32(return_data.size) + ceil32(32 * mem[_8623 + mem[_8623]]) + 1 > test266151307() or ceil32(32 * mem[_8623 + mem[_8623]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8623 + ceil32(return_data.size) + ceil32(32 * mem[_8623 + mem[_8623]]) + 1
                                        mem[_8623 + ceil32(return_data.size)] = _8911
                                        require return_data.size >= _8767 + (32 * _8911) + 32
                                        mem[_8623 + ceil32(return_data.size) + 32 len 32 * _8911] = mem[_8623 + _8767 + 32 len 32 * _8911]
                                        if 0 >= _8911:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8623 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8623 + ceil32(return_data.size) + 32]
                                        if 1 >= _8911:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8623 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8624 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8768 = mem[_8624]
                                            require mem[_8624] <= test266151307()
                                            require _8624 + mem[_8624] + 31 < _8624 + return_data.size
                                            _8912 = mem[_8624 + mem[_8624]]
                                            if mem[_8624 + mem[_8624]] > test266151307():
                                                revert with 0, 65
                                            if _8624 + ceil32(return_data.size) + ceil32(32 * mem[_8624 + mem[_8624]]) + 1 > test266151307() or ceil32(32 * mem[_8624 + mem[_8624]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8624 + ceil32(return_data.size) + ceil32(32 * mem[_8624 + mem[_8624]]) + 1
                                            mem[_8624 + ceil32(return_data.size)] = _8912
                                            require return_data.size >= _8768 + (32 * _8912) + 32
                                            mem[_8624 + ceil32(return_data.size) + 32 len 32 * _8912] = mem[_8624 + _8768 + 32 len 32 * _8912]
                                            if 0 >= _8912:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8624 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8624 + ceil32(return_data.size) + 32]
                                            if 1 >= _8912:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8624 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8625 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8769 = mem[_8625]
                                            require mem[_8625] <= test266151307()
                                            require _8625 + mem[_8625] + 31 < _8625 + return_data.size
                                            _8913 = mem[_8625 + mem[_8625]]
                                            if mem[_8625 + mem[_8625]] > test266151307():
                                                revert with 0, 65
                                            if _8625 + ceil32(return_data.size) + ceil32(32 * mem[_8625 + mem[_8625]]) + 1 > test266151307() or ceil32(32 * mem[_8625 + mem[_8625]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8625 + ceil32(return_data.size) + ceil32(32 * mem[_8625 + mem[_8625]]) + 1
                                            mem[_8625 + ceil32(return_data.size)] = _8913
                                            require return_data.size >= _8769 + (32 * _8913) + 32
                                            mem[_8625 + ceil32(return_data.size) + 32 len 32 * _8913] = mem[_8625 + _8769 + 32 len 32 * _8913]
                                            if 0 >= _8913:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8625 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8625 + ceil32(return_data.size) + 32]
                                            if 1 >= _8913:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8625 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8626 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8770 = mem[_8626]
                                    require mem[_8626] <= test266151307()
                                    require _8626 + mem[_8626] + 31 < _8626 + return_data.size
                                    _8914 = mem[_8626 + mem[_8626]]
                                    if mem[_8626 + mem[_8626]] > test266151307():
                                        revert with 0, 65
                                    if _8626 + ceil32(return_data.size) + ceil32(32 * mem[_8626 + mem[_8626]]) + 1 > test266151307() or ceil32(32 * mem[_8626 + mem[_8626]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8626 + ceil32(return_data.size) + ceil32(32 * mem[_8626 + mem[_8626]]) + 1
                                    mem[_8626 + ceil32(return_data.size)] = _8914
                                    require return_data.size >= _8770 + (32 * _8914) + 32
                                    mem[_8626 + ceil32(return_data.size) + 32 len 32 * _8914] = mem[_8626 + _8770 + 32 len 32 * _8914]
                                    if 0 >= _8914:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8626 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8626 + ceil32(return_data.size) + 32]
                                    if 1 >= _8914:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8626 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8627 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8771 = mem[_8627]
                                    require mem[_8627] <= test266151307()
                                    require _8627 + mem[_8627] + 31 < _8627 + return_data.size
                                    _8915 = mem[_8627 + mem[_8627]]
                                    if mem[_8627 + mem[_8627]] > test266151307():
                                        revert with 0, 65
                                    if _8627 + ceil32(return_data.size) + ceil32(32 * mem[_8627 + mem[_8627]]) + 1 > test266151307() or ceil32(32 * mem[_8627 + mem[_8627]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8627 + ceil32(return_data.size) + ceil32(32 * mem[_8627 + mem[_8627]]) + 1
                                    mem[_8627 + ceil32(return_data.size)] = _8915
                                    require return_data.size >= _8771 + (32 * _8915) + 32
                                    mem[_8627 + ceil32(return_data.size) + 32 len 32 * _8915] = mem[_8627 + _8771 + 32 len 32 * _8915]
                                    if 0 >= _8915:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8627 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8627 + ceil32(return_data.size) + 32]
                                    if 1 >= _8915:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8627 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8628 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8772 = mem[_8628]
                                    require mem[_8628] <= test266151307()
                                    require _8628 + mem[_8628] + 31 < _8628 + return_data.size
                                    _8916 = mem[_8628 + mem[_8628]]
                                    if mem[_8628 + mem[_8628]] > test266151307():
                                        revert with 0, 65
                                    if _8628 + ceil32(return_data.size) + ceil32(32 * mem[_8628 + mem[_8628]]) + 1 > test266151307() or ceil32(32 * mem[_8628 + mem[_8628]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8628 + ceil32(return_data.size) + ceil32(32 * mem[_8628 + mem[_8628]]) + 1
                                    mem[_8628 + ceil32(return_data.size)] = _8916
                                    require return_data.size >= _8772 + (32 * _8916) + 32
                                    mem[_8628 + ceil32(return_data.size) + 32 len 32 * _8916] = mem[_8628 + _8772 + 32 len 32 * _8916]
                                    if 0 >= _8916:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8628 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8628 + ceil32(return_data.size) + 32]
                                    if 1 >= _8916:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8628 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8629 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8773 = mem[_8629]
                                        require mem[_8629] <= test266151307()
                                        require _8629 + mem[_8629] + 31 < _8629 + return_data.size
                                        _8917 = mem[_8629 + mem[_8629]]
                                        if mem[_8629 + mem[_8629]] > test266151307():
                                            revert with 0, 65
                                        if _8629 + ceil32(return_data.size) + ceil32(32 * mem[_8629 + mem[_8629]]) + 1 > test266151307() or ceil32(32 * mem[_8629 + mem[_8629]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8629 + ceil32(return_data.size) + ceil32(32 * mem[_8629 + mem[_8629]]) + 1
                                        mem[_8629 + ceil32(return_data.size)] = _8917
                                        require return_data.size >= _8773 + (32 * _8917) + 32
                                        mem[_8629 + ceil32(return_data.size) + 32 len 32 * _8917] = mem[_8629 + _8773 + 32 len 32 * _8917]
                                        if 0 >= _8917:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8629 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8629 + ceil32(return_data.size) + 32]
                                        if 1 >= _8917:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8629 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8630 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8774 = mem[_8630]
                                            require mem[_8630] <= test266151307()
                                            require _8630 + mem[_8630] + 31 < _8630 + return_data.size
                                            _8918 = mem[_8630 + mem[_8630]]
                                            if mem[_8630 + mem[_8630]] > test266151307():
                                                revert with 0, 65
                                            if _8630 + ceil32(return_data.size) + ceil32(32 * mem[_8630 + mem[_8630]]) + 1 > test266151307() or ceil32(32 * mem[_8630 + mem[_8630]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8630 + ceil32(return_data.size) + ceil32(32 * mem[_8630 + mem[_8630]]) + 1
                                            mem[_8630 + ceil32(return_data.size)] = _8918
                                            require return_data.size >= _8774 + (32 * _8918) + 32
                                            mem[_8630 + ceil32(return_data.size) + 32 len 32 * _8918] = mem[_8630 + _8774 + 32 len 32 * _8918]
                                            if 0 >= _8918:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8630 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8630 + ceil32(return_data.size) + 32]
                                            if 1 >= _8918:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8630 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8631 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8775 = mem[_8631]
                                            require mem[_8631] <= test266151307()
                                            require _8631 + mem[_8631] + 31 < _8631 + return_data.size
                                            _8919 = mem[_8631 + mem[_8631]]
                                            if mem[_8631 + mem[_8631]] > test266151307():
                                                revert with 0, 65
                                            if _8631 + ceil32(return_data.size) + ceil32(32 * mem[_8631 + mem[_8631]]) + 1 > test266151307() or ceil32(32 * mem[_8631 + mem[_8631]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8631 + ceil32(return_data.size) + ceil32(32 * mem[_8631 + mem[_8631]]) + 1
                                            mem[_8631 + ceil32(return_data.size)] = _8919
                                            require return_data.size >= _8775 + (32 * _8919) + 32
                                            mem[_8631 + ceil32(return_data.size) + 32 len 32 * _8919] = mem[_8631 + _8775 + 32 len 32 * _8919]
                                            if 0 >= _8919:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8631 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8631 + ceil32(return_data.size) + 32]
                                            if 1 >= _8919:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8631 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8632 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8776 = mem[_8632]
                                        require mem[_8632] <= test266151307()
                                        require _8632 + mem[_8632] + 31 < _8632 + return_data.size
                                        _8920 = mem[_8632 + mem[_8632]]
                                        if mem[_8632 + mem[_8632]] > test266151307():
                                            revert with 0, 65
                                        if _8632 + ceil32(return_data.size) + ceil32(32 * mem[_8632 + mem[_8632]]) + 1 > test266151307() or ceil32(32 * mem[_8632 + mem[_8632]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8632 + ceil32(return_data.size) + ceil32(32 * mem[_8632 + mem[_8632]]) + 1
                                        mem[_8632 + ceil32(return_data.size)] = _8920
                                        require return_data.size >= _8776 + (32 * _8920) + 32
                                        mem[_8632 + ceil32(return_data.size) + 32 len 32 * _8920] = mem[_8632 + _8776 + 32 len 32 * _8920]
                                        if 0 >= _8920:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8632 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8632 + ceil32(return_data.size) + 32]
                                        if 1 >= _8920:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8632 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8633 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8777 = mem[_8633]
                                        require mem[_8633] <= test266151307()
                                        require _8633 + mem[_8633] + 31 < _8633 + return_data.size
                                        _8921 = mem[_8633 + mem[_8633]]
                                        if mem[_8633 + mem[_8633]] > test266151307():
                                            revert with 0, 65
                                        if _8633 + ceil32(return_data.size) + ceil32(32 * mem[_8633 + mem[_8633]]) + 1 > test266151307() or ceil32(32 * mem[_8633 + mem[_8633]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8633 + ceil32(return_data.size) + ceil32(32 * mem[_8633 + mem[_8633]]) + 1
                                        mem[_8633 + ceil32(return_data.size)] = _8921
                                        require return_data.size >= _8777 + (32 * _8921) + 32
                                        mem[_8633 + ceil32(return_data.size) + 32 len 32 * _8921] = mem[_8633 + _8777 + 32 len 32 * _8921]
                                        if 0 >= _8921:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8633 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8633 + ceil32(return_data.size) + 32]
                                        if 1 >= _8921:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8633 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8634 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8778 = mem[_8634]
                                        require mem[_8634] <= test266151307()
                                        require _8634 + mem[_8634] + 31 < _8634 + return_data.size
                                        _8922 = mem[_8634 + mem[_8634]]
                                        if mem[_8634 + mem[_8634]] > test266151307():
                                            revert with 0, 65
                                        if _8634 + ceil32(return_data.size) + ceil32(32 * mem[_8634 + mem[_8634]]) + 1 > test266151307() or ceil32(32 * mem[_8634 + mem[_8634]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8634 + ceil32(return_data.size) + ceil32(32 * mem[_8634 + mem[_8634]]) + 1
                                        mem[_8634 + ceil32(return_data.size)] = _8922
                                        require return_data.size >= _8778 + (32 * _8922) + 32
                                        mem[_8634 + ceil32(return_data.size) + 32 len 32 * _8922] = mem[_8634 + _8778 + 32 len 32 * _8922]
                                        if 0 >= _8922:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8634 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8634 + ceil32(return_data.size) + 32]
                                        if 1 >= _8922:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8634 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8635 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8779 = mem[_8635]
                                            require mem[_8635] <= test266151307()
                                            require _8635 + mem[_8635] + 31 < _8635 + return_data.size
                                            _8923 = mem[_8635 + mem[_8635]]
                                            if mem[_8635 + mem[_8635]] > test266151307():
                                                revert with 0, 65
                                            if _8635 + ceil32(return_data.size) + ceil32(32 * mem[_8635 + mem[_8635]]) + 1 > test266151307() or ceil32(32 * mem[_8635 + mem[_8635]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8635 + ceil32(return_data.size) + ceil32(32 * mem[_8635 + mem[_8635]]) + 1
                                            mem[_8635 + ceil32(return_data.size)] = _8923
                                            require return_data.size >= _8779 + (32 * _8923) + 32
                                            mem[_8635 + ceil32(return_data.size) + 32 len 32 * _8923] = mem[_8635 + _8779 + 32 len 32 * _8923]
                                            if 0 >= _8923:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8635 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8635 + ceil32(return_data.size) + 32]
                                            if 1 >= _8923:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8635 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5753:
                                                    revert with 0, 17
                                                mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                                mem[_5757 + 132] = 0
                                                mem[_5757 + 164] = 160
                                                mem[_5757 + 260] = mem[_5757]
                                                idx = 0
                                                s = _5757 + 292
                                                t = _5757 + 32
                                                while idx < mem[_5757]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5757 + 196] = this.address
                                                mem[_5757 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8636 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8780 = mem[_8636]
                                                require mem[_8636] <= test266151307()
                                                require _8636 + mem[_8636] + 31 < _8636 + return_data.size
                                                _8924 = mem[_8636 + mem[_8636]]
                                                if mem[_8636 + mem[_8636]] > test266151307():
                                                    revert with 0, 65
                                                if _8636 + ceil32(return_data.size) + ceil32(32 * mem[_8636 + mem[_8636]]) + 1 > test266151307() or ceil32(32 * mem[_8636 + mem[_8636]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8636 + ceil32(return_data.size) + ceil32(32 * mem[_8636 + mem[_8636]]) + 1
                                                mem[_8636 + ceil32(return_data.size)] = _8924
                                                require return_data.size >= _8780 + (32 * _8924) + 32
                                                mem[_8636 + ceil32(return_data.size) + 32 len 32 * _8924] = mem[_8636 + _8780 + 32 len 32 * _8924]
                                                if 0 >= _8924:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8636 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8636 + ceil32(return_data.size) + 32]
                                                if 1 >= _8924:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8636 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5753:
                                                    revert with 0, 17
                                                mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                                mem[_5757 + 132] = 0
                                                mem[_5757 + 164] = 160
                                                mem[_5757 + 260] = mem[_5757]
                                                idx = 0
                                                s = _5757 + 292
                                                t = _5757 + 32
                                                while idx < mem[_5757]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5757 + 196] = this.address
                                                mem[_5757 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8637 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8781 = mem[_8637]
                                                require mem[_8637] <= test266151307()
                                                require _8637 + mem[_8637] + 31 < _8637 + return_data.size
                                                _8925 = mem[_8637 + mem[_8637]]
                                                if mem[_8637 + mem[_8637]] > test266151307():
                                                    revert with 0, 65
                                                if _8637 + ceil32(return_data.size) + ceil32(32 * mem[_8637 + mem[_8637]]) + 1 > test266151307() or ceil32(32 * mem[_8637 + mem[_8637]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8637 + ceil32(return_data.size) + ceil32(32 * mem[_8637 + mem[_8637]]) + 1
                                                mem[_8637 + ceil32(return_data.size)] = _8925
                                                require return_data.size >= _8781 + (32 * _8925) + 32
                                                mem[_8637 + ceil32(return_data.size) + 32 len 32 * _8925] = mem[_8637 + _8781 + 32 len 32 * _8925]
                                                if 0 >= _8925:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8637 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8637 + ceil32(return_data.size) + 32]
                                                if 1 >= _8925:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8637 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8638 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8782 = mem[_8638]
                                            require mem[_8638] <= test266151307()
                                            require _8638 + mem[_8638] + 31 < _8638 + return_data.size
                                            _8926 = mem[_8638 + mem[_8638]]
                                            if mem[_8638 + mem[_8638]] > test266151307():
                                                revert with 0, 65
                                            if _8638 + ceil32(return_data.size) + ceil32(32 * mem[_8638 + mem[_8638]]) + 1 > test266151307() or ceil32(32 * mem[_8638 + mem[_8638]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8638 + ceil32(return_data.size) + ceil32(32 * mem[_8638 + mem[_8638]]) + 1
                                            mem[_8638 + ceil32(return_data.size)] = _8926
                                            require return_data.size >= _8782 + (32 * _8926) + 32
                                            mem[_8638 + ceil32(return_data.size) + 32 len 32 * _8926] = mem[_8638 + _8782 + 32 len 32 * _8926]
                                            if 0 >= _8926:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8638 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8638 + ceil32(return_data.size) + 32]
                                            if 1 >= _8926:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8638 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8639 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8783 = mem[_8639]
                                            require mem[_8639] <= test266151307()
                                            require _8639 + mem[_8639] + 31 < _8639 + return_data.size
                                            _8927 = mem[_8639 + mem[_8639]]
                                            if mem[_8639 + mem[_8639]] > test266151307():
                                                revert with 0, 65
                                            if _8639 + ceil32(return_data.size) + ceil32(32 * mem[_8639 + mem[_8639]]) + 1 > test266151307() or ceil32(32 * mem[_8639 + mem[_8639]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8639 + ceil32(return_data.size) + ceil32(32 * mem[_8639 + mem[_8639]]) + 1
                                            mem[_8639 + ceil32(return_data.size)] = _8927
                                            require return_data.size >= _8783 + (32 * _8927) + 32
                                            mem[_8639 + ceil32(return_data.size) + 32 len 32 * _8927] = mem[_8639 + _8783 + 32 len 32 * _8927]
                                            if 0 >= _8927:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8639 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8639 + ceil32(return_data.size) + 32]
                                            if 1 >= _8927:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8639 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8640 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8784 = mem[_8640]
                                            require mem[_8640] <= test266151307()
                                            require _8640 + mem[_8640] + 31 < _8640 + return_data.size
                                            _8928 = mem[_8640 + mem[_8640]]
                                            if mem[_8640 + mem[_8640]] > test266151307():
                                                revert with 0, 65
                                            if _8640 + ceil32(return_data.size) + ceil32(32 * mem[_8640 + mem[_8640]]) + 1 > test266151307() or ceil32(32 * mem[_8640 + mem[_8640]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8640 + ceil32(return_data.size) + ceil32(32 * mem[_8640 + mem[_8640]]) + 1
                                            mem[_8640 + ceil32(return_data.size)] = _8928
                                            require return_data.size >= _8784 + (32 * _8928) + 32
                                            mem[_8640 + ceil32(return_data.size) + 32 len 32 * _8928] = mem[_8640 + _8784 + 32 len 32 * _8928]
                                            if 0 >= _8928:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8640 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8640 + ceil32(return_data.size) + 32]
                                            if 1 >= _8928:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8640 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5753:
                                                    revert with 0, 17
                                                mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                                mem[_5757 + 132] = 0
                                                mem[_5757 + 164] = 160
                                                mem[_5757 + 260] = mem[_5757]
                                                idx = 0
                                                s = _5757 + 292
                                                t = _5757 + 32
                                                while idx < mem[_5757]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5757 + 196] = this.address
                                                mem[_5757 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8641 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8785 = mem[_8641]
                                                require mem[_8641] <= test266151307()
                                                require _8641 + mem[_8641] + 31 < _8641 + return_data.size
                                                _8929 = mem[_8641 + mem[_8641]]
                                                if mem[_8641 + mem[_8641]] > test266151307():
                                                    revert with 0, 65
                                                if _8641 + ceil32(return_data.size) + ceil32(32 * mem[_8641 + mem[_8641]]) + 1 > test266151307() or ceil32(32 * mem[_8641 + mem[_8641]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8641 + ceil32(return_data.size) + ceil32(32 * mem[_8641 + mem[_8641]]) + 1
                                                mem[_8641 + ceil32(return_data.size)] = _8929
                                                require return_data.size >= _8785 + (32 * _8929) + 32
                                                mem[_8641 + ceil32(return_data.size) + 32 len 32 * _8929] = mem[_8641 + _8785 + 32 len 32 * _8929]
                                                if 0 >= _8929:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8641 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8641 + ceil32(return_data.size) + 32]
                                                if 1 >= _8929:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8641 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5753:
                                                        revert with 0, 17
                                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                                    mem[_5757 + 132] = 0
                                                    mem[_5757 + 164] = 160
                                                    mem[_5757 + 260] = mem[_5757]
                                                    idx = 0
                                                    s = _5757 + 292
                                                    t = _5757 + 32
                                                    while idx < mem[_5757]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5757 + 196] = this.address
                                                    mem[_5757 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8642 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8786 = mem[_8642]
                                                    require mem[_8642] <= test266151307()
                                                    require _8642 + mem[_8642] + 31 < _8642 + return_data.size
                                                    _8930 = mem[_8642 + mem[_8642]]
                                                    if mem[_8642 + mem[_8642]] > test266151307():
                                                        revert with 0, 65
                                                    if _8642 + ceil32(return_data.size) + ceil32(32 * mem[_8642 + mem[_8642]]) + 1 > test266151307() or ceil32(32 * mem[_8642 + mem[_8642]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8642 + ceil32(return_data.size) + ceil32(32 * mem[_8642 + mem[_8642]]) + 1
                                                    mem[_8642 + ceil32(return_data.size)] = _8930
                                                    require return_data.size >= _8786 + (32 * _8930) + 32
                                                    mem[_8642 + ceil32(return_data.size) + 32 len 32 * _8930] = mem[_8642 + _8786 + 32 len 32 * _8930]
                                                    if 0 >= _8930:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8642 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8642 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8930:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8642 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5753:
                                                        revert with 0, 17
                                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                                    mem[_5757 + 132] = 0
                                                    mem[_5757 + 164] = 160
                                                    mem[_5757 + 260] = mem[_5757]
                                                    idx = 0
                                                    s = _5757 + 292
                                                    t = _5757 + 32
                                                    while idx < mem[_5757]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5757 + 196] = this.address
                                                    mem[_5757 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8643 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8787 = mem[_8643]
                                                    require mem[_8643] <= test266151307()
                                                    require _8643 + mem[_8643] + 31 < _8643 + return_data.size
                                                    _8931 = mem[_8643 + mem[_8643]]
                                                    if mem[_8643 + mem[_8643]] > test266151307():
                                                        revert with 0, 65
                                                    if _8643 + ceil32(return_data.size) + ceil32(32 * mem[_8643 + mem[_8643]]) + 1 > test266151307() or ceil32(32 * mem[_8643 + mem[_8643]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8643 + ceil32(return_data.size) + ceil32(32 * mem[_8643 + mem[_8643]]) + 1
                                                    mem[_8643 + ceil32(return_data.size)] = _8931
                                                    require return_data.size >= _8787 + (32 * _8931) + 32
                                                    mem[_8643 + ceil32(return_data.size) + 32 len 32 * _8931] = mem[_8643 + _8787 + 32 len 32 * _8931]
                                                    if 0 >= _8931:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8643 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8643 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8931:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8643 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8644 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8788 = mem[_8644]
                                            require mem[_8644] <= test266151307()
                                            require _8644 + mem[_8644] + 31 < _8644 + return_data.size
                                            _8932 = mem[_8644 + mem[_8644]]
                                            if mem[_8644 + mem[_8644]] > test266151307():
                                                revert with 0, 65
                                            if _8644 + ceil32(return_data.size) + ceil32(32 * mem[_8644 + mem[_8644]]) + 1 > test266151307() or ceil32(32 * mem[_8644 + mem[_8644]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8644 + ceil32(return_data.size) + ceil32(32 * mem[_8644 + mem[_8644]]) + 1
                                            mem[_8644 + ceil32(return_data.size)] = _8932
                                            require return_data.size >= _8788 + (32 * _8932) + 32
                                            mem[_8644 + ceil32(return_data.size) + 32 len 32 * _8932] = mem[_8644 + _8788 + 32 len 32 * _8932]
                                            if 0 >= _8932:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8644 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8644 + ceil32(return_data.size) + 32]
                                            if 1 >= _8932:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8644 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8645 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8789 = mem[_8645]
                                            require mem[_8645] <= test266151307()
                                            require _8645 + mem[_8645] + 31 < _8645 + return_data.size
                                            _8933 = mem[_8645 + mem[_8645]]
                                            if mem[_8645 + mem[_8645]] > test266151307():
                                                revert with 0, 65
                                            if _8645 + ceil32(return_data.size) + ceil32(32 * mem[_8645 + mem[_8645]]) + 1 > test266151307() or ceil32(32 * mem[_8645 + mem[_8645]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8645 + ceil32(return_data.size) + ceil32(32 * mem[_8645 + mem[_8645]]) + 1
                                            mem[_8645 + ceil32(return_data.size)] = _8933
                                            require return_data.size >= _8789 + (32 * _8933) + 32
                                            mem[_8645 + ceil32(return_data.size) + 32 len 32 * _8933] = mem[_8645 + _8789 + 32 len 32 * _8933]
                                            if 0 >= _8933:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8645 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8645 + ceil32(return_data.size) + 32]
                                            if 1 >= _8933:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8645 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8646 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8790 = mem[_8646]
                                            require mem[_8646] <= test266151307()
                                            require _8646 + mem[_8646] + 31 < _8646 + return_data.size
                                            _8934 = mem[_8646 + mem[_8646]]
                                            if mem[_8646 + mem[_8646]] > test266151307():
                                                revert with 0, 65
                                            if _8646 + ceil32(return_data.size) + ceil32(32 * mem[_8646 + mem[_8646]]) + 1 > test266151307() or ceil32(32 * mem[_8646 + mem[_8646]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8646 + ceil32(return_data.size) + ceil32(32 * mem[_8646 + mem[_8646]]) + 1
                                            mem[_8646 + ceil32(return_data.size)] = _8934
                                            require return_data.size >= _8790 + (32 * _8934) + 32
                                            mem[_8646 + ceil32(return_data.size) + 32 len 32 * _8934] = mem[_8646 + _8790 + 32 len 32 * _8934]
                                            if 0 >= _8934:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8646 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8646 + ceil32(return_data.size) + 32]
                                            if 1 >= _8934:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8646 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5753:
                                                    revert with 0, 17
                                                mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                                mem[_5757 + 132] = 0
                                                mem[_5757 + 164] = 160
                                                mem[_5757 + 260] = mem[_5757]
                                                idx = 0
                                                s = _5757 + 292
                                                t = _5757 + 32
                                                while idx < mem[_5757]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5757 + 196] = this.address
                                                mem[_5757 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8647 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8791 = mem[_8647]
                                                require mem[_8647] <= test266151307()
                                                require _8647 + mem[_8647] + 31 < _8647 + return_data.size
                                                _8935 = mem[_8647 + mem[_8647]]
                                                if mem[_8647 + mem[_8647]] > test266151307():
                                                    revert with 0, 65
                                                if _8647 + ceil32(return_data.size) + ceil32(32 * mem[_8647 + mem[_8647]]) + 1 > test266151307() or ceil32(32 * mem[_8647 + mem[_8647]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8647 + ceil32(return_data.size) + ceil32(32 * mem[_8647 + mem[_8647]]) + 1
                                                mem[_8647 + ceil32(return_data.size)] = _8935
                                                require return_data.size >= _8791 + (32 * _8935) + 32
                                                mem[_8647 + ceil32(return_data.size) + 32 len 32 * _8935] = mem[_8647 + _8791 + 32 len 32 * _8935]
                                                if 0 >= _8935:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8647 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8647 + ceil32(return_data.size) + 32]
                                                if 1 >= _8935:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8647 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5753:
                                                        revert with 0, 17
                                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                                    mem[_5757 + 132] = 0
                                                    mem[_5757 + 164] = 160
                                                    mem[_5757 + 260] = mem[_5757]
                                                    idx = 0
                                                    s = _5757 + 292
                                                    t = _5757 + 32
                                                    while idx < mem[_5757]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5757 + 196] = this.address
                                                    mem[_5757 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8648 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8792 = mem[_8648]
                                                    require mem[_8648] <= test266151307()
                                                    require _8648 + mem[_8648] + 31 < _8648 + return_data.size
                                                    _8936 = mem[_8648 + mem[_8648]]
                                                    if mem[_8648 + mem[_8648]] > test266151307():
                                                        revert with 0, 65
                                                    if _8648 + ceil32(return_data.size) + ceil32(32 * mem[_8648 + mem[_8648]]) + 1 > test266151307() or ceil32(32 * mem[_8648 + mem[_8648]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8648 + ceil32(return_data.size) + ceil32(32 * mem[_8648 + mem[_8648]]) + 1
                                                    mem[_8648 + ceil32(return_data.size)] = _8936
                                                    require return_data.size >= _8792 + (32 * _8936) + 32
                                                    mem[_8648 + ceil32(return_data.size) + 32 len 32 * _8936] = mem[_8648 + _8792 + 32 len 32 * _8936]
                                                    if 0 >= _8936:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8648 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8648 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8936:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8648 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5753:
                                                        revert with 0, 17
                                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                                    mem[_5757 + 132] = 0
                                                    mem[_5757 + 164] = 160
                                                    mem[_5757 + 260] = mem[_5757]
                                                    idx = 0
                                                    s = _5757 + 292
                                                    t = _5757 + 32
                                                    while idx < mem[_5757]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5757 + 196] = this.address
                                                    mem[_5757 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8649 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8793 = mem[_8649]
                                                    require mem[_8649] <= test266151307()
                                                    require _8649 + mem[_8649] + 31 < _8649 + return_data.size
                                                    _8937 = mem[_8649 + mem[_8649]]
                                                    if mem[_8649 + mem[_8649]] > test266151307():
                                                        revert with 0, 65
                                                    if _8649 + ceil32(return_data.size) + ceil32(32 * mem[_8649 + mem[_8649]]) + 1 > test266151307() or ceil32(32 * mem[_8649 + mem[_8649]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8649 + ceil32(return_data.size) + ceil32(32 * mem[_8649 + mem[_8649]]) + 1
                                                    mem[_8649 + ceil32(return_data.size)] = _8937
                                                    require return_data.size >= _8793 + (32 * _8937) + 32
                                                    mem[_8649 + ceil32(return_data.size) + 32 len 32 * _8937] = mem[_8649 + _8793 + 32 len 32 * _8937]
                                                    if 0 >= _8937:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8649 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8649 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8937:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8649 + ceil32(return_data.size) + 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function buyBackAndBurnAll(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require maxBurnAndBuyBackAmounts[address(arg1)] > 0
    mem[0] = arg1
    mem[32] = 10
    require maxBurnAndBuyBackAmounts[address(arg1)] <= maxBurnAndBuyBackAmounts[address(arg1)]
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(arg1)
    staticcall arg1.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if 60 > !block.timestamp:
        revert with 0, 17
    mem[(2 * ceil32(return_data.size)) + 132] = address(ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 164] = maxBurnAndBuyBackAmounts[address(arg1)]
    mem[(2 * ceil32(return_data.size)) + 196] = 0
    mem[(2 * ceil32(return_data.size)) + 228] = 0
    mem[(2 * ceil32(return_data.size)) + 260] = this.address
    mem[(2 * ceil32(return_data.size)) + 292] = block.timestamp + 60
    require ext_code.size(routerAddress)
    call routerAddress.removeLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, address rg6, uint256 rg7) with:
         gas gas_remaining wei
        args address(ext_call.return_data[0]), address(ext_call.return_data[0]), maxBurnAndBuyBackAmounts[address(arg1)], 0, 0, address(this.address), block.timestamp + 60
    mem[(2 * ceil32(return_data.size)) + 96 len 64] = ext_call.return_data[0 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    if 10000 > !block.timestamp:
        revert with 0, 17
    if brushAddress == address(ext_call.return_data[0]):
        mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
        mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
        if brushAddress == address(ext_call.return_data[0]):
            if ext_call.return_data[32] > -1:
                revert with 0, 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 388
            t = (4 * ceil32(return_data.size)) + 128
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
            require ext_code.size(routerAddress)
            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _2960 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _2991 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                revert with 0, 65
            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                revert with 0, 65
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            require return_data.size >= _2960 + (32 * _2991) + 32
            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2991] = mem[(4 * ceil32(return_data.size)) + _2960 + 224 len 32 * _2991]
            if 0 >= _2991:
                revert with 0, 50
            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                revert with 0, 17
            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
            if 1 >= _2991:
                revert with 0, 50
        else:
            if wftmAddress == address(ext_call.return_data[0]):
                if ext_call.return_data[32] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2958 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _2989 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                require return_data.size >= _2958 + (32 * _2989) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2989] = mem[(4 * ceil32(return_data.size)) + _2958 + 224 len 32 * _2989]
                if 0 >= _2989:
                    revert with 0, 50
                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                if 1 >= _2989:
                    revert with 0, 50
            else:
                if ext_call.return_data[0] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2959 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _2990 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                require return_data.size >= _2959 + (32 * _2990) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2990] = mem[(4 * ceil32(return_data.size)) + _2959 + 224 len 32 * _2990]
                if 0 >= _2990:
                    revert with 0, 50
                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                if 1 >= _2990:
                    revert with 0, 50
        require ext_code.size(brushAddress)
        call brushAddress.burn(uint256 rg1) with:
             gas gas_remaining wei
            args mem[(6 * ceil32(return_data.size)) + 256]
    else:
        if brushAddress == address(ext_call.return_data[0]):
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
            if brushAddress == address(ext_call.return_data[0]):
                if brushAddress != address(ext_call.return_data[0]):
                    if wftmAddress == address(ext_call.return_data[0]):
                        if ext_call.return_data[32] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2961 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2992 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        require return_data.size >= _2961 + (32 * _2992) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2992] = mem[(4 * ceil32(return_data.size)) + _2961 + 224 len 32 * _2992]
                        if 0 >= _2992:
                            revert with 0, 50
                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                        if 1 >= _2992:
                            revert with 0, 50
                    else:
                        if ext_call.return_data[0] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2962 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2993 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                        require return_data.size >= _2962 + (32 * _2993) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2993] = mem[(4 * ceil32(return_data.size)) + _2962 + 224 len 32 * _2993]
                        if 0 >= _2993:
                            revert with 0, 50
                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                        if 1 >= _2993:
                            revert with 0, 50
                else:
                    if brushAddress == address(ext_call.return_data[0]):
                        if ext_call.return_data[32] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2963 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2994 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        require return_data.size >= _2963 + (32 * _2994) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2994] = mem[(4 * ceil32(return_data.size)) + _2963 + 224 len 32 * _2994]
                        if 0 >= _2994:
                            revert with 0, 50
                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                        if 1 >= _2994:
                            revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[0] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2964 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2995 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            require return_data.size >= _2964 + (32 * _2995) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2995] = mem[(4 * ceil32(return_data.size)) + _2964 + 224 len 32 * _2995]
                            if 0 >= _2995:
                                revert with 0, 50
                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                            if 1 >= _2995:
                                revert with 0, 50
                        else:
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2965 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2996 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2965 + (32 * _2996) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2996] = mem[(4 * ceil32(return_data.size)) + _2965 + 224 len 32 * _2996]
                                if 0 >= _2996:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _2996:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2966 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2997 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2966 + (32 * _2997) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2997] = mem[(4 * ceil32(return_data.size)) + _2966 + 224 len 32 * _2997]
                                if 0 >= _2997:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _2997:
                                    revert with 0, 50
            else:
                if brushAddress == address(ext_call.return_data[0]):
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[32] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2967 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2998 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            require return_data.size >= _2967 + (32 * _2998) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2998] = mem[(4 * ceil32(return_data.size)) + _2967 + 224 len 32 * _2998]
                            if 0 >= _2998:
                                revert with 0, 50
                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                            if 1 >= _2998:
                                revert with 0, 50
                        else:
                            if ext_call.return_data[0] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2968 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2999 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            require return_data.size >= _2968 + (32 * _2999) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2999] = mem[(4 * ceil32(return_data.size)) + _2968 + 224 len 32 * _2999]
                            if 0 >= _2999:
                                revert with 0, 50
                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                            if 1 >= _2999:
                                revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[32] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2969 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _3000 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            require return_data.size >= _2969 + (32 * _3000) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3000] = mem[(4 * ceil32(return_data.size)) + _2969 + 224 len 32 * _3000]
                            if 0 >= _3000:
                                revert with 0, 50
                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                            if 1 >= _3000:
                                revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2970 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3001 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2970 + (32 * _3001) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3001] = mem[(4 * ceil32(return_data.size)) + _2970 + 224 len 32 * _3001]
                                if 0 >= _3001:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3001:
                                    revert with 0, 50
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2971 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3002 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _2971 + (32 * _3002) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3002] = mem[(4 * ceil32(return_data.size)) + _2971 + 224 len 32 * _3002]
                                    if 0 >= _3002:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                    if 1 >= _3002:
                                        revert with 0, 50
                                else:
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2972 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3003 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2972 + (32 * _3003) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3003] = mem[(4 * ceil32(return_data.size)) + _2972 + 224 len 32 * _3003]
                                    if 0 >= _3003:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                    if 1 >= _3003:
                                        revert with 0, 50
                else:
                    if wftmAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2973 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3004 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2973 + (32 * _3004) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3004] = mem[(4 * ceil32(return_data.size)) + _2973 + 224 len 32 * _3004]
                                if 0 >= _3004:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3004:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2974 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3005 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2974 + (32 * _3005) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3005] = mem[(4 * ceil32(return_data.size)) + _2974 + 224 len 32 * _3005]
                                if 0 >= _3005:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3005:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2975 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3006 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2975 + (32 * _3006) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3006] = mem[(4 * ceil32(return_data.size)) + _2975 + 224 len 32 * _3006]
                                if 0 >= _3006:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3006:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2976 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3007 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2976 + (32 * _3007) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3007] = mem[(4 * ceil32(return_data.size)) + _2976 + 224 len 32 * _3007]
                                    if 0 >= _3007:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                    if 1 >= _3007:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2977 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3008 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _2977 + (32 * _3008) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3008] = mem[(4 * ceil32(return_data.size)) + _2977 + 224 len 32 * _3008]
                                        if 0 >= _3008:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                        if 1 >= _3008:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2978 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3009 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _2978 + (32 * _3009) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3009] = mem[(4 * ceil32(return_data.size)) + _2978 + 224 len 32 * _3009]
                                        if 0 >= _3009:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                        if 1 >= _3009:
                                            revert with 0, 50
                    else:
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2979 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3010 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2979 + (32 * _3010) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3010] = mem[(4 * ceil32(return_data.size)) + _2979 + 224 len 32 * _3010]
                                if 0 >= _3010:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3010:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2980 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3011 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2980 + (32 * _3011) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3011] = mem[(4 * ceil32(return_data.size)) + _2980 + 224 len 32 * _3011]
                                if 0 >= _3011:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3011:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2981 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3012 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2981 + (32 * _3012) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3012] = mem[(4 * ceil32(return_data.size)) + _2981 + 224 len 32 * _3012]
                                if 0 >= _3012:
                                    revert with 0, 50
                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                if 1 >= _3012:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2982 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3013 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2982 + (32 * _3013) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3013] = mem[(4 * ceil32(return_data.size)) + _2982 + 224 len 32 * _3013]
                                    if 0 >= _3013:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                    if 1 >= _3013:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2983 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3014 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _2983 + (32 * _3014) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3014] = mem[(4 * ceil32(return_data.size)) + _2983 + 224 len 32 * _3014]
                                        if 0 >= _3014:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                        if 1 >= _3014:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2984 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3015 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _2984 + (32 * _3015) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3015] = mem[(4 * ceil32(return_data.size)) + _2984 + 224 len 32 * _3015]
                                        if 0 >= _3015:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[(6 * ceil32(return_data.size)) + 224]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[(6 * ceil32(return_data.size)) + 224]
                                        if 1 >= _3015:
                                            revert with 0, 50
            require ext_code.size(brushAddress)
            call brushAddress.burn(uint256 rg1) with:
                 gas gas_remaining wei
                args mem[(6 * ceil32(return_data.size)) + 256]
        else:
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = wftmAddress
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            if wftmAddress == address(ext_call.return_data[0]):
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2985 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3016 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3016
                    require return_data.size >= _2985 + (32 * _3016) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3016] = mem[(4 * ceil32(return_data.size)) + _2985 + 224 len 32 * _3016]
                    if 1 >= _3016:
                        revert with 0, 50
                    _5751 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5755 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5755]:
                        revert with 0, 50
                    mem[_5755 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5755]:
                        revert with 0, 50
                    mem[_5755 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8507 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8651 = mem[_8507]
                                    require mem[_8507] <= test266151307()
                                    require _8507 + mem[_8507] + 31 < _8507 + return_data.size
                                    _8795 = mem[_8507 + mem[_8507]]
                                    if mem[_8507 + mem[_8507]] > test266151307():
                                        revert with 0, 65
                                    if _8507 + ceil32(return_data.size) + ceil32(32 * mem[_8507 + mem[_8507]]) + 1 > test266151307() or ceil32(32 * mem[_8507 + mem[_8507]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8507 + ceil32(return_data.size) + ceil32(32 * mem[_8507 + mem[_8507]]) + 1
                                    mem[_8507 + ceil32(return_data.size)] = _8795
                                    require return_data.size >= _8651 + (32 * _8795) + 32
                                    mem[_8507 + ceil32(return_data.size) + 32 len 32 * _8795] = mem[_8507 + _8651 + 32 len 32 * _8795]
                                    if 0 >= _8795:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8507 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8507 + ceil32(return_data.size) + 32]
                                    if 1 >= _8795:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8507 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8508 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8652 = mem[_8508]
                                    require mem[_8508] <= test266151307()
                                    require _8508 + mem[_8508] + 31 < _8508 + return_data.size
                                    _8796 = mem[_8508 + mem[_8508]]
                                    if mem[_8508 + mem[_8508]] > test266151307():
                                        revert with 0, 65
                                    if _8508 + ceil32(return_data.size) + ceil32(32 * mem[_8508 + mem[_8508]]) + 1 > test266151307() or ceil32(32 * mem[_8508 + mem[_8508]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8508 + ceil32(return_data.size) + ceil32(32 * mem[_8508 + mem[_8508]]) + 1
                                    mem[_8508 + ceil32(return_data.size)] = _8796
                                    require return_data.size >= _8652 + (32 * _8796) + 32
                                    mem[_8508 + ceil32(return_data.size) + 32 len 32 * _8796] = mem[_8508 + _8652 + 32 len 32 * _8796]
                                    if 0 >= _8796:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8508 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8508 + ceil32(return_data.size) + 32]
                                    if 1 >= _8796:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8508 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8509 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8653 = mem[_8509]
                                    require mem[_8509] <= test266151307()
                                    require _8509 + mem[_8509] + 31 < _8509 + return_data.size
                                    _8797 = mem[_8509 + mem[_8509]]
                                    if mem[_8509 + mem[_8509]] > test266151307():
                                        revert with 0, 65
                                    if _8509 + ceil32(return_data.size) + ceil32(32 * mem[_8509 + mem[_8509]]) + 1 > test266151307() or ceil32(32 * mem[_8509 + mem[_8509]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8509 + ceil32(return_data.size) + ceil32(32 * mem[_8509 + mem[_8509]]) + 1
                                    mem[_8509 + ceil32(return_data.size)] = _8797
                                    require return_data.size >= _8653 + (32 * _8797) + 32
                                    mem[_8509 + ceil32(return_data.size) + 32 len 32 * _8797] = mem[_8509 + _8653 + 32 len 32 * _8797]
                                    if 0 >= _8797:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8509 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8509 + ceil32(return_data.size) + 32]
                                    if 1 >= _8797:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8509 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8510 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8654 = mem[_8510]
                                        require mem[_8510] <= test266151307()
                                        require _8510 + mem[_8510] + 31 < _8510 + return_data.size
                                        _8798 = mem[_8510 + mem[_8510]]
                                        if mem[_8510 + mem[_8510]] > test266151307():
                                            revert with 0, 65
                                        if _8510 + ceil32(return_data.size) + ceil32(32 * mem[_8510 + mem[_8510]]) + 1 > test266151307() or ceil32(32 * mem[_8510 + mem[_8510]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8510 + ceil32(return_data.size) + ceil32(32 * mem[_8510 + mem[_8510]]) + 1
                                        mem[_8510 + ceil32(return_data.size)] = _8798
                                        require return_data.size >= _8654 + (32 * _8798) + 32
                                        mem[_8510 + ceil32(return_data.size) + 32 len 32 * _8798] = mem[_8510 + _8654 + 32 len 32 * _8798]
                                        if 0 >= _8798:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8510 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8510 + ceil32(return_data.size) + 32]
                                        if 1 >= _8798:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8510 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8511 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8655 = mem[_8511]
                                            require mem[_8511] <= test266151307()
                                            require _8511 + mem[_8511] + 31 < _8511 + return_data.size
                                            _8799 = mem[_8511 + mem[_8511]]
                                            if mem[_8511 + mem[_8511]] > test266151307():
                                                revert with 0, 65
                                            if _8511 + ceil32(return_data.size) + ceil32(32 * mem[_8511 + mem[_8511]]) + 1 > test266151307() or ceil32(32 * mem[_8511 + mem[_8511]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8511 + ceil32(return_data.size) + ceil32(32 * mem[_8511 + mem[_8511]]) + 1
                                            mem[_8511 + ceil32(return_data.size)] = _8799
                                            require return_data.size >= _8655 + (32 * _8799) + 32
                                            mem[_8511 + ceil32(return_data.size) + 32 len 32 * _8799] = mem[_8511 + _8655 + 32 len 32 * _8799]
                                            if 0 >= _8799:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8511 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8511 + ceil32(return_data.size) + 32]
                                            if 1 >= _8799:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8511 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8512 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8656 = mem[_8512]
                                            require mem[_8512] <= test266151307()
                                            require _8512 + mem[_8512] + 31 < _8512 + return_data.size
                                            _8800 = mem[_8512 + mem[_8512]]
                                            if mem[_8512 + mem[_8512]] > test266151307():
                                                revert with 0, 65
                                            if _8512 + ceil32(return_data.size) + ceil32(32 * mem[_8512 + mem[_8512]]) + 1 > test266151307() or ceil32(32 * mem[_8512 + mem[_8512]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8512 + ceil32(return_data.size) + ceil32(32 * mem[_8512 + mem[_8512]]) + 1
                                            mem[_8512 + ceil32(return_data.size)] = _8800
                                            require return_data.size >= _8656 + (32 * _8800) + 32
                                            mem[_8512 + ceil32(return_data.size) + 32 len 32 * _8800] = mem[_8512 + _8656 + 32 len 32 * _8800]
                                            if 0 >= _8800:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8512 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8512 + ceil32(return_data.size) + 32]
                                            if 1 >= _8800:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8512 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8513 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8657 = mem[_8513]
                                    require mem[_8513] <= test266151307()
                                    require _8513 + mem[_8513] + 31 < _8513 + return_data.size
                                    _8801 = mem[_8513 + mem[_8513]]
                                    if mem[_8513 + mem[_8513]] > test266151307():
                                        revert with 0, 65
                                    if _8513 + ceil32(return_data.size) + ceil32(32 * mem[_8513 + mem[_8513]]) + 1 > test266151307() or ceil32(32 * mem[_8513 + mem[_8513]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8513 + ceil32(return_data.size) + ceil32(32 * mem[_8513 + mem[_8513]]) + 1
                                    mem[_8513 + ceil32(return_data.size)] = _8801
                                    require return_data.size >= _8657 + (32 * _8801) + 32
                                    mem[_8513 + ceil32(return_data.size) + 32 len 32 * _8801] = mem[_8513 + _8657 + 32 len 32 * _8801]
                                    if 0 >= _8801:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8513 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8513 + ceil32(return_data.size) + 32]
                                    if 1 >= _8801:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8513 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8514 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8658 = mem[_8514]
                                    require mem[_8514] <= test266151307()
                                    require _8514 + mem[_8514] + 31 < _8514 + return_data.size
                                    _8802 = mem[_8514 + mem[_8514]]
                                    if mem[_8514 + mem[_8514]] > test266151307():
                                        revert with 0, 65
                                    if _8514 + ceil32(return_data.size) + ceil32(32 * mem[_8514 + mem[_8514]]) + 1 > test266151307() or ceil32(32 * mem[_8514 + mem[_8514]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8514 + ceil32(return_data.size) + ceil32(32 * mem[_8514 + mem[_8514]]) + 1
                                    mem[_8514 + ceil32(return_data.size)] = _8802
                                    require return_data.size >= _8658 + (32 * _8802) + 32
                                    mem[_8514 + ceil32(return_data.size) + 32 len 32 * _8802] = mem[_8514 + _8658 + 32 len 32 * _8802]
                                    if 0 >= _8802:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8514 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8514 + ceil32(return_data.size) + 32]
                                    if 1 >= _8802:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8514 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8515 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8659 = mem[_8515]
                                    require mem[_8515] <= test266151307()
                                    require _8515 + mem[_8515] + 31 < _8515 + return_data.size
                                    _8803 = mem[_8515 + mem[_8515]]
                                    if mem[_8515 + mem[_8515]] > test266151307():
                                        revert with 0, 65
                                    if _8515 + ceil32(return_data.size) + ceil32(32 * mem[_8515 + mem[_8515]]) + 1 > test266151307() or ceil32(32 * mem[_8515 + mem[_8515]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8515 + ceil32(return_data.size) + ceil32(32 * mem[_8515 + mem[_8515]]) + 1
                                    mem[_8515 + ceil32(return_data.size)] = _8803
                                    require return_data.size >= _8659 + (32 * _8803) + 32
                                    mem[_8515 + ceil32(return_data.size) + 32 len 32 * _8803] = mem[_8515 + _8659 + 32 len 32 * _8803]
                                    if 0 >= _8803:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8515 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8515 + ceil32(return_data.size) + 32]
                                    if 1 >= _8803:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8515 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8516 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8660 = mem[_8516]
                                        require mem[_8516] <= test266151307()
                                        require _8516 + mem[_8516] + 31 < _8516 + return_data.size
                                        _8804 = mem[_8516 + mem[_8516]]
                                        if mem[_8516 + mem[_8516]] > test266151307():
                                            revert with 0, 65
                                        if _8516 + ceil32(return_data.size) + ceil32(32 * mem[_8516 + mem[_8516]]) + 1 > test266151307() or ceil32(32 * mem[_8516 + mem[_8516]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8516 + ceil32(return_data.size) + ceil32(32 * mem[_8516 + mem[_8516]]) + 1
                                        mem[_8516 + ceil32(return_data.size)] = _8804
                                        require return_data.size >= _8660 + (32 * _8804) + 32
                                        mem[_8516 + ceil32(return_data.size) + 32 len 32 * _8804] = mem[_8516 + _8660 + 32 len 32 * _8804]
                                        if 0 >= _8804:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8516 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8516 + ceil32(return_data.size) + 32]
                                        if 1 >= _8804:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8516 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8517 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8661 = mem[_8517]
                                            require mem[_8517] <= test266151307()
                                            require _8517 + mem[_8517] + 31 < _8517 + return_data.size
                                            _8805 = mem[_8517 + mem[_8517]]
                                            if mem[_8517 + mem[_8517]] > test266151307():
                                                revert with 0, 65
                                            if _8517 + ceil32(return_data.size) + ceil32(32 * mem[_8517 + mem[_8517]]) + 1 > test266151307() or ceil32(32 * mem[_8517 + mem[_8517]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8517 + ceil32(return_data.size) + ceil32(32 * mem[_8517 + mem[_8517]]) + 1
                                            mem[_8517 + ceil32(return_data.size)] = _8805
                                            require return_data.size >= _8661 + (32 * _8805) + 32
                                            mem[_8517 + ceil32(return_data.size) + 32 len 32 * _8805] = mem[_8517 + _8661 + 32 len 32 * _8805]
                                            if 0 >= _8805:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8517 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8517 + ceil32(return_data.size) + 32]
                                            if 1 >= _8805:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8517 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8518 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8662 = mem[_8518]
                                            require mem[_8518] <= test266151307()
                                            require _8518 + mem[_8518] + 31 < _8518 + return_data.size
                                            _8806 = mem[_8518 + mem[_8518]]
                                            if mem[_8518 + mem[_8518]] > test266151307():
                                                revert with 0, 65
                                            if _8518 + ceil32(return_data.size) + ceil32(32 * mem[_8518 + mem[_8518]]) + 1 > test266151307() or ceil32(32 * mem[_8518 + mem[_8518]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8518 + ceil32(return_data.size) + ceil32(32 * mem[_8518 + mem[_8518]]) + 1
                                            mem[_8518 + ceil32(return_data.size)] = _8806
                                            require return_data.size >= _8662 + (32 * _8806) + 32
                                            mem[_8518 + ceil32(return_data.size) + 32 len 32 * _8806] = mem[_8518 + _8662 + 32 len 32 * _8806]
                                            if 0 >= _8806:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8518 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8518 + ceil32(return_data.size) + 32]
                                            if 1 >= _8806:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8518 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8519 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8663 = mem[_8519]
                                    require mem[_8519] <= test266151307()
                                    require _8519 + mem[_8519] + 31 < _8519 + return_data.size
                                    _8807 = mem[_8519 + mem[_8519]]
                                    if mem[_8519 + mem[_8519]] > test266151307():
                                        revert with 0, 65
                                    if _8519 + ceil32(return_data.size) + ceil32(32 * mem[_8519 + mem[_8519]]) + 1 > test266151307() or ceil32(32 * mem[_8519 + mem[_8519]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8519 + ceil32(return_data.size) + ceil32(32 * mem[_8519 + mem[_8519]]) + 1
                                    mem[_8519 + ceil32(return_data.size)] = _8807
                                    require return_data.size >= _8663 + (32 * _8807) + 32
                                    mem[_8519 + ceil32(return_data.size) + 32 len 32 * _8807] = mem[_8519 + _8663 + 32 len 32 * _8807]
                                    if 0 >= _8807:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8519 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8519 + ceil32(return_data.size) + 32]
                                    if 1 >= _8807:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8519 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8520 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8664 = mem[_8520]
                                    require mem[_8520] <= test266151307()
                                    require _8520 + mem[_8520] + 31 < _8520 + return_data.size
                                    _8808 = mem[_8520 + mem[_8520]]
                                    if mem[_8520 + mem[_8520]] > test266151307():
                                        revert with 0, 65
                                    if _8520 + ceil32(return_data.size) + ceil32(32 * mem[_8520 + mem[_8520]]) + 1 > test266151307() or ceil32(32 * mem[_8520 + mem[_8520]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8520 + ceil32(return_data.size) + ceil32(32 * mem[_8520 + mem[_8520]]) + 1
                                    mem[_8520 + ceil32(return_data.size)] = _8808
                                    require return_data.size >= _8664 + (32 * _8808) + 32
                                    mem[_8520 + ceil32(return_data.size) + 32 len 32 * _8808] = mem[_8520 + _8664 + 32 len 32 * _8808]
                                    if 0 >= _8808:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8520 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8520 + ceil32(return_data.size) + 32]
                                    if 1 >= _8808:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8520 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5751:
                                        revert with 0, 17
                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                    mem[_5755 + 132] = 0
                                    mem[_5755 + 164] = 160
                                    mem[_5755 + 260] = mem[_5755]
                                    idx = 0
                                    s = _5755 + 292
                                    t = _5755 + 32
                                    while idx < mem[_5755]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5755 + 196] = this.address
                                    mem[_5755 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8521 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8665 = mem[_8521]
                                    require mem[_8521] <= test266151307()
                                    require _8521 + mem[_8521] + 31 < _8521 + return_data.size
                                    _8809 = mem[_8521 + mem[_8521]]
                                    if mem[_8521 + mem[_8521]] > test266151307():
                                        revert with 0, 65
                                    if _8521 + ceil32(return_data.size) + ceil32(32 * mem[_8521 + mem[_8521]]) + 1 > test266151307() or ceil32(32 * mem[_8521 + mem[_8521]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8521 + ceil32(return_data.size) + ceil32(32 * mem[_8521 + mem[_8521]]) + 1
                                    mem[_8521 + ceil32(return_data.size)] = _8809
                                    require return_data.size >= _8665 + (32 * _8809) + 32
                                    mem[_8521 + ceil32(return_data.size) + 32 len 32 * _8809] = mem[_8521 + _8665 + 32 len 32 * _8809]
                                    if 0 >= _8809:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8521 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8521 + ceil32(return_data.size) + 32]
                                    if 1 >= _8809:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8521 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8522 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8666 = mem[_8522]
                                        require mem[_8522] <= test266151307()
                                        require _8522 + mem[_8522] + 31 < _8522 + return_data.size
                                        _8810 = mem[_8522 + mem[_8522]]
                                        if mem[_8522 + mem[_8522]] > test266151307():
                                            revert with 0, 65
                                        if _8522 + ceil32(return_data.size) + ceil32(32 * mem[_8522 + mem[_8522]]) + 1 > test266151307() or ceil32(32 * mem[_8522 + mem[_8522]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8522 + ceil32(return_data.size) + ceil32(32 * mem[_8522 + mem[_8522]]) + 1
                                        mem[_8522 + ceil32(return_data.size)] = _8810
                                        require return_data.size >= _8666 + (32 * _8810) + 32
                                        mem[_8522 + ceil32(return_data.size) + 32 len 32 * _8810] = mem[_8522 + _8666 + 32 len 32 * _8810]
                                        if 0 >= _8810:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8522 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8522 + ceil32(return_data.size) + 32]
                                        if 1 >= _8810:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8522 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8523 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8667 = mem[_8523]
                                            require mem[_8523] <= test266151307()
                                            require _8523 + mem[_8523] + 31 < _8523 + return_data.size
                                            _8811 = mem[_8523 + mem[_8523]]
                                            if mem[_8523 + mem[_8523]] > test266151307():
                                                revert with 0, 65
                                            if _8523 + ceil32(return_data.size) + ceil32(32 * mem[_8523 + mem[_8523]]) + 1 > test266151307() or ceil32(32 * mem[_8523 + mem[_8523]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8523 + ceil32(return_data.size) + ceil32(32 * mem[_8523 + mem[_8523]]) + 1
                                            mem[_8523 + ceil32(return_data.size)] = _8811
                                            require return_data.size >= _8667 + (32 * _8811) + 32
                                            mem[_8523 + ceil32(return_data.size) + 32 len 32 * _8811] = mem[_8523 + _8667 + 32 len 32 * _8811]
                                            if 0 >= _8811:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8523 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8523 + ceil32(return_data.size) + 32]
                                            if 1 >= _8811:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8523 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8524 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8668 = mem[_8524]
                                            require mem[_8524] <= test266151307()
                                            require _8524 + mem[_8524] + 31 < _8524 + return_data.size
                                            _8812 = mem[_8524 + mem[_8524]]
                                            if mem[_8524 + mem[_8524]] > test266151307():
                                                revert with 0, 65
                                            if _8524 + ceil32(return_data.size) + ceil32(32 * mem[_8524 + mem[_8524]]) + 1 > test266151307() or ceil32(32 * mem[_8524 + mem[_8524]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8524 + ceil32(return_data.size) + ceil32(32 * mem[_8524 + mem[_8524]]) + 1
                                            mem[_8524 + ceil32(return_data.size)] = _8812
                                            require return_data.size >= _8668 + (32 * _8812) + 32
                                            mem[_8524 + ceil32(return_data.size) + 32 len 32 * _8812] = mem[_8524 + _8668 + 32 len 32 * _8812]
                                            if 0 >= _8812:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8524 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8524 + ceil32(return_data.size) + 32]
                                            if 1 >= _8812:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8524 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8525 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8669 = mem[_8525]
                                        require mem[_8525] <= test266151307()
                                        require _8525 + mem[_8525] + 31 < _8525 + return_data.size
                                        _8813 = mem[_8525 + mem[_8525]]
                                        if mem[_8525 + mem[_8525]] > test266151307():
                                            revert with 0, 65
                                        if _8525 + ceil32(return_data.size) + ceil32(32 * mem[_8525 + mem[_8525]]) + 1 > test266151307() or ceil32(32 * mem[_8525 + mem[_8525]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8525 + ceil32(return_data.size) + ceil32(32 * mem[_8525 + mem[_8525]]) + 1
                                        mem[_8525 + ceil32(return_data.size)] = _8813
                                        require return_data.size >= _8669 + (32 * _8813) + 32
                                        mem[_8525 + ceil32(return_data.size) + 32 len 32 * _8813] = mem[_8525 + _8669 + 32 len 32 * _8813]
                                        if 0 >= _8813:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8525 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8525 + ceil32(return_data.size) + 32]
                                        if 1 >= _8813:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8525 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8526 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8670 = mem[_8526]
                                        require mem[_8526] <= test266151307()
                                        require _8526 + mem[_8526] + 31 < _8526 + return_data.size
                                        _8814 = mem[_8526 + mem[_8526]]
                                        if mem[_8526 + mem[_8526]] > test266151307():
                                            revert with 0, 65
                                        if _8526 + ceil32(return_data.size) + ceil32(32 * mem[_8526 + mem[_8526]]) + 1 > test266151307() or ceil32(32 * mem[_8526 + mem[_8526]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8526 + ceil32(return_data.size) + ceil32(32 * mem[_8526 + mem[_8526]]) + 1
                                        mem[_8526 + ceil32(return_data.size)] = _8814
                                        require return_data.size >= _8670 + (32 * _8814) + 32
                                        mem[_8526 + ceil32(return_data.size) + 32 len 32 * _8814] = mem[_8526 + _8670 + 32 len 32 * _8814]
                                        if 0 >= _8814:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8526 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8526 + ceil32(return_data.size) + 32]
                                        if 1 >= _8814:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8526 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5751:
                                            revert with 0, 17
                                        mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                        mem[_5755 + 132] = 0
                                        mem[_5755 + 164] = 160
                                        mem[_5755 + 260] = mem[_5755]
                                        idx = 0
                                        s = _5755 + 292
                                        t = _5755 + 32
                                        while idx < mem[_5755]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5755 + 196] = this.address
                                        mem[_5755 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8527 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8671 = mem[_8527]
                                        require mem[_8527] <= test266151307()
                                        require _8527 + mem[_8527] + 31 < _8527 + return_data.size
                                        _8815 = mem[_8527 + mem[_8527]]
                                        if mem[_8527 + mem[_8527]] > test266151307():
                                            revert with 0, 65
                                        if _8527 + ceil32(return_data.size) + ceil32(32 * mem[_8527 + mem[_8527]]) + 1 > test266151307() or ceil32(32 * mem[_8527 + mem[_8527]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8527 + ceil32(return_data.size) + ceil32(32 * mem[_8527 + mem[_8527]]) + 1
                                        mem[_8527 + ceil32(return_data.size)] = _8815
                                        require return_data.size >= _8671 + (32 * _8815) + 32
                                        mem[_8527 + ceil32(return_data.size) + 32 len 32 * _8815] = mem[_8527 + _8671 + 32 len 32 * _8815]
                                        if 0 >= _8815:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8527 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8527 + ceil32(return_data.size) + 32]
                                        if 1 >= _8815:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8527 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8528 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8672 = mem[_8528]
                                            require mem[_8528] <= test266151307()
                                            require _8528 + mem[_8528] + 31 < _8528 + return_data.size
                                            _8816 = mem[_8528 + mem[_8528]]
                                            if mem[_8528 + mem[_8528]] > test266151307():
                                                revert with 0, 65
                                            if _8528 + ceil32(return_data.size) + ceil32(32 * mem[_8528 + mem[_8528]]) + 1 > test266151307() or ceil32(32 * mem[_8528 + mem[_8528]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8528 + ceil32(return_data.size) + ceil32(32 * mem[_8528 + mem[_8528]]) + 1
                                            mem[_8528 + ceil32(return_data.size)] = _8816
                                            require return_data.size >= _8672 + (32 * _8816) + 32
                                            mem[_8528 + ceil32(return_data.size) + 32 len 32 * _8816] = mem[_8528 + _8672 + 32 len 32 * _8816]
                                            if 0 >= _8816:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8528 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8528 + ceil32(return_data.size) + 32]
                                            if 1 >= _8816:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8528 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5751:
                                                    revert with 0, 17
                                                mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                                mem[_5755 + 132] = 0
                                                mem[_5755 + 164] = 160
                                                mem[_5755 + 260] = mem[_5755]
                                                idx = 0
                                                s = _5755 + 292
                                                t = _5755 + 32
                                                while idx < mem[_5755]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5755 + 196] = this.address
                                                mem[_5755 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8529 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8673 = mem[_8529]
                                                require mem[_8529] <= test266151307()
                                                require _8529 + mem[_8529] + 31 < _8529 + return_data.size
                                                _8817 = mem[_8529 + mem[_8529]]
                                                if mem[_8529 + mem[_8529]] > test266151307():
                                                    revert with 0, 65
                                                if _8529 + ceil32(return_data.size) + ceil32(32 * mem[_8529 + mem[_8529]]) + 1 > test266151307() or ceil32(32 * mem[_8529 + mem[_8529]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8529 + ceil32(return_data.size) + ceil32(32 * mem[_8529 + mem[_8529]]) + 1
                                                mem[_8529 + ceil32(return_data.size)] = _8817
                                                require return_data.size >= _8673 + (32 * _8817) + 32
                                                mem[_8529 + ceil32(return_data.size) + 32 len 32 * _8817] = mem[_8529 + _8673 + 32 len 32 * _8817]
                                                if 0 >= _8817:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8529 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8529 + ceil32(return_data.size) + 32]
                                                if 1 >= _8817:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8529 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5751:
                                                    revert with 0, 17
                                                mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                                mem[_5755 + 132] = 0
                                                mem[_5755 + 164] = 160
                                                mem[_5755 + 260] = mem[_5755]
                                                idx = 0
                                                s = _5755 + 292
                                                t = _5755 + 32
                                                while idx < mem[_5755]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5755 + 196] = this.address
                                                mem[_5755 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8530 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8674 = mem[_8530]
                                                require mem[_8530] <= test266151307()
                                                require _8530 + mem[_8530] + 31 < _8530 + return_data.size
                                                _8818 = mem[_8530 + mem[_8530]]
                                                if mem[_8530 + mem[_8530]] > test266151307():
                                                    revert with 0, 65
                                                if _8530 + ceil32(return_data.size) + ceil32(32 * mem[_8530 + mem[_8530]]) + 1 > test266151307() or ceil32(32 * mem[_8530 + mem[_8530]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8530 + ceil32(return_data.size) + ceil32(32 * mem[_8530 + mem[_8530]]) + 1
                                                mem[_8530 + ceil32(return_data.size)] = _8818
                                                require return_data.size >= _8674 + (32 * _8818) + 32
                                                mem[_8530 + ceil32(return_data.size) + 32 len 32 * _8818] = mem[_8530 + _8674 + 32 len 32 * _8818]
                                                if 0 >= _8818:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8530 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8530 + ceil32(return_data.size) + 32]
                                                if 1 >= _8818:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8530 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8531 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8675 = mem[_8531]
                                            require mem[_8531] <= test266151307()
                                            require _8531 + mem[_8531] + 31 < _8531 + return_data.size
                                            _8819 = mem[_8531 + mem[_8531]]
                                            if mem[_8531 + mem[_8531]] > test266151307():
                                                revert with 0, 65
                                            if _8531 + ceil32(return_data.size) + ceil32(32 * mem[_8531 + mem[_8531]]) + 1 > test266151307() or ceil32(32 * mem[_8531 + mem[_8531]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8531 + ceil32(return_data.size) + ceil32(32 * mem[_8531 + mem[_8531]]) + 1
                                            mem[_8531 + ceil32(return_data.size)] = _8819
                                            require return_data.size >= _8675 + (32 * _8819) + 32
                                            mem[_8531 + ceil32(return_data.size) + 32 len 32 * _8819] = mem[_8531 + _8675 + 32 len 32 * _8819]
                                            if 0 >= _8819:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8531 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8531 + ceil32(return_data.size) + 32]
                                            if 1 >= _8819:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8531 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8532 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8676 = mem[_8532]
                                            require mem[_8532] <= test266151307()
                                            require _8532 + mem[_8532] + 31 < _8532 + return_data.size
                                            _8820 = mem[_8532 + mem[_8532]]
                                            if mem[_8532 + mem[_8532]] > test266151307():
                                                revert with 0, 65
                                            if _8532 + ceil32(return_data.size) + ceil32(32 * mem[_8532 + mem[_8532]]) + 1 > test266151307() or ceil32(32 * mem[_8532 + mem[_8532]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8532 + ceil32(return_data.size) + ceil32(32 * mem[_8532 + mem[_8532]]) + 1
                                            mem[_8532 + ceil32(return_data.size)] = _8820
                                            require return_data.size >= _8676 + (32 * _8820) + 32
                                            mem[_8532 + ceil32(return_data.size) + 32 len 32 * _8820] = mem[_8532 + _8676 + 32 len 32 * _8820]
                                            if 0 >= _8820:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8532 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8532 + ceil32(return_data.size) + 32]
                                            if 1 >= _8820:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8532 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8533 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8677 = mem[_8533]
                                            require mem[_8533] <= test266151307()
                                            require _8533 + mem[_8533] + 31 < _8533 + return_data.size
                                            _8821 = mem[_8533 + mem[_8533]]
                                            if mem[_8533 + mem[_8533]] > test266151307():
                                                revert with 0, 65
                                            if _8533 + ceil32(return_data.size) + ceil32(32 * mem[_8533 + mem[_8533]]) + 1 > test266151307() or ceil32(32 * mem[_8533 + mem[_8533]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8533 + ceil32(return_data.size) + ceil32(32 * mem[_8533 + mem[_8533]]) + 1
                                            mem[_8533 + ceil32(return_data.size)] = _8821
                                            require return_data.size >= _8677 + (32 * _8821) + 32
                                            mem[_8533 + ceil32(return_data.size) + 32 len 32 * _8821] = mem[_8533 + _8677 + 32 len 32 * _8821]
                                            if 0 >= _8821:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8533 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8533 + ceil32(return_data.size) + 32]
                                            if 1 >= _8821:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8533 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5751:
                                                    revert with 0, 17
                                                mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                                mem[_5755 + 132] = 0
                                                mem[_5755 + 164] = 160
                                                mem[_5755 + 260] = mem[_5755]
                                                idx = 0
                                                s = _5755 + 292
                                                t = _5755 + 32
                                                while idx < mem[_5755]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5755 + 196] = this.address
                                                mem[_5755 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8534 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8678 = mem[_8534]
                                                require mem[_8534] <= test266151307()
                                                require _8534 + mem[_8534] + 31 < _8534 + return_data.size
                                                _8822 = mem[_8534 + mem[_8534]]
                                                if mem[_8534 + mem[_8534]] > test266151307():
                                                    revert with 0, 65
                                                if _8534 + ceil32(return_data.size) + ceil32(32 * mem[_8534 + mem[_8534]]) + 1 > test266151307() or ceil32(32 * mem[_8534 + mem[_8534]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8534 + ceil32(return_data.size) + ceil32(32 * mem[_8534 + mem[_8534]]) + 1
                                                mem[_8534 + ceil32(return_data.size)] = _8822
                                                require return_data.size >= _8678 + (32 * _8822) + 32
                                                mem[_8534 + ceil32(return_data.size) + 32 len 32 * _8822] = mem[_8534 + _8678 + 32 len 32 * _8822]
                                                if 0 >= _8822:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8534 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8534 + ceil32(return_data.size) + 32]
                                                if 1 >= _8822:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8534 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5751:
                                                        revert with 0, 17
                                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                                    mem[_5755 + 132] = 0
                                                    mem[_5755 + 164] = 160
                                                    mem[_5755 + 260] = mem[_5755]
                                                    idx = 0
                                                    s = _5755 + 292
                                                    t = _5755 + 32
                                                    while idx < mem[_5755]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5755 + 196] = this.address
                                                    mem[_5755 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8535 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8679 = mem[_8535]
                                                    require mem[_8535] <= test266151307()
                                                    require _8535 + mem[_8535] + 31 < _8535 + return_data.size
                                                    _8823 = mem[_8535 + mem[_8535]]
                                                    if mem[_8535 + mem[_8535]] > test266151307():
                                                        revert with 0, 65
                                                    if _8535 + ceil32(return_data.size) + ceil32(32 * mem[_8535 + mem[_8535]]) + 1 > test266151307() or ceil32(32 * mem[_8535 + mem[_8535]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8535 + ceil32(return_data.size) + ceil32(32 * mem[_8535 + mem[_8535]]) + 1
                                                    mem[_8535 + ceil32(return_data.size)] = _8823
                                                    require return_data.size >= _8679 + (32 * _8823) + 32
                                                    mem[_8535 + ceil32(return_data.size) + 32 len 32 * _8823] = mem[_8535 + _8679 + 32 len 32 * _8823]
                                                    if 0 >= _8823:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8535 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8535 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8823:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8535 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5751:
                                                        revert with 0, 17
                                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                                    mem[_5755 + 132] = 0
                                                    mem[_5755 + 164] = 160
                                                    mem[_5755 + 260] = mem[_5755]
                                                    idx = 0
                                                    s = _5755 + 292
                                                    t = _5755 + 32
                                                    while idx < mem[_5755]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5755 + 196] = this.address
                                                    mem[_5755 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8536 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8680 = mem[_8536]
                                                    require mem[_8536] <= test266151307()
                                                    require _8536 + mem[_8536] + 31 < _8536 + return_data.size
                                                    _8824 = mem[_8536 + mem[_8536]]
                                                    if mem[_8536 + mem[_8536]] > test266151307():
                                                        revert with 0, 65
                                                    if _8536 + ceil32(return_data.size) + ceil32(32 * mem[_8536 + mem[_8536]]) + 1 > test266151307() or ceil32(32 * mem[_8536 + mem[_8536]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8536 + ceil32(return_data.size) + ceil32(32 * mem[_8536 + mem[_8536]]) + 1
                                                    mem[_8536 + ceil32(return_data.size)] = _8824
                                                    require return_data.size >= _8680 + (32 * _8824) + 32
                                                    mem[_8536 + ceil32(return_data.size) + 32 len 32 * _8824] = mem[_8536 + _8680 + 32 len 32 * _8824]
                                                    if 0 >= _8824:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8536 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8536 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8824:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8536 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8537 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8681 = mem[_8537]
                                            require mem[_8537] <= test266151307()
                                            require _8537 + mem[_8537] + 31 < _8537 + return_data.size
                                            _8825 = mem[_8537 + mem[_8537]]
                                            if mem[_8537 + mem[_8537]] > test266151307():
                                                revert with 0, 65
                                            if _8537 + ceil32(return_data.size) + ceil32(32 * mem[_8537 + mem[_8537]]) + 1 > test266151307() or ceil32(32 * mem[_8537 + mem[_8537]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8537 + ceil32(return_data.size) + ceil32(32 * mem[_8537 + mem[_8537]]) + 1
                                            mem[_8537 + ceil32(return_data.size)] = _8825
                                            require return_data.size >= _8681 + (32 * _8825) + 32
                                            mem[_8537 + ceil32(return_data.size) + 32 len 32 * _8825] = mem[_8537 + _8681 + 32 len 32 * _8825]
                                            if 0 >= _8825:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8537 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8537 + ceil32(return_data.size) + 32]
                                            if 1 >= _8825:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8537 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8538 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8682 = mem[_8538]
                                            require mem[_8538] <= test266151307()
                                            require _8538 + mem[_8538] + 31 < _8538 + return_data.size
                                            _8826 = mem[_8538 + mem[_8538]]
                                            if mem[_8538 + mem[_8538]] > test266151307():
                                                revert with 0, 65
                                            if _8538 + ceil32(return_data.size) + ceil32(32 * mem[_8538 + mem[_8538]]) + 1 > test266151307() or ceil32(32 * mem[_8538 + mem[_8538]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8538 + ceil32(return_data.size) + ceil32(32 * mem[_8538 + mem[_8538]]) + 1
                                            mem[_8538 + ceil32(return_data.size)] = _8826
                                            require return_data.size >= _8682 + (32 * _8826) + 32
                                            mem[_8538 + ceil32(return_data.size) + 32 len 32 * _8826] = mem[_8538 + _8682 + 32 len 32 * _8826]
                                            if 0 >= _8826:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8538 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8538 + ceil32(return_data.size) + 32]
                                            if 1 >= _8826:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8538 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5751:
                                                revert with 0, 17
                                            mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                            mem[_5755 + 132] = 0
                                            mem[_5755 + 164] = 160
                                            mem[_5755 + 260] = mem[_5755]
                                            idx = 0
                                            s = _5755 + 292
                                            t = _5755 + 32
                                            while idx < mem[_5755]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5755 + 196] = this.address
                                            mem[_5755 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8539 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8683 = mem[_8539]
                                            require mem[_8539] <= test266151307()
                                            require _8539 + mem[_8539] + 31 < _8539 + return_data.size
                                            _8827 = mem[_8539 + mem[_8539]]
                                            if mem[_8539 + mem[_8539]] > test266151307():
                                                revert with 0, 65
                                            if _8539 + ceil32(return_data.size) + ceil32(32 * mem[_8539 + mem[_8539]]) + 1 > test266151307() or ceil32(32 * mem[_8539 + mem[_8539]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8539 + ceil32(return_data.size) + ceil32(32 * mem[_8539 + mem[_8539]]) + 1
                                            mem[_8539 + ceil32(return_data.size)] = _8827
                                            require return_data.size >= _8683 + (32 * _8827) + 32
                                            mem[_8539 + ceil32(return_data.size) + 32 len 32 * _8827] = mem[_8539 + _8683 + 32 len 32 * _8827]
                                            if 0 >= _8827:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8539 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8539 + ceil32(return_data.size) + 32]
                                            if 1 >= _8827:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8539 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5751:
                                                    revert with 0, 17
                                                mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                                mem[_5755 + 132] = 0
                                                mem[_5755 + 164] = 160
                                                mem[_5755 + 260] = mem[_5755]
                                                idx = 0
                                                s = _5755 + 292
                                                t = _5755 + 32
                                                while idx < mem[_5755]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5755 + 196] = this.address
                                                mem[_5755 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8540 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8684 = mem[_8540]
                                                require mem[_8540] <= test266151307()
                                                require _8540 + mem[_8540] + 31 < _8540 + return_data.size
                                                _8828 = mem[_8540 + mem[_8540]]
                                                if mem[_8540 + mem[_8540]] > test266151307():
                                                    revert with 0, 65
                                                if _8540 + ceil32(return_data.size) + ceil32(32 * mem[_8540 + mem[_8540]]) + 1 > test266151307() or ceil32(32 * mem[_8540 + mem[_8540]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8540 + ceil32(return_data.size) + ceil32(32 * mem[_8540 + mem[_8540]]) + 1
                                                mem[_8540 + ceil32(return_data.size)] = _8828
                                                require return_data.size >= _8684 + (32 * _8828) + 32
                                                mem[_8540 + ceil32(return_data.size) + 32 len 32 * _8828] = mem[_8540 + _8684 + 32 len 32 * _8828]
                                                if 0 >= _8828:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8540 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8540 + ceil32(return_data.size) + 32]
                                                if 1 >= _8828:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8540 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5751:
                                                        revert with 0, 17
                                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5755 + 100] = ext_call.return_data[32] + _5751
                                                    mem[_5755 + 132] = 0
                                                    mem[_5755 + 164] = 160
                                                    mem[_5755 + 260] = mem[_5755]
                                                    idx = 0
                                                    s = _5755 + 292
                                                    t = _5755 + 32
                                                    while idx < mem[_5755]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5755 + 196] = this.address
                                                    mem[_5755 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8541 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8685 = mem[_8541]
                                                    require mem[_8541] <= test266151307()
                                                    require _8541 + mem[_8541] + 31 < _8541 + return_data.size
                                                    _8829 = mem[_8541 + mem[_8541]]
                                                    if mem[_8541 + mem[_8541]] > test266151307():
                                                        revert with 0, 65
                                                    if _8541 + ceil32(return_data.size) + ceil32(32 * mem[_8541 + mem[_8541]]) + 1 > test266151307() or ceil32(32 * mem[_8541 + mem[_8541]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8541 + ceil32(return_data.size) + ceil32(32 * mem[_8541 + mem[_8541]]) + 1
                                                    mem[_8541 + ceil32(return_data.size)] = _8829
                                                    require return_data.size >= _8685 + (32 * _8829) + 32
                                                    mem[_8541 + ceil32(return_data.size) + 32 len 32 * _8829] = mem[_8541 + _8685 + 32 len 32 * _8829]
                                                    if 0 >= _8829:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8541 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8541 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8829:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8541 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5751:
                                                        revert with 0, 17
                                                    mem[_5755 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5755 + 100] = ext_call.return_data[0] + _5751
                                                    mem[_5755 + 132] = 0
                                                    mem[_5755 + 164] = 160
                                                    mem[_5755 + 260] = mem[_5755]
                                                    idx = 0
                                                    s = _5755 + 292
                                                    t = _5755 + 32
                                                    while idx < mem[_5755]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5755 + 196] = this.address
                                                    mem[_5755 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5755 + (32 * mem[_5755]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8542 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8686 = mem[_8542]
                                                    require mem[_8542] <= test266151307()
                                                    require _8542 + mem[_8542] + 31 < _8542 + return_data.size
                                                    _8830 = mem[_8542 + mem[_8542]]
                                                    if mem[_8542 + mem[_8542]] > test266151307():
                                                        revert with 0, 65
                                                    if _8542 + ceil32(return_data.size) + ceil32(32 * mem[_8542 + mem[_8542]]) + 1 > test266151307() or ceil32(32 * mem[_8542 + mem[_8542]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8542 + ceil32(return_data.size) + ceil32(32 * mem[_8542 + mem[_8542]]) + 1
                                                    mem[_8542 + ceil32(return_data.size)] = _8830
                                                    require return_data.size >= _8686 + (32 * _8830) + 32
                                                    mem[_8542 + ceil32(return_data.size) + 32 len 32 * _8830] = mem[_8542 + _8686 + 32 len 32 * _8830]
                                                    if 0 >= _8830:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8542 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8542 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8830:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8542 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2986 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3017 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3017
                    require return_data.size >= _2986 + (32 * _3017) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3017] = mem[(4 * ceil32(return_data.size)) + _2986 + 224 len 32 * _3017]
                    if 1 >= _3017:
                        revert with 0, 50
                    _5752 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5756 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5756]:
                        revert with 0, 50
                    mem[_5756 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5756]:
                        revert with 0, 50
                    mem[_5756 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8543 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8687 = mem[_8543]
                                    require mem[_8543] <= test266151307()
                                    require _8543 + mem[_8543] + 31 < _8543 + return_data.size
                                    _8831 = mem[_8543 + mem[_8543]]
                                    if mem[_8543 + mem[_8543]] > test266151307():
                                        revert with 0, 65
                                    if _8543 + ceil32(return_data.size) + ceil32(32 * mem[_8543 + mem[_8543]]) + 1 > test266151307() or ceil32(32 * mem[_8543 + mem[_8543]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8543 + ceil32(return_data.size) + ceil32(32 * mem[_8543 + mem[_8543]]) + 1
                                    mem[_8543 + ceil32(return_data.size)] = _8831
                                    require return_data.size >= _8687 + (32 * _8831) + 32
                                    mem[_8543 + ceil32(return_data.size) + 32 len 32 * _8831] = mem[_8543 + _8687 + 32 len 32 * _8831]
                                    if 0 >= _8831:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8543 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8543 + ceil32(return_data.size) + 32]
                                    if 1 >= _8831:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8543 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8544 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8688 = mem[_8544]
                                    require mem[_8544] <= test266151307()
                                    require _8544 + mem[_8544] + 31 < _8544 + return_data.size
                                    _8832 = mem[_8544 + mem[_8544]]
                                    if mem[_8544 + mem[_8544]] > test266151307():
                                        revert with 0, 65
                                    if _8544 + ceil32(return_data.size) + ceil32(32 * mem[_8544 + mem[_8544]]) + 1 > test266151307() or ceil32(32 * mem[_8544 + mem[_8544]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8544 + ceil32(return_data.size) + ceil32(32 * mem[_8544 + mem[_8544]]) + 1
                                    mem[_8544 + ceil32(return_data.size)] = _8832
                                    require return_data.size >= _8688 + (32 * _8832) + 32
                                    mem[_8544 + ceil32(return_data.size) + 32 len 32 * _8832] = mem[_8544 + _8688 + 32 len 32 * _8832]
                                    if 0 >= _8832:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8544 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8544 + ceil32(return_data.size) + 32]
                                    if 1 >= _8832:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8544 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8545 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8689 = mem[_8545]
                                    require mem[_8545] <= test266151307()
                                    require _8545 + mem[_8545] + 31 < _8545 + return_data.size
                                    _8833 = mem[_8545 + mem[_8545]]
                                    if mem[_8545 + mem[_8545]] > test266151307():
                                        revert with 0, 65
                                    if _8545 + ceil32(return_data.size) + ceil32(32 * mem[_8545 + mem[_8545]]) + 1 > test266151307() or ceil32(32 * mem[_8545 + mem[_8545]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8545 + ceil32(return_data.size) + ceil32(32 * mem[_8545 + mem[_8545]]) + 1
                                    mem[_8545 + ceil32(return_data.size)] = _8833
                                    require return_data.size >= _8689 + (32 * _8833) + 32
                                    mem[_8545 + ceil32(return_data.size) + 32 len 32 * _8833] = mem[_8545 + _8689 + 32 len 32 * _8833]
                                    if 0 >= _8833:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8545 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8545 + ceil32(return_data.size) + 32]
                                    if 1 >= _8833:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8545 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8546 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8690 = mem[_8546]
                                        require mem[_8546] <= test266151307()
                                        require _8546 + mem[_8546] + 31 < _8546 + return_data.size
                                        _8834 = mem[_8546 + mem[_8546]]
                                        if mem[_8546 + mem[_8546]] > test266151307():
                                            revert with 0, 65
                                        if _8546 + ceil32(return_data.size) + ceil32(32 * mem[_8546 + mem[_8546]]) + 1 > test266151307() or ceil32(32 * mem[_8546 + mem[_8546]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8546 + ceil32(return_data.size) + ceil32(32 * mem[_8546 + mem[_8546]]) + 1
                                        mem[_8546 + ceil32(return_data.size)] = _8834
                                        require return_data.size >= _8690 + (32 * _8834) + 32
                                        mem[_8546 + ceil32(return_data.size) + 32 len 32 * _8834] = mem[_8546 + _8690 + 32 len 32 * _8834]
                                        if 0 >= _8834:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8546 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8546 + ceil32(return_data.size) + 32]
                                        if 1 >= _8834:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8546 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8547 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8691 = mem[_8547]
                                            require mem[_8547] <= test266151307()
                                            require _8547 + mem[_8547] + 31 < _8547 + return_data.size
                                            _8835 = mem[_8547 + mem[_8547]]
                                            if mem[_8547 + mem[_8547]] > test266151307():
                                                revert with 0, 65
                                            if _8547 + ceil32(return_data.size) + ceil32(32 * mem[_8547 + mem[_8547]]) + 1 > test266151307() or ceil32(32 * mem[_8547 + mem[_8547]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8547 + ceil32(return_data.size) + ceil32(32 * mem[_8547 + mem[_8547]]) + 1
                                            mem[_8547 + ceil32(return_data.size)] = _8835
                                            require return_data.size >= _8691 + (32 * _8835) + 32
                                            mem[_8547 + ceil32(return_data.size) + 32 len 32 * _8835] = mem[_8547 + _8691 + 32 len 32 * _8835]
                                            if 0 >= _8835:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8547 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8547 + ceil32(return_data.size) + 32]
                                            if 1 >= _8835:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8547 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8548 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8692 = mem[_8548]
                                            require mem[_8548] <= test266151307()
                                            require _8548 + mem[_8548] + 31 < _8548 + return_data.size
                                            _8836 = mem[_8548 + mem[_8548]]
                                            if mem[_8548 + mem[_8548]] > test266151307():
                                                revert with 0, 65
                                            if _8548 + ceil32(return_data.size) + ceil32(32 * mem[_8548 + mem[_8548]]) + 1 > test266151307() or ceil32(32 * mem[_8548 + mem[_8548]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8548 + ceil32(return_data.size) + ceil32(32 * mem[_8548 + mem[_8548]]) + 1
                                            mem[_8548 + ceil32(return_data.size)] = _8836
                                            require return_data.size >= _8692 + (32 * _8836) + 32
                                            mem[_8548 + ceil32(return_data.size) + 32 len 32 * _8836] = mem[_8548 + _8692 + 32 len 32 * _8836]
                                            if 0 >= _8836:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8548 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8548 + ceil32(return_data.size) + 32]
                                            if 1 >= _8836:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8548 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8549 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8693 = mem[_8549]
                                    require mem[_8549] <= test266151307()
                                    require _8549 + mem[_8549] + 31 < _8549 + return_data.size
                                    _8837 = mem[_8549 + mem[_8549]]
                                    if mem[_8549 + mem[_8549]] > test266151307():
                                        revert with 0, 65
                                    if _8549 + ceil32(return_data.size) + ceil32(32 * mem[_8549 + mem[_8549]]) + 1 > test266151307() or ceil32(32 * mem[_8549 + mem[_8549]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8549 + ceil32(return_data.size) + ceil32(32 * mem[_8549 + mem[_8549]]) + 1
                                    mem[_8549 + ceil32(return_data.size)] = _8837
                                    require return_data.size >= _8693 + (32 * _8837) + 32
                                    mem[_8549 + ceil32(return_data.size) + 32 len 32 * _8837] = mem[_8549 + _8693 + 32 len 32 * _8837]
                                    if 0 >= _8837:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8549 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8549 + ceil32(return_data.size) + 32]
                                    if 1 >= _8837:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8549 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8550 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8694 = mem[_8550]
                                    require mem[_8550] <= test266151307()
                                    require _8550 + mem[_8550] + 31 < _8550 + return_data.size
                                    _8838 = mem[_8550 + mem[_8550]]
                                    if mem[_8550 + mem[_8550]] > test266151307():
                                        revert with 0, 65
                                    if _8550 + ceil32(return_data.size) + ceil32(32 * mem[_8550 + mem[_8550]]) + 1 > test266151307() or ceil32(32 * mem[_8550 + mem[_8550]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8550 + ceil32(return_data.size) + ceil32(32 * mem[_8550 + mem[_8550]]) + 1
                                    mem[_8550 + ceil32(return_data.size)] = _8838
                                    require return_data.size >= _8694 + (32 * _8838) + 32
                                    mem[_8550 + ceil32(return_data.size) + 32 len 32 * _8838] = mem[_8550 + _8694 + 32 len 32 * _8838]
                                    if 0 >= _8838:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8550 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8550 + ceil32(return_data.size) + 32]
                                    if 1 >= _8838:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8550 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8551 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8695 = mem[_8551]
                                    require mem[_8551] <= test266151307()
                                    require _8551 + mem[_8551] + 31 < _8551 + return_data.size
                                    _8839 = mem[_8551 + mem[_8551]]
                                    if mem[_8551 + mem[_8551]] > test266151307():
                                        revert with 0, 65
                                    if _8551 + ceil32(return_data.size) + ceil32(32 * mem[_8551 + mem[_8551]]) + 1 > test266151307() or ceil32(32 * mem[_8551 + mem[_8551]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8551 + ceil32(return_data.size) + ceil32(32 * mem[_8551 + mem[_8551]]) + 1
                                    mem[_8551 + ceil32(return_data.size)] = _8839
                                    require return_data.size >= _8695 + (32 * _8839) + 32
                                    mem[_8551 + ceil32(return_data.size) + 32 len 32 * _8839] = mem[_8551 + _8695 + 32 len 32 * _8839]
                                    if 0 >= _8839:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8551 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8551 + ceil32(return_data.size) + 32]
                                    if 1 >= _8839:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8551 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8552 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8696 = mem[_8552]
                                        require mem[_8552] <= test266151307()
                                        require _8552 + mem[_8552] + 31 < _8552 + return_data.size
                                        _8840 = mem[_8552 + mem[_8552]]
                                        if mem[_8552 + mem[_8552]] > test266151307():
                                            revert with 0, 65
                                        if _8552 + ceil32(return_data.size) + ceil32(32 * mem[_8552 + mem[_8552]]) + 1 > test266151307() or ceil32(32 * mem[_8552 + mem[_8552]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8552 + ceil32(return_data.size) + ceil32(32 * mem[_8552 + mem[_8552]]) + 1
                                        mem[_8552 + ceil32(return_data.size)] = _8840
                                        require return_data.size >= _8696 + (32 * _8840) + 32
                                        mem[_8552 + ceil32(return_data.size) + 32 len 32 * _8840] = mem[_8552 + _8696 + 32 len 32 * _8840]
                                        if 0 >= _8840:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8552 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8552 + ceil32(return_data.size) + 32]
                                        if 1 >= _8840:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8552 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8553 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8697 = mem[_8553]
                                            require mem[_8553] <= test266151307()
                                            require _8553 + mem[_8553] + 31 < _8553 + return_data.size
                                            _8841 = mem[_8553 + mem[_8553]]
                                            if mem[_8553 + mem[_8553]] > test266151307():
                                                revert with 0, 65
                                            if _8553 + ceil32(return_data.size) + ceil32(32 * mem[_8553 + mem[_8553]]) + 1 > test266151307() or ceil32(32 * mem[_8553 + mem[_8553]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8553 + ceil32(return_data.size) + ceil32(32 * mem[_8553 + mem[_8553]]) + 1
                                            mem[_8553 + ceil32(return_data.size)] = _8841
                                            require return_data.size >= _8697 + (32 * _8841) + 32
                                            mem[_8553 + ceil32(return_data.size) + 32 len 32 * _8841] = mem[_8553 + _8697 + 32 len 32 * _8841]
                                            if 0 >= _8841:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8553 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8553 + ceil32(return_data.size) + 32]
                                            if 1 >= _8841:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8553 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8554 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8698 = mem[_8554]
                                            require mem[_8554] <= test266151307()
                                            require _8554 + mem[_8554] + 31 < _8554 + return_data.size
                                            _8842 = mem[_8554 + mem[_8554]]
                                            if mem[_8554 + mem[_8554]] > test266151307():
                                                revert with 0, 65
                                            if _8554 + ceil32(return_data.size) + ceil32(32 * mem[_8554 + mem[_8554]]) + 1 > test266151307() or ceil32(32 * mem[_8554 + mem[_8554]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8554 + ceil32(return_data.size) + ceil32(32 * mem[_8554 + mem[_8554]]) + 1
                                            mem[_8554 + ceil32(return_data.size)] = _8842
                                            require return_data.size >= _8698 + (32 * _8842) + 32
                                            mem[_8554 + ceil32(return_data.size) + 32 len 32 * _8842] = mem[_8554 + _8698 + 32 len 32 * _8842]
                                            if 0 >= _8842:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8554 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8554 + ceil32(return_data.size) + 32]
                                            if 1 >= _8842:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8554 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8555 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8699 = mem[_8555]
                                    require mem[_8555] <= test266151307()
                                    require _8555 + mem[_8555] + 31 < _8555 + return_data.size
                                    _8843 = mem[_8555 + mem[_8555]]
                                    if mem[_8555 + mem[_8555]] > test266151307():
                                        revert with 0, 65
                                    if _8555 + ceil32(return_data.size) + ceil32(32 * mem[_8555 + mem[_8555]]) + 1 > test266151307() or ceil32(32 * mem[_8555 + mem[_8555]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8555 + ceil32(return_data.size) + ceil32(32 * mem[_8555 + mem[_8555]]) + 1
                                    mem[_8555 + ceil32(return_data.size)] = _8843
                                    require return_data.size >= _8699 + (32 * _8843) + 32
                                    mem[_8555 + ceil32(return_data.size) + 32 len 32 * _8843] = mem[_8555 + _8699 + 32 len 32 * _8843]
                                    if 0 >= _8843:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8555 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8555 + ceil32(return_data.size) + 32]
                                    if 1 >= _8843:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8555 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8556 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8700 = mem[_8556]
                                    require mem[_8556] <= test266151307()
                                    require _8556 + mem[_8556] + 31 < _8556 + return_data.size
                                    _8844 = mem[_8556 + mem[_8556]]
                                    if mem[_8556 + mem[_8556]] > test266151307():
                                        revert with 0, 65
                                    if _8556 + ceil32(return_data.size) + ceil32(32 * mem[_8556 + mem[_8556]]) + 1 > test266151307() or ceil32(32 * mem[_8556 + mem[_8556]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8556 + ceil32(return_data.size) + ceil32(32 * mem[_8556 + mem[_8556]]) + 1
                                    mem[_8556 + ceil32(return_data.size)] = _8844
                                    require return_data.size >= _8700 + (32 * _8844) + 32
                                    mem[_8556 + ceil32(return_data.size) + 32 len 32 * _8844] = mem[_8556 + _8700 + 32 len 32 * _8844]
                                    if 0 >= _8844:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8556 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8556 + ceil32(return_data.size) + 32]
                                    if 1 >= _8844:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8556 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5752:
                                        revert with 0, 17
                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                    mem[_5756 + 132] = 0
                                    mem[_5756 + 164] = 160
                                    mem[_5756 + 260] = mem[_5756]
                                    idx = 0
                                    s = _5756 + 292
                                    t = _5756 + 32
                                    while idx < mem[_5756]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5756 + 196] = this.address
                                    mem[_5756 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8557 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8701 = mem[_8557]
                                    require mem[_8557] <= test266151307()
                                    require _8557 + mem[_8557] + 31 < _8557 + return_data.size
                                    _8845 = mem[_8557 + mem[_8557]]
                                    if mem[_8557 + mem[_8557]] > test266151307():
                                        revert with 0, 65
                                    if _8557 + ceil32(return_data.size) + ceil32(32 * mem[_8557 + mem[_8557]]) + 1 > test266151307() or ceil32(32 * mem[_8557 + mem[_8557]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8557 + ceil32(return_data.size) + ceil32(32 * mem[_8557 + mem[_8557]]) + 1
                                    mem[_8557 + ceil32(return_data.size)] = _8845
                                    require return_data.size >= _8701 + (32 * _8845) + 32
                                    mem[_8557 + ceil32(return_data.size) + 32 len 32 * _8845] = mem[_8557 + _8701 + 32 len 32 * _8845]
                                    if 0 >= _8845:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8557 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8557 + ceil32(return_data.size) + 32]
                                    if 1 >= _8845:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8557 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8558 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8702 = mem[_8558]
                                        require mem[_8558] <= test266151307()
                                        require _8558 + mem[_8558] + 31 < _8558 + return_data.size
                                        _8846 = mem[_8558 + mem[_8558]]
                                        if mem[_8558 + mem[_8558]] > test266151307():
                                            revert with 0, 65
                                        if _8558 + ceil32(return_data.size) + ceil32(32 * mem[_8558 + mem[_8558]]) + 1 > test266151307() or ceil32(32 * mem[_8558 + mem[_8558]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8558 + ceil32(return_data.size) + ceil32(32 * mem[_8558 + mem[_8558]]) + 1
                                        mem[_8558 + ceil32(return_data.size)] = _8846
                                        require return_data.size >= _8702 + (32 * _8846) + 32
                                        mem[_8558 + ceil32(return_data.size) + 32 len 32 * _8846] = mem[_8558 + _8702 + 32 len 32 * _8846]
                                        if 0 >= _8846:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8558 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8558 + ceil32(return_data.size) + 32]
                                        if 1 >= _8846:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8558 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8559 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8703 = mem[_8559]
                                            require mem[_8559] <= test266151307()
                                            require _8559 + mem[_8559] + 31 < _8559 + return_data.size
                                            _8847 = mem[_8559 + mem[_8559]]
                                            if mem[_8559 + mem[_8559]] > test266151307():
                                                revert with 0, 65
                                            if _8559 + ceil32(return_data.size) + ceil32(32 * mem[_8559 + mem[_8559]]) + 1 > test266151307() or ceil32(32 * mem[_8559 + mem[_8559]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8559 + ceil32(return_data.size) + ceil32(32 * mem[_8559 + mem[_8559]]) + 1
                                            mem[_8559 + ceil32(return_data.size)] = _8847
                                            require return_data.size >= _8703 + (32 * _8847) + 32
                                            mem[_8559 + ceil32(return_data.size) + 32 len 32 * _8847] = mem[_8559 + _8703 + 32 len 32 * _8847]
                                            if 0 >= _8847:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8559 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8559 + ceil32(return_data.size) + 32]
                                            if 1 >= _8847:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8559 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8560 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8704 = mem[_8560]
                                            require mem[_8560] <= test266151307()
                                            require _8560 + mem[_8560] + 31 < _8560 + return_data.size
                                            _8848 = mem[_8560 + mem[_8560]]
                                            if mem[_8560 + mem[_8560]] > test266151307():
                                                revert with 0, 65
                                            if _8560 + ceil32(return_data.size) + ceil32(32 * mem[_8560 + mem[_8560]]) + 1 > test266151307() or ceil32(32 * mem[_8560 + mem[_8560]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8560 + ceil32(return_data.size) + ceil32(32 * mem[_8560 + mem[_8560]]) + 1
                                            mem[_8560 + ceil32(return_data.size)] = _8848
                                            require return_data.size >= _8704 + (32 * _8848) + 32
                                            mem[_8560 + ceil32(return_data.size) + 32 len 32 * _8848] = mem[_8560 + _8704 + 32 len 32 * _8848]
                                            if 0 >= _8848:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8560 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8560 + ceil32(return_data.size) + 32]
                                            if 1 >= _8848:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8560 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8561 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8705 = mem[_8561]
                                        require mem[_8561] <= test266151307()
                                        require _8561 + mem[_8561] + 31 < _8561 + return_data.size
                                        _8849 = mem[_8561 + mem[_8561]]
                                        if mem[_8561 + mem[_8561]] > test266151307():
                                            revert with 0, 65
                                        if _8561 + ceil32(return_data.size) + ceil32(32 * mem[_8561 + mem[_8561]]) + 1 > test266151307() or ceil32(32 * mem[_8561 + mem[_8561]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8561 + ceil32(return_data.size) + ceil32(32 * mem[_8561 + mem[_8561]]) + 1
                                        mem[_8561 + ceil32(return_data.size)] = _8849
                                        require return_data.size >= _8705 + (32 * _8849) + 32
                                        mem[_8561 + ceil32(return_data.size) + 32 len 32 * _8849] = mem[_8561 + _8705 + 32 len 32 * _8849]
                                        if 0 >= _8849:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8561 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8561 + ceil32(return_data.size) + 32]
                                        if 1 >= _8849:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8561 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8562 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8706 = mem[_8562]
                                        require mem[_8562] <= test266151307()
                                        require _8562 + mem[_8562] + 31 < _8562 + return_data.size
                                        _8850 = mem[_8562 + mem[_8562]]
                                        if mem[_8562 + mem[_8562]] > test266151307():
                                            revert with 0, 65
                                        if _8562 + ceil32(return_data.size) + ceil32(32 * mem[_8562 + mem[_8562]]) + 1 > test266151307() or ceil32(32 * mem[_8562 + mem[_8562]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8562 + ceil32(return_data.size) + ceil32(32 * mem[_8562 + mem[_8562]]) + 1
                                        mem[_8562 + ceil32(return_data.size)] = _8850
                                        require return_data.size >= _8706 + (32 * _8850) + 32
                                        mem[_8562 + ceil32(return_data.size) + 32 len 32 * _8850] = mem[_8562 + _8706 + 32 len 32 * _8850]
                                        if 0 >= _8850:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8562 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8562 + ceil32(return_data.size) + 32]
                                        if 1 >= _8850:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8562 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5752:
                                            revert with 0, 17
                                        mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                        mem[_5756 + 132] = 0
                                        mem[_5756 + 164] = 160
                                        mem[_5756 + 260] = mem[_5756]
                                        idx = 0
                                        s = _5756 + 292
                                        t = _5756 + 32
                                        while idx < mem[_5756]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5756 + 196] = this.address
                                        mem[_5756 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8563 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8707 = mem[_8563]
                                        require mem[_8563] <= test266151307()
                                        require _8563 + mem[_8563] + 31 < _8563 + return_data.size
                                        _8851 = mem[_8563 + mem[_8563]]
                                        if mem[_8563 + mem[_8563]] > test266151307():
                                            revert with 0, 65
                                        if _8563 + ceil32(return_data.size) + ceil32(32 * mem[_8563 + mem[_8563]]) + 1 > test266151307() or ceil32(32 * mem[_8563 + mem[_8563]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8563 + ceil32(return_data.size) + ceil32(32 * mem[_8563 + mem[_8563]]) + 1
                                        mem[_8563 + ceil32(return_data.size)] = _8851
                                        require return_data.size >= _8707 + (32 * _8851) + 32
                                        mem[_8563 + ceil32(return_data.size) + 32 len 32 * _8851] = mem[_8563 + _8707 + 32 len 32 * _8851]
                                        if 0 >= _8851:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8563 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8563 + ceil32(return_data.size) + 32]
                                        if 1 >= _8851:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8563 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8564 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8708 = mem[_8564]
                                            require mem[_8564] <= test266151307()
                                            require _8564 + mem[_8564] + 31 < _8564 + return_data.size
                                            _8852 = mem[_8564 + mem[_8564]]
                                            if mem[_8564 + mem[_8564]] > test266151307():
                                                revert with 0, 65
                                            if _8564 + ceil32(return_data.size) + ceil32(32 * mem[_8564 + mem[_8564]]) + 1 > test266151307() or ceil32(32 * mem[_8564 + mem[_8564]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8564 + ceil32(return_data.size) + ceil32(32 * mem[_8564 + mem[_8564]]) + 1
                                            mem[_8564 + ceil32(return_data.size)] = _8852
                                            require return_data.size >= _8708 + (32 * _8852) + 32
                                            mem[_8564 + ceil32(return_data.size) + 32 len 32 * _8852] = mem[_8564 + _8708 + 32 len 32 * _8852]
                                            if 0 >= _8852:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8564 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8564 + ceil32(return_data.size) + 32]
                                            if 1 >= _8852:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8564 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5752:
                                                    revert with 0, 17
                                                mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                                mem[_5756 + 132] = 0
                                                mem[_5756 + 164] = 160
                                                mem[_5756 + 260] = mem[_5756]
                                                idx = 0
                                                s = _5756 + 292
                                                t = _5756 + 32
                                                while idx < mem[_5756]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5756 + 196] = this.address
                                                mem[_5756 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8565 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8709 = mem[_8565]
                                                require mem[_8565] <= test266151307()
                                                require _8565 + mem[_8565] + 31 < _8565 + return_data.size
                                                _8853 = mem[_8565 + mem[_8565]]
                                                if mem[_8565 + mem[_8565]] > test266151307():
                                                    revert with 0, 65
                                                if _8565 + ceil32(return_data.size) + ceil32(32 * mem[_8565 + mem[_8565]]) + 1 > test266151307() or ceil32(32 * mem[_8565 + mem[_8565]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8565 + ceil32(return_data.size) + ceil32(32 * mem[_8565 + mem[_8565]]) + 1
                                                mem[_8565 + ceil32(return_data.size)] = _8853
                                                require return_data.size >= _8709 + (32 * _8853) + 32
                                                mem[_8565 + ceil32(return_data.size) + 32 len 32 * _8853] = mem[_8565 + _8709 + 32 len 32 * _8853]
                                                if 0 >= _8853:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8565 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8565 + ceil32(return_data.size) + 32]
                                                if 1 >= _8853:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8565 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5752:
                                                    revert with 0, 17
                                                mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                                mem[_5756 + 132] = 0
                                                mem[_5756 + 164] = 160
                                                mem[_5756 + 260] = mem[_5756]
                                                idx = 0
                                                s = _5756 + 292
                                                t = _5756 + 32
                                                while idx < mem[_5756]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5756 + 196] = this.address
                                                mem[_5756 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8566 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8710 = mem[_8566]
                                                require mem[_8566] <= test266151307()
                                                require _8566 + mem[_8566] + 31 < _8566 + return_data.size
                                                _8854 = mem[_8566 + mem[_8566]]
                                                if mem[_8566 + mem[_8566]] > test266151307():
                                                    revert with 0, 65
                                                if _8566 + ceil32(return_data.size) + ceil32(32 * mem[_8566 + mem[_8566]]) + 1 > test266151307() or ceil32(32 * mem[_8566 + mem[_8566]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8566 + ceil32(return_data.size) + ceil32(32 * mem[_8566 + mem[_8566]]) + 1
                                                mem[_8566 + ceil32(return_data.size)] = _8854
                                                require return_data.size >= _8710 + (32 * _8854) + 32
                                                mem[_8566 + ceil32(return_data.size) + 32 len 32 * _8854] = mem[_8566 + _8710 + 32 len 32 * _8854]
                                                if 0 >= _8854:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8566 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8566 + ceil32(return_data.size) + 32]
                                                if 1 >= _8854:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8566 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8567 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8711 = mem[_8567]
                                            require mem[_8567] <= test266151307()
                                            require _8567 + mem[_8567] + 31 < _8567 + return_data.size
                                            _8855 = mem[_8567 + mem[_8567]]
                                            if mem[_8567 + mem[_8567]] > test266151307():
                                                revert with 0, 65
                                            if _8567 + ceil32(return_data.size) + ceil32(32 * mem[_8567 + mem[_8567]]) + 1 > test266151307() or ceil32(32 * mem[_8567 + mem[_8567]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8567 + ceil32(return_data.size) + ceil32(32 * mem[_8567 + mem[_8567]]) + 1
                                            mem[_8567 + ceil32(return_data.size)] = _8855
                                            require return_data.size >= _8711 + (32 * _8855) + 32
                                            mem[_8567 + ceil32(return_data.size) + 32 len 32 * _8855] = mem[_8567 + _8711 + 32 len 32 * _8855]
                                            if 0 >= _8855:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8567 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8567 + ceil32(return_data.size) + 32]
                                            if 1 >= _8855:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8567 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8568 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8712 = mem[_8568]
                                            require mem[_8568] <= test266151307()
                                            require _8568 + mem[_8568] + 31 < _8568 + return_data.size
                                            _8856 = mem[_8568 + mem[_8568]]
                                            if mem[_8568 + mem[_8568]] > test266151307():
                                                revert with 0, 65
                                            if _8568 + ceil32(return_data.size) + ceil32(32 * mem[_8568 + mem[_8568]]) + 1 > test266151307() or ceil32(32 * mem[_8568 + mem[_8568]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8568 + ceil32(return_data.size) + ceil32(32 * mem[_8568 + mem[_8568]]) + 1
                                            mem[_8568 + ceil32(return_data.size)] = _8856
                                            require return_data.size >= _8712 + (32 * _8856) + 32
                                            mem[_8568 + ceil32(return_data.size) + 32 len 32 * _8856] = mem[_8568 + _8712 + 32 len 32 * _8856]
                                            if 0 >= _8856:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8568 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8568 + ceil32(return_data.size) + 32]
                                            if 1 >= _8856:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8568 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8569 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8713 = mem[_8569]
                                            require mem[_8569] <= test266151307()
                                            require _8569 + mem[_8569] + 31 < _8569 + return_data.size
                                            _8857 = mem[_8569 + mem[_8569]]
                                            if mem[_8569 + mem[_8569]] > test266151307():
                                                revert with 0, 65
                                            if _8569 + ceil32(return_data.size) + ceil32(32 * mem[_8569 + mem[_8569]]) + 1 > test266151307() or ceil32(32 * mem[_8569 + mem[_8569]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8569 + ceil32(return_data.size) + ceil32(32 * mem[_8569 + mem[_8569]]) + 1
                                            mem[_8569 + ceil32(return_data.size)] = _8857
                                            require return_data.size >= _8713 + (32 * _8857) + 32
                                            mem[_8569 + ceil32(return_data.size) + 32 len 32 * _8857] = mem[_8569 + _8713 + 32 len 32 * _8857]
                                            if 0 >= _8857:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8569 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8569 + ceil32(return_data.size) + 32]
                                            if 1 >= _8857:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8569 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5752:
                                                    revert with 0, 17
                                                mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                                mem[_5756 + 132] = 0
                                                mem[_5756 + 164] = 160
                                                mem[_5756 + 260] = mem[_5756]
                                                idx = 0
                                                s = _5756 + 292
                                                t = _5756 + 32
                                                while idx < mem[_5756]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5756 + 196] = this.address
                                                mem[_5756 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8570 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8714 = mem[_8570]
                                                require mem[_8570] <= test266151307()
                                                require _8570 + mem[_8570] + 31 < _8570 + return_data.size
                                                _8858 = mem[_8570 + mem[_8570]]
                                                if mem[_8570 + mem[_8570]] > test266151307():
                                                    revert with 0, 65
                                                if _8570 + ceil32(return_data.size) + ceil32(32 * mem[_8570 + mem[_8570]]) + 1 > test266151307() or ceil32(32 * mem[_8570 + mem[_8570]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8570 + ceil32(return_data.size) + ceil32(32 * mem[_8570 + mem[_8570]]) + 1
                                                mem[_8570 + ceil32(return_data.size)] = _8858
                                                require return_data.size >= _8714 + (32 * _8858) + 32
                                                mem[_8570 + ceil32(return_data.size) + 32 len 32 * _8858] = mem[_8570 + _8714 + 32 len 32 * _8858]
                                                if 0 >= _8858:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8570 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8570 + ceil32(return_data.size) + 32]
                                                if 1 >= _8858:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8570 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5752:
                                                        revert with 0, 17
                                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                                    mem[_5756 + 132] = 0
                                                    mem[_5756 + 164] = 160
                                                    mem[_5756 + 260] = mem[_5756]
                                                    idx = 0
                                                    s = _5756 + 292
                                                    t = _5756 + 32
                                                    while idx < mem[_5756]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5756 + 196] = this.address
                                                    mem[_5756 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8571 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8715 = mem[_8571]
                                                    require mem[_8571] <= test266151307()
                                                    require _8571 + mem[_8571] + 31 < _8571 + return_data.size
                                                    _8859 = mem[_8571 + mem[_8571]]
                                                    if mem[_8571 + mem[_8571]] > test266151307():
                                                        revert with 0, 65
                                                    if _8571 + ceil32(return_data.size) + ceil32(32 * mem[_8571 + mem[_8571]]) + 1 > test266151307() or ceil32(32 * mem[_8571 + mem[_8571]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8571 + ceil32(return_data.size) + ceil32(32 * mem[_8571 + mem[_8571]]) + 1
                                                    mem[_8571 + ceil32(return_data.size)] = _8859
                                                    require return_data.size >= _8715 + (32 * _8859) + 32
                                                    mem[_8571 + ceil32(return_data.size) + 32 len 32 * _8859] = mem[_8571 + _8715 + 32 len 32 * _8859]
                                                    if 0 >= _8859:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8571 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8571 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8859:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8571 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5752:
                                                        revert with 0, 17
                                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                                    mem[_5756 + 132] = 0
                                                    mem[_5756 + 164] = 160
                                                    mem[_5756 + 260] = mem[_5756]
                                                    idx = 0
                                                    s = _5756 + 292
                                                    t = _5756 + 32
                                                    while idx < mem[_5756]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5756 + 196] = this.address
                                                    mem[_5756 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8572 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8716 = mem[_8572]
                                                    require mem[_8572] <= test266151307()
                                                    require _8572 + mem[_8572] + 31 < _8572 + return_data.size
                                                    _8860 = mem[_8572 + mem[_8572]]
                                                    if mem[_8572 + mem[_8572]] > test266151307():
                                                        revert with 0, 65
                                                    if _8572 + ceil32(return_data.size) + ceil32(32 * mem[_8572 + mem[_8572]]) + 1 > test266151307() or ceil32(32 * mem[_8572 + mem[_8572]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8572 + ceil32(return_data.size) + ceil32(32 * mem[_8572 + mem[_8572]]) + 1
                                                    mem[_8572 + ceil32(return_data.size)] = _8860
                                                    require return_data.size >= _8716 + (32 * _8860) + 32
                                                    mem[_8572 + ceil32(return_data.size) + 32 len 32 * _8860] = mem[_8572 + _8716 + 32 len 32 * _8860]
                                                    if 0 >= _8860:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8572 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8572 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8860:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8572 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8573 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8717 = mem[_8573]
                                            require mem[_8573] <= test266151307()
                                            require _8573 + mem[_8573] + 31 < _8573 + return_data.size
                                            _8861 = mem[_8573 + mem[_8573]]
                                            if mem[_8573 + mem[_8573]] > test266151307():
                                                revert with 0, 65
                                            if _8573 + ceil32(return_data.size) + ceil32(32 * mem[_8573 + mem[_8573]]) + 1 > test266151307() or ceil32(32 * mem[_8573 + mem[_8573]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8573 + ceil32(return_data.size) + ceil32(32 * mem[_8573 + mem[_8573]]) + 1
                                            mem[_8573 + ceil32(return_data.size)] = _8861
                                            require return_data.size >= _8717 + (32 * _8861) + 32
                                            mem[_8573 + ceil32(return_data.size) + 32 len 32 * _8861] = mem[_8573 + _8717 + 32 len 32 * _8861]
                                            if 0 >= _8861:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8573 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8573 + ceil32(return_data.size) + 32]
                                            if 1 >= _8861:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8573 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8574 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8718 = mem[_8574]
                                            require mem[_8574] <= test266151307()
                                            require _8574 + mem[_8574] + 31 < _8574 + return_data.size
                                            _8862 = mem[_8574 + mem[_8574]]
                                            if mem[_8574 + mem[_8574]] > test266151307():
                                                revert with 0, 65
                                            if _8574 + ceil32(return_data.size) + ceil32(32 * mem[_8574 + mem[_8574]]) + 1 > test266151307() or ceil32(32 * mem[_8574 + mem[_8574]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8574 + ceil32(return_data.size) + ceil32(32 * mem[_8574 + mem[_8574]]) + 1
                                            mem[_8574 + ceil32(return_data.size)] = _8862
                                            require return_data.size >= _8718 + (32 * _8862) + 32
                                            mem[_8574 + ceil32(return_data.size) + 32 len 32 * _8862] = mem[_8574 + _8718 + 32 len 32 * _8862]
                                            if 0 >= _8862:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8574 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8574 + ceil32(return_data.size) + 32]
                                            if 1 >= _8862:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8574 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5752:
                                                revert with 0, 17
                                            mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                            mem[_5756 + 132] = 0
                                            mem[_5756 + 164] = 160
                                            mem[_5756 + 260] = mem[_5756]
                                            idx = 0
                                            s = _5756 + 292
                                            t = _5756 + 32
                                            while idx < mem[_5756]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5756 + 196] = this.address
                                            mem[_5756 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8575 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8719 = mem[_8575]
                                            require mem[_8575] <= test266151307()
                                            require _8575 + mem[_8575] + 31 < _8575 + return_data.size
                                            _8863 = mem[_8575 + mem[_8575]]
                                            if mem[_8575 + mem[_8575]] > test266151307():
                                                revert with 0, 65
                                            if _8575 + ceil32(return_data.size) + ceil32(32 * mem[_8575 + mem[_8575]]) + 1 > test266151307() or ceil32(32 * mem[_8575 + mem[_8575]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8575 + ceil32(return_data.size) + ceil32(32 * mem[_8575 + mem[_8575]]) + 1
                                            mem[_8575 + ceil32(return_data.size)] = _8863
                                            require return_data.size >= _8719 + (32 * _8863) + 32
                                            mem[_8575 + ceil32(return_data.size) + 32 len 32 * _8863] = mem[_8575 + _8719 + 32 len 32 * _8863]
                                            if 0 >= _8863:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8575 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8575 + ceil32(return_data.size) + 32]
                                            if 1 >= _8863:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8575 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5752:
                                                    revert with 0, 17
                                                mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                                mem[_5756 + 132] = 0
                                                mem[_5756 + 164] = 160
                                                mem[_5756 + 260] = mem[_5756]
                                                idx = 0
                                                s = _5756 + 292
                                                t = _5756 + 32
                                                while idx < mem[_5756]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5756 + 196] = this.address
                                                mem[_5756 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8576 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8720 = mem[_8576]
                                                require mem[_8576] <= test266151307()
                                                require _8576 + mem[_8576] + 31 < _8576 + return_data.size
                                                _8864 = mem[_8576 + mem[_8576]]
                                                if mem[_8576 + mem[_8576]] > test266151307():
                                                    revert with 0, 65
                                                if _8576 + ceil32(return_data.size) + ceil32(32 * mem[_8576 + mem[_8576]]) + 1 > test266151307() or ceil32(32 * mem[_8576 + mem[_8576]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8576 + ceil32(return_data.size) + ceil32(32 * mem[_8576 + mem[_8576]]) + 1
                                                mem[_8576 + ceil32(return_data.size)] = _8864
                                                require return_data.size >= _8720 + (32 * _8864) + 32
                                                mem[_8576 + ceil32(return_data.size) + 32 len 32 * _8864] = mem[_8576 + _8720 + 32 len 32 * _8864]
                                                if 0 >= _8864:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8576 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8576 + ceil32(return_data.size) + 32]
                                                if 1 >= _8864:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8576 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5752:
                                                        revert with 0, 17
                                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5756 + 100] = ext_call.return_data[32] + _5752
                                                    mem[_5756 + 132] = 0
                                                    mem[_5756 + 164] = 160
                                                    mem[_5756 + 260] = mem[_5756]
                                                    idx = 0
                                                    s = _5756 + 292
                                                    t = _5756 + 32
                                                    while idx < mem[_5756]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5756 + 196] = this.address
                                                    mem[_5756 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8577 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8721 = mem[_8577]
                                                    require mem[_8577] <= test266151307()
                                                    require _8577 + mem[_8577] + 31 < _8577 + return_data.size
                                                    _8865 = mem[_8577 + mem[_8577]]
                                                    if mem[_8577 + mem[_8577]] > test266151307():
                                                        revert with 0, 65
                                                    if _8577 + ceil32(return_data.size) + ceil32(32 * mem[_8577 + mem[_8577]]) + 1 > test266151307() or ceil32(32 * mem[_8577 + mem[_8577]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8577 + ceil32(return_data.size) + ceil32(32 * mem[_8577 + mem[_8577]]) + 1
                                                    mem[_8577 + ceil32(return_data.size)] = _8865
                                                    require return_data.size >= _8721 + (32 * _8865) + 32
                                                    mem[_8577 + ceil32(return_data.size) + 32 len 32 * _8865] = mem[_8577 + _8721 + 32 len 32 * _8865]
                                                    if 0 >= _8865:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8577 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8577 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8865:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8577 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5752:
                                                        revert with 0, 17
                                                    mem[_5756 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5756 + 100] = ext_call.return_data[0] + _5752
                                                    mem[_5756 + 132] = 0
                                                    mem[_5756 + 164] = 160
                                                    mem[_5756 + 260] = mem[_5756]
                                                    idx = 0
                                                    s = _5756 + 292
                                                    t = _5756 + 32
                                                    while idx < mem[_5756]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5756 + 196] = this.address
                                                    mem[_5756 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5756 + (32 * mem[_5756]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8578 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8722 = mem[_8578]
                                                    require mem[_8578] <= test266151307()
                                                    require _8578 + mem[_8578] + 31 < _8578 + return_data.size
                                                    _8866 = mem[_8578 + mem[_8578]]
                                                    if mem[_8578 + mem[_8578]] > test266151307():
                                                        revert with 0, 65
                                                    if _8578 + ceil32(return_data.size) + ceil32(32 * mem[_8578 + mem[_8578]]) + 1 > test266151307() or ceil32(32 * mem[_8578 + mem[_8578]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8578 + ceil32(return_data.size) + ceil32(32 * mem[_8578 + mem[_8578]]) + 1
                                                    mem[_8578 + ceil32(return_data.size)] = _8866
                                                    require return_data.size >= _8722 + (32 * _8866) + 32
                                                    mem[_8578 + ceil32(return_data.size) + 32 len 32 * _8866] = mem[_8578 + _8722 + 32 len 32 * _8866]
                                                    if 0 >= _8866:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8578 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8578 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8866:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8578 + ceil32(return_data.size) + 64]
            else:
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2987 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3018 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3018
                    require return_data.size >= _2987 + (32 * _3018) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3018] = mem[(4 * ceil32(return_data.size)) + _2987 + 224 len 32 * _3018]
                    if 1 >= _3018:
                        revert with 0, 50
                    _5753 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5757 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5757]:
                        revert with 0, 50
                    mem[_5757 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5757]:
                        revert with 0, 50
                    mem[_5757 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8579 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8723 = mem[_8579]
                                    require mem[_8579] <= test266151307()
                                    require _8579 + mem[_8579] + 31 < _8579 + return_data.size
                                    _8867 = mem[_8579 + mem[_8579]]
                                    if mem[_8579 + mem[_8579]] > test266151307():
                                        revert with 0, 65
                                    if _8579 + ceil32(return_data.size) + ceil32(32 * mem[_8579 + mem[_8579]]) + 1 > test266151307() or ceil32(32 * mem[_8579 + mem[_8579]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8579 + ceil32(return_data.size) + ceil32(32 * mem[_8579 + mem[_8579]]) + 1
                                    mem[_8579 + ceil32(return_data.size)] = _8867
                                    require return_data.size >= _8723 + (32 * _8867) + 32
                                    mem[_8579 + ceil32(return_data.size) + 32 len 32 * _8867] = mem[_8579 + _8723 + 32 len 32 * _8867]
                                    if 0 >= _8867:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8579 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8579 + ceil32(return_data.size) + 32]
                                    if 1 >= _8867:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8579 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8580 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8724 = mem[_8580]
                                    require mem[_8580] <= test266151307()
                                    require _8580 + mem[_8580] + 31 < _8580 + return_data.size
                                    _8868 = mem[_8580 + mem[_8580]]
                                    if mem[_8580 + mem[_8580]] > test266151307():
                                        revert with 0, 65
                                    if _8580 + ceil32(return_data.size) + ceil32(32 * mem[_8580 + mem[_8580]]) + 1 > test266151307() or ceil32(32 * mem[_8580 + mem[_8580]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8580 + ceil32(return_data.size) + ceil32(32 * mem[_8580 + mem[_8580]]) + 1
                                    mem[_8580 + ceil32(return_data.size)] = _8868
                                    require return_data.size >= _8724 + (32 * _8868) + 32
                                    mem[_8580 + ceil32(return_data.size) + 32 len 32 * _8868] = mem[_8580 + _8724 + 32 len 32 * _8868]
                                    if 0 >= _8868:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8580 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8580 + ceil32(return_data.size) + 32]
                                    if 1 >= _8868:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8580 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8581 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8725 = mem[_8581]
                                    require mem[_8581] <= test266151307()
                                    require _8581 + mem[_8581] + 31 < _8581 + return_data.size
                                    _8869 = mem[_8581 + mem[_8581]]
                                    if mem[_8581 + mem[_8581]] > test266151307():
                                        revert with 0, 65
                                    if _8581 + ceil32(return_data.size) + ceil32(32 * mem[_8581 + mem[_8581]]) + 1 > test266151307() or ceil32(32 * mem[_8581 + mem[_8581]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8581 + ceil32(return_data.size) + ceil32(32 * mem[_8581 + mem[_8581]]) + 1
                                    mem[_8581 + ceil32(return_data.size)] = _8869
                                    require return_data.size >= _8725 + (32 * _8869) + 32
                                    mem[_8581 + ceil32(return_data.size) + 32 len 32 * _8869] = mem[_8581 + _8725 + 32 len 32 * _8869]
                                    if 0 >= _8869:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8581 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8581 + ceil32(return_data.size) + 32]
                                    if 1 >= _8869:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8581 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8582 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8726 = mem[_8582]
                                        require mem[_8582] <= test266151307()
                                        require _8582 + mem[_8582] + 31 < _8582 + return_data.size
                                        _8870 = mem[_8582 + mem[_8582]]
                                        if mem[_8582 + mem[_8582]] > test266151307():
                                            revert with 0, 65
                                        if _8582 + ceil32(return_data.size) + ceil32(32 * mem[_8582 + mem[_8582]]) + 1 > test266151307() or ceil32(32 * mem[_8582 + mem[_8582]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8582 + ceil32(return_data.size) + ceil32(32 * mem[_8582 + mem[_8582]]) + 1
                                        mem[_8582 + ceil32(return_data.size)] = _8870
                                        require return_data.size >= _8726 + (32 * _8870) + 32
                                        mem[_8582 + ceil32(return_data.size) + 32 len 32 * _8870] = mem[_8582 + _8726 + 32 len 32 * _8870]
                                        if 0 >= _8870:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8582 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8582 + ceil32(return_data.size) + 32]
                                        if 1 >= _8870:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8582 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8583 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8727 = mem[_8583]
                                            require mem[_8583] <= test266151307()
                                            require _8583 + mem[_8583] + 31 < _8583 + return_data.size
                                            _8871 = mem[_8583 + mem[_8583]]
                                            if mem[_8583 + mem[_8583]] > test266151307():
                                                revert with 0, 65
                                            if _8583 + ceil32(return_data.size) + ceil32(32 * mem[_8583 + mem[_8583]]) + 1 > test266151307() or ceil32(32 * mem[_8583 + mem[_8583]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8583 + ceil32(return_data.size) + ceil32(32 * mem[_8583 + mem[_8583]]) + 1
                                            mem[_8583 + ceil32(return_data.size)] = _8871
                                            require return_data.size >= _8727 + (32 * _8871) + 32
                                            mem[_8583 + ceil32(return_data.size) + 32 len 32 * _8871] = mem[_8583 + _8727 + 32 len 32 * _8871]
                                            if 0 >= _8871:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8583 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8583 + ceil32(return_data.size) + 32]
                                            if 1 >= _8871:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8583 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8584 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8728 = mem[_8584]
                                            require mem[_8584] <= test266151307()
                                            require _8584 + mem[_8584] + 31 < _8584 + return_data.size
                                            _8872 = mem[_8584 + mem[_8584]]
                                            if mem[_8584 + mem[_8584]] > test266151307():
                                                revert with 0, 65
                                            if _8584 + ceil32(return_data.size) + ceil32(32 * mem[_8584 + mem[_8584]]) + 1 > test266151307() or ceil32(32 * mem[_8584 + mem[_8584]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8584 + ceil32(return_data.size) + ceil32(32 * mem[_8584 + mem[_8584]]) + 1
                                            mem[_8584 + ceil32(return_data.size)] = _8872
                                            require return_data.size >= _8728 + (32 * _8872) + 32
                                            mem[_8584 + ceil32(return_data.size) + 32 len 32 * _8872] = mem[_8584 + _8728 + 32 len 32 * _8872]
                                            if 0 >= _8872:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8584 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8584 + ceil32(return_data.size) + 32]
                                            if 1 >= _8872:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8584 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8585 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8729 = mem[_8585]
                                    require mem[_8585] <= test266151307()
                                    require _8585 + mem[_8585] + 31 < _8585 + return_data.size
                                    _8873 = mem[_8585 + mem[_8585]]
                                    if mem[_8585 + mem[_8585]] > test266151307():
                                        revert with 0, 65
                                    if _8585 + ceil32(return_data.size) + ceil32(32 * mem[_8585 + mem[_8585]]) + 1 > test266151307() or ceil32(32 * mem[_8585 + mem[_8585]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8585 + ceil32(return_data.size) + ceil32(32 * mem[_8585 + mem[_8585]]) + 1
                                    mem[_8585 + ceil32(return_data.size)] = _8873
                                    require return_data.size >= _8729 + (32 * _8873) + 32
                                    mem[_8585 + ceil32(return_data.size) + 32 len 32 * _8873] = mem[_8585 + _8729 + 32 len 32 * _8873]
                                    if 0 >= _8873:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8585 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8585 + ceil32(return_data.size) + 32]
                                    if 1 >= _8873:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8585 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8586 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8730 = mem[_8586]
                                    require mem[_8586] <= test266151307()
                                    require _8586 + mem[_8586] + 31 < _8586 + return_data.size
                                    _8874 = mem[_8586 + mem[_8586]]
                                    if mem[_8586 + mem[_8586]] > test266151307():
                                        revert with 0, 65
                                    if _8586 + ceil32(return_data.size) + ceil32(32 * mem[_8586 + mem[_8586]]) + 1 > test266151307() or ceil32(32 * mem[_8586 + mem[_8586]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8586 + ceil32(return_data.size) + ceil32(32 * mem[_8586 + mem[_8586]]) + 1
                                    mem[_8586 + ceil32(return_data.size)] = _8874
                                    require return_data.size >= _8730 + (32 * _8874) + 32
                                    mem[_8586 + ceil32(return_data.size) + 32 len 32 * _8874] = mem[_8586 + _8730 + 32 len 32 * _8874]
                                    if 0 >= _8874:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8586 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8586 + ceil32(return_data.size) + 32]
                                    if 1 >= _8874:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8586 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8587 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8731 = mem[_8587]
                                    require mem[_8587] <= test266151307()
                                    require _8587 + mem[_8587] + 31 < _8587 + return_data.size
                                    _8875 = mem[_8587 + mem[_8587]]
                                    if mem[_8587 + mem[_8587]] > test266151307():
                                        revert with 0, 65
                                    if _8587 + ceil32(return_data.size) + ceil32(32 * mem[_8587 + mem[_8587]]) + 1 > test266151307() or ceil32(32 * mem[_8587 + mem[_8587]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8587 + ceil32(return_data.size) + ceil32(32 * mem[_8587 + mem[_8587]]) + 1
                                    mem[_8587 + ceil32(return_data.size)] = _8875
                                    require return_data.size >= _8731 + (32 * _8875) + 32
                                    mem[_8587 + ceil32(return_data.size) + 32 len 32 * _8875] = mem[_8587 + _8731 + 32 len 32 * _8875]
                                    if 0 >= _8875:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8587 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8587 + ceil32(return_data.size) + 32]
                                    if 1 >= _8875:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8587 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8588 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8732 = mem[_8588]
                                        require mem[_8588] <= test266151307()
                                        require _8588 + mem[_8588] + 31 < _8588 + return_data.size
                                        _8876 = mem[_8588 + mem[_8588]]
                                        if mem[_8588 + mem[_8588]] > test266151307():
                                            revert with 0, 65
                                        if _8588 + ceil32(return_data.size) + ceil32(32 * mem[_8588 + mem[_8588]]) + 1 > test266151307() or ceil32(32 * mem[_8588 + mem[_8588]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8588 + ceil32(return_data.size) + ceil32(32 * mem[_8588 + mem[_8588]]) + 1
                                        mem[_8588 + ceil32(return_data.size)] = _8876
                                        require return_data.size >= _8732 + (32 * _8876) + 32
                                        mem[_8588 + ceil32(return_data.size) + 32 len 32 * _8876] = mem[_8588 + _8732 + 32 len 32 * _8876]
                                        if 0 >= _8876:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8588 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8588 + ceil32(return_data.size) + 32]
                                        if 1 >= _8876:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8588 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8589 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8733 = mem[_8589]
                                            require mem[_8589] <= test266151307()
                                            require _8589 + mem[_8589] + 31 < _8589 + return_data.size
                                            _8877 = mem[_8589 + mem[_8589]]
                                            if mem[_8589 + mem[_8589]] > test266151307():
                                                revert with 0, 65
                                            if _8589 + ceil32(return_data.size) + ceil32(32 * mem[_8589 + mem[_8589]]) + 1 > test266151307() or ceil32(32 * mem[_8589 + mem[_8589]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8589 + ceil32(return_data.size) + ceil32(32 * mem[_8589 + mem[_8589]]) + 1
                                            mem[_8589 + ceil32(return_data.size)] = _8877
                                            require return_data.size >= _8733 + (32 * _8877) + 32
                                            mem[_8589 + ceil32(return_data.size) + 32 len 32 * _8877] = mem[_8589 + _8733 + 32 len 32 * _8877]
                                            if 0 >= _8877:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8589 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8589 + ceil32(return_data.size) + 32]
                                            if 1 >= _8877:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8589 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8590 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8734 = mem[_8590]
                                            require mem[_8590] <= test266151307()
                                            require _8590 + mem[_8590] + 31 < _8590 + return_data.size
                                            _8878 = mem[_8590 + mem[_8590]]
                                            if mem[_8590 + mem[_8590]] > test266151307():
                                                revert with 0, 65
                                            if _8590 + ceil32(return_data.size) + ceil32(32 * mem[_8590 + mem[_8590]]) + 1 > test266151307() or ceil32(32 * mem[_8590 + mem[_8590]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8590 + ceil32(return_data.size) + ceil32(32 * mem[_8590 + mem[_8590]]) + 1
                                            mem[_8590 + ceil32(return_data.size)] = _8878
                                            require return_data.size >= _8734 + (32 * _8878) + 32
                                            mem[_8590 + ceil32(return_data.size) + 32 len 32 * _8878] = mem[_8590 + _8734 + 32 len 32 * _8878]
                                            if 0 >= _8878:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8590 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8590 + ceil32(return_data.size) + 32]
                                            if 1 >= _8878:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8590 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8591 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8735 = mem[_8591]
                                    require mem[_8591] <= test266151307()
                                    require _8591 + mem[_8591] + 31 < _8591 + return_data.size
                                    _8879 = mem[_8591 + mem[_8591]]
                                    if mem[_8591 + mem[_8591]] > test266151307():
                                        revert with 0, 65
                                    if _8591 + ceil32(return_data.size) + ceil32(32 * mem[_8591 + mem[_8591]]) + 1 > test266151307() or ceil32(32 * mem[_8591 + mem[_8591]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8591 + ceil32(return_data.size) + ceil32(32 * mem[_8591 + mem[_8591]]) + 1
                                    mem[_8591 + ceil32(return_data.size)] = _8879
                                    require return_data.size >= _8735 + (32 * _8879) + 32
                                    mem[_8591 + ceil32(return_data.size) + 32 len 32 * _8879] = mem[_8591 + _8735 + 32 len 32 * _8879]
                                    if 0 >= _8879:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8591 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8591 + ceil32(return_data.size) + 32]
                                    if 1 >= _8879:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8591 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8592 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8736 = mem[_8592]
                                    require mem[_8592] <= test266151307()
                                    require _8592 + mem[_8592] + 31 < _8592 + return_data.size
                                    _8880 = mem[_8592 + mem[_8592]]
                                    if mem[_8592 + mem[_8592]] > test266151307():
                                        revert with 0, 65
                                    if _8592 + ceil32(return_data.size) + ceil32(32 * mem[_8592 + mem[_8592]]) + 1 > test266151307() or ceil32(32 * mem[_8592 + mem[_8592]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8592 + ceil32(return_data.size) + ceil32(32 * mem[_8592 + mem[_8592]]) + 1
                                    mem[_8592 + ceil32(return_data.size)] = _8880
                                    require return_data.size >= _8736 + (32 * _8880) + 32
                                    mem[_8592 + ceil32(return_data.size) + 32 len 32 * _8880] = mem[_8592 + _8736 + 32 len 32 * _8880]
                                    if 0 >= _8880:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8592 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8592 + ceil32(return_data.size) + 32]
                                    if 1 >= _8880:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8592 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5753:
                                        revert with 0, 17
                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                    mem[_5757 + 132] = 0
                                    mem[_5757 + 164] = 160
                                    mem[_5757 + 260] = mem[_5757]
                                    idx = 0
                                    s = _5757 + 292
                                    t = _5757 + 32
                                    while idx < mem[_5757]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5757 + 196] = this.address
                                    mem[_5757 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8593 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8737 = mem[_8593]
                                    require mem[_8593] <= test266151307()
                                    require _8593 + mem[_8593] + 31 < _8593 + return_data.size
                                    _8881 = mem[_8593 + mem[_8593]]
                                    if mem[_8593 + mem[_8593]] > test266151307():
                                        revert with 0, 65
                                    if _8593 + ceil32(return_data.size) + ceil32(32 * mem[_8593 + mem[_8593]]) + 1 > test266151307() or ceil32(32 * mem[_8593 + mem[_8593]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8593 + ceil32(return_data.size) + ceil32(32 * mem[_8593 + mem[_8593]]) + 1
                                    mem[_8593 + ceil32(return_data.size)] = _8881
                                    require return_data.size >= _8737 + (32 * _8881) + 32
                                    mem[_8593 + ceil32(return_data.size) + 32 len 32 * _8881] = mem[_8593 + _8737 + 32 len 32 * _8881]
                                    if 0 >= _8881:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8593 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8593 + ceil32(return_data.size) + 32]
                                    if 1 >= _8881:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8593 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8594 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8738 = mem[_8594]
                                        require mem[_8594] <= test266151307()
                                        require _8594 + mem[_8594] + 31 < _8594 + return_data.size
                                        _8882 = mem[_8594 + mem[_8594]]
                                        if mem[_8594 + mem[_8594]] > test266151307():
                                            revert with 0, 65
                                        if _8594 + ceil32(return_data.size) + ceil32(32 * mem[_8594 + mem[_8594]]) + 1 > test266151307() or ceil32(32 * mem[_8594 + mem[_8594]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8594 + ceil32(return_data.size) + ceil32(32 * mem[_8594 + mem[_8594]]) + 1
                                        mem[_8594 + ceil32(return_data.size)] = _8882
                                        require return_data.size >= _8738 + (32 * _8882) + 32
                                        mem[_8594 + ceil32(return_data.size) + 32 len 32 * _8882] = mem[_8594 + _8738 + 32 len 32 * _8882]
                                        if 0 >= _8882:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8594 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8594 + ceil32(return_data.size) + 32]
                                        if 1 >= _8882:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8594 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8595 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8739 = mem[_8595]
                                            require mem[_8595] <= test266151307()
                                            require _8595 + mem[_8595] + 31 < _8595 + return_data.size
                                            _8883 = mem[_8595 + mem[_8595]]
                                            if mem[_8595 + mem[_8595]] > test266151307():
                                                revert with 0, 65
                                            if _8595 + ceil32(return_data.size) + ceil32(32 * mem[_8595 + mem[_8595]]) + 1 > test266151307() or ceil32(32 * mem[_8595 + mem[_8595]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8595 + ceil32(return_data.size) + ceil32(32 * mem[_8595 + mem[_8595]]) + 1
                                            mem[_8595 + ceil32(return_data.size)] = _8883
                                            require return_data.size >= _8739 + (32 * _8883) + 32
                                            mem[_8595 + ceil32(return_data.size) + 32 len 32 * _8883] = mem[_8595 + _8739 + 32 len 32 * _8883]
                                            if 0 >= _8883:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8595 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8595 + ceil32(return_data.size) + 32]
                                            if 1 >= _8883:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8595 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8596 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8740 = mem[_8596]
                                            require mem[_8596] <= test266151307()
                                            require _8596 + mem[_8596] + 31 < _8596 + return_data.size
                                            _8884 = mem[_8596 + mem[_8596]]
                                            if mem[_8596 + mem[_8596]] > test266151307():
                                                revert with 0, 65
                                            if _8596 + ceil32(return_data.size) + ceil32(32 * mem[_8596 + mem[_8596]]) + 1 > test266151307() or ceil32(32 * mem[_8596 + mem[_8596]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8596 + ceil32(return_data.size) + ceil32(32 * mem[_8596 + mem[_8596]]) + 1
                                            mem[_8596 + ceil32(return_data.size)] = _8884
                                            require return_data.size >= _8740 + (32 * _8884) + 32
                                            mem[_8596 + ceil32(return_data.size) + 32 len 32 * _8884] = mem[_8596 + _8740 + 32 len 32 * _8884]
                                            if 0 >= _8884:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8596 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8596 + ceil32(return_data.size) + 32]
                                            if 1 >= _8884:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8596 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8597 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8741 = mem[_8597]
                                        require mem[_8597] <= test266151307()
                                        require _8597 + mem[_8597] + 31 < _8597 + return_data.size
                                        _8885 = mem[_8597 + mem[_8597]]
                                        if mem[_8597 + mem[_8597]] > test266151307():
                                            revert with 0, 65
                                        if _8597 + ceil32(return_data.size) + ceil32(32 * mem[_8597 + mem[_8597]]) + 1 > test266151307() or ceil32(32 * mem[_8597 + mem[_8597]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8597 + ceil32(return_data.size) + ceil32(32 * mem[_8597 + mem[_8597]]) + 1
                                        mem[_8597 + ceil32(return_data.size)] = _8885
                                        require return_data.size >= _8741 + (32 * _8885) + 32
                                        mem[_8597 + ceil32(return_data.size) + 32 len 32 * _8885] = mem[_8597 + _8741 + 32 len 32 * _8885]
                                        if 0 >= _8885:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8597 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8597 + ceil32(return_data.size) + 32]
                                        if 1 >= _8885:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8597 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8598 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8742 = mem[_8598]
                                        require mem[_8598] <= test266151307()
                                        require _8598 + mem[_8598] + 31 < _8598 + return_data.size
                                        _8886 = mem[_8598 + mem[_8598]]
                                        if mem[_8598 + mem[_8598]] > test266151307():
                                            revert with 0, 65
                                        if _8598 + ceil32(return_data.size) + ceil32(32 * mem[_8598 + mem[_8598]]) + 1 > test266151307() or ceil32(32 * mem[_8598 + mem[_8598]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8598 + ceil32(return_data.size) + ceil32(32 * mem[_8598 + mem[_8598]]) + 1
                                        mem[_8598 + ceil32(return_data.size)] = _8886
                                        require return_data.size >= _8742 + (32 * _8886) + 32
                                        mem[_8598 + ceil32(return_data.size) + 32 len 32 * _8886] = mem[_8598 + _8742 + 32 len 32 * _8886]
                                        if 0 >= _8886:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8598 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8598 + ceil32(return_data.size) + 32]
                                        if 1 >= _8886:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8598 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5753:
                                            revert with 0, 17
                                        mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                        mem[_5757 + 132] = 0
                                        mem[_5757 + 164] = 160
                                        mem[_5757 + 260] = mem[_5757]
                                        idx = 0
                                        s = _5757 + 292
                                        t = _5757 + 32
                                        while idx < mem[_5757]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5757 + 196] = this.address
                                        mem[_5757 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8599 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8743 = mem[_8599]
                                        require mem[_8599] <= test266151307()
                                        require _8599 + mem[_8599] + 31 < _8599 + return_data.size
                                        _8887 = mem[_8599 + mem[_8599]]
                                        if mem[_8599 + mem[_8599]] > test266151307():
                                            revert with 0, 65
                                        if _8599 + ceil32(return_data.size) + ceil32(32 * mem[_8599 + mem[_8599]]) + 1 > test266151307() or ceil32(32 * mem[_8599 + mem[_8599]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8599 + ceil32(return_data.size) + ceil32(32 * mem[_8599 + mem[_8599]]) + 1
                                        mem[_8599 + ceil32(return_data.size)] = _8887
                                        require return_data.size >= _8743 + (32 * _8887) + 32
                                        mem[_8599 + ceil32(return_data.size) + 32 len 32 * _8887] = mem[_8599 + _8743 + 32 len 32 * _8887]
                                        if 0 >= _8887:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8599 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8599 + ceil32(return_data.size) + 32]
                                        if 1 >= _8887:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8599 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8600 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8744 = mem[_8600]
                                            require mem[_8600] <= test266151307()
                                            require _8600 + mem[_8600] + 31 < _8600 + return_data.size
                                            _8888 = mem[_8600 + mem[_8600]]
                                            if mem[_8600 + mem[_8600]] > test266151307():
                                                revert with 0, 65
                                            if _8600 + ceil32(return_data.size) + ceil32(32 * mem[_8600 + mem[_8600]]) + 1 > test266151307() or ceil32(32 * mem[_8600 + mem[_8600]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8600 + ceil32(return_data.size) + ceil32(32 * mem[_8600 + mem[_8600]]) + 1
                                            mem[_8600 + ceil32(return_data.size)] = _8888
                                            require return_data.size >= _8744 + (32 * _8888) + 32
                                            mem[_8600 + ceil32(return_data.size) + 32 len 32 * _8888] = mem[_8600 + _8744 + 32 len 32 * _8888]
                                            if 0 >= _8888:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8600 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8600 + ceil32(return_data.size) + 32]
                                            if 1 >= _8888:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8600 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5753:
                                                    revert with 0, 17
                                                mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                                mem[_5757 + 132] = 0
                                                mem[_5757 + 164] = 160
                                                mem[_5757 + 260] = mem[_5757]
                                                idx = 0
                                                s = _5757 + 292
                                                t = _5757 + 32
                                                while idx < mem[_5757]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5757 + 196] = this.address
                                                mem[_5757 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8601 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8745 = mem[_8601]
                                                require mem[_8601] <= test266151307()
                                                require _8601 + mem[_8601] + 31 < _8601 + return_data.size
                                                _8889 = mem[_8601 + mem[_8601]]
                                                if mem[_8601 + mem[_8601]] > test266151307():
                                                    revert with 0, 65
                                                if _8601 + ceil32(return_data.size) + ceil32(32 * mem[_8601 + mem[_8601]]) + 1 > test266151307() or ceil32(32 * mem[_8601 + mem[_8601]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8601 + ceil32(return_data.size) + ceil32(32 * mem[_8601 + mem[_8601]]) + 1
                                                mem[_8601 + ceil32(return_data.size)] = _8889
                                                require return_data.size >= _8745 + (32 * _8889) + 32
                                                mem[_8601 + ceil32(return_data.size) + 32 len 32 * _8889] = mem[_8601 + _8745 + 32 len 32 * _8889]
                                                if 0 >= _8889:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8601 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8601 + ceil32(return_data.size) + 32]
                                                if 1 >= _8889:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8601 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5753:
                                                    revert with 0, 17
                                                mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                                mem[_5757 + 132] = 0
                                                mem[_5757 + 164] = 160
                                                mem[_5757 + 260] = mem[_5757]
                                                idx = 0
                                                s = _5757 + 292
                                                t = _5757 + 32
                                                while idx < mem[_5757]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5757 + 196] = this.address
                                                mem[_5757 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8602 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8746 = mem[_8602]
                                                require mem[_8602] <= test266151307()
                                                require _8602 + mem[_8602] + 31 < _8602 + return_data.size
                                                _8890 = mem[_8602 + mem[_8602]]
                                                if mem[_8602 + mem[_8602]] > test266151307():
                                                    revert with 0, 65
                                                if _8602 + ceil32(return_data.size) + ceil32(32 * mem[_8602 + mem[_8602]]) + 1 > test266151307() or ceil32(32 * mem[_8602 + mem[_8602]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8602 + ceil32(return_data.size) + ceil32(32 * mem[_8602 + mem[_8602]]) + 1
                                                mem[_8602 + ceil32(return_data.size)] = _8890
                                                require return_data.size >= _8746 + (32 * _8890) + 32
                                                mem[_8602 + ceil32(return_data.size) + 32 len 32 * _8890] = mem[_8602 + _8746 + 32 len 32 * _8890]
                                                if 0 >= _8890:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8602 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8602 + ceil32(return_data.size) + 32]
                                                if 1 >= _8890:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8602 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8603 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8747 = mem[_8603]
                                            require mem[_8603] <= test266151307()
                                            require _8603 + mem[_8603] + 31 < _8603 + return_data.size
                                            _8891 = mem[_8603 + mem[_8603]]
                                            if mem[_8603 + mem[_8603]] > test266151307():
                                                revert with 0, 65
                                            if _8603 + ceil32(return_data.size) + ceil32(32 * mem[_8603 + mem[_8603]]) + 1 > test266151307() or ceil32(32 * mem[_8603 + mem[_8603]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8603 + ceil32(return_data.size) + ceil32(32 * mem[_8603 + mem[_8603]]) + 1
                                            mem[_8603 + ceil32(return_data.size)] = _8891
                                            require return_data.size >= _8747 + (32 * _8891) + 32
                                            mem[_8603 + ceil32(return_data.size) + 32 len 32 * _8891] = mem[_8603 + _8747 + 32 len 32 * _8891]
                                            if 0 >= _8891:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8603 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8603 + ceil32(return_data.size) + 32]
                                            if 1 >= _8891:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8603 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8604 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8748 = mem[_8604]
                                            require mem[_8604] <= test266151307()
                                            require _8604 + mem[_8604] + 31 < _8604 + return_data.size
                                            _8892 = mem[_8604 + mem[_8604]]
                                            if mem[_8604 + mem[_8604]] > test266151307():
                                                revert with 0, 65
                                            if _8604 + ceil32(return_data.size) + ceil32(32 * mem[_8604 + mem[_8604]]) + 1 > test266151307() or ceil32(32 * mem[_8604 + mem[_8604]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8604 + ceil32(return_data.size) + ceil32(32 * mem[_8604 + mem[_8604]]) + 1
                                            mem[_8604 + ceil32(return_data.size)] = _8892
                                            require return_data.size >= _8748 + (32 * _8892) + 32
                                            mem[_8604 + ceil32(return_data.size) + 32 len 32 * _8892] = mem[_8604 + _8748 + 32 len 32 * _8892]
                                            if 0 >= _8892:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8604 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8604 + ceil32(return_data.size) + 32]
                                            if 1 >= _8892:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8604 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8605 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8749 = mem[_8605]
                                            require mem[_8605] <= test266151307()
                                            require _8605 + mem[_8605] + 31 < _8605 + return_data.size
                                            _8893 = mem[_8605 + mem[_8605]]
                                            if mem[_8605 + mem[_8605]] > test266151307():
                                                revert with 0, 65
                                            if _8605 + ceil32(return_data.size) + ceil32(32 * mem[_8605 + mem[_8605]]) + 1 > test266151307() or ceil32(32 * mem[_8605 + mem[_8605]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8605 + ceil32(return_data.size) + ceil32(32 * mem[_8605 + mem[_8605]]) + 1
                                            mem[_8605 + ceil32(return_data.size)] = _8893
                                            require return_data.size >= _8749 + (32 * _8893) + 32
                                            mem[_8605 + ceil32(return_data.size) + 32 len 32 * _8893] = mem[_8605 + _8749 + 32 len 32 * _8893]
                                            if 0 >= _8893:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8605 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8605 + ceil32(return_data.size) + 32]
                                            if 1 >= _8893:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8605 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5753:
                                                    revert with 0, 17
                                                mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                                mem[_5757 + 132] = 0
                                                mem[_5757 + 164] = 160
                                                mem[_5757 + 260] = mem[_5757]
                                                idx = 0
                                                s = _5757 + 292
                                                t = _5757 + 32
                                                while idx < mem[_5757]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5757 + 196] = this.address
                                                mem[_5757 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8606 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8750 = mem[_8606]
                                                require mem[_8606] <= test266151307()
                                                require _8606 + mem[_8606] + 31 < _8606 + return_data.size
                                                _8894 = mem[_8606 + mem[_8606]]
                                                if mem[_8606 + mem[_8606]] > test266151307():
                                                    revert with 0, 65
                                                if _8606 + ceil32(return_data.size) + ceil32(32 * mem[_8606 + mem[_8606]]) + 1 > test266151307() or ceil32(32 * mem[_8606 + mem[_8606]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8606 + ceil32(return_data.size) + ceil32(32 * mem[_8606 + mem[_8606]]) + 1
                                                mem[_8606 + ceil32(return_data.size)] = _8894
                                                require return_data.size >= _8750 + (32 * _8894) + 32
                                                mem[_8606 + ceil32(return_data.size) + 32 len 32 * _8894] = mem[_8606 + _8750 + 32 len 32 * _8894]
                                                if 0 >= _8894:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8606 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8606 + ceil32(return_data.size) + 32]
                                                if 1 >= _8894:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8606 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5753:
                                                        revert with 0, 17
                                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                                    mem[_5757 + 132] = 0
                                                    mem[_5757 + 164] = 160
                                                    mem[_5757 + 260] = mem[_5757]
                                                    idx = 0
                                                    s = _5757 + 292
                                                    t = _5757 + 32
                                                    while idx < mem[_5757]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5757 + 196] = this.address
                                                    mem[_5757 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8607 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8751 = mem[_8607]
                                                    require mem[_8607] <= test266151307()
                                                    require _8607 + mem[_8607] + 31 < _8607 + return_data.size
                                                    _8895 = mem[_8607 + mem[_8607]]
                                                    if mem[_8607 + mem[_8607]] > test266151307():
                                                        revert with 0, 65
                                                    if _8607 + ceil32(return_data.size) + ceil32(32 * mem[_8607 + mem[_8607]]) + 1 > test266151307() or ceil32(32 * mem[_8607 + mem[_8607]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8607 + ceil32(return_data.size) + ceil32(32 * mem[_8607 + mem[_8607]]) + 1
                                                    mem[_8607 + ceil32(return_data.size)] = _8895
                                                    require return_data.size >= _8751 + (32 * _8895) + 32
                                                    mem[_8607 + ceil32(return_data.size) + 32 len 32 * _8895] = mem[_8607 + _8751 + 32 len 32 * _8895]
                                                    if 0 >= _8895:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8607 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8607 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8895:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8607 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5753:
                                                        revert with 0, 17
                                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                                    mem[_5757 + 132] = 0
                                                    mem[_5757 + 164] = 160
                                                    mem[_5757 + 260] = mem[_5757]
                                                    idx = 0
                                                    s = _5757 + 292
                                                    t = _5757 + 32
                                                    while idx < mem[_5757]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5757 + 196] = this.address
                                                    mem[_5757 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8608 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8752 = mem[_8608]
                                                    require mem[_8608] <= test266151307()
                                                    require _8608 + mem[_8608] + 31 < _8608 + return_data.size
                                                    _8896 = mem[_8608 + mem[_8608]]
                                                    if mem[_8608 + mem[_8608]] > test266151307():
                                                        revert with 0, 65
                                                    if _8608 + ceil32(return_data.size) + ceil32(32 * mem[_8608 + mem[_8608]]) + 1 > test266151307() or ceil32(32 * mem[_8608 + mem[_8608]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8608 + ceil32(return_data.size) + ceil32(32 * mem[_8608 + mem[_8608]]) + 1
                                                    mem[_8608 + ceil32(return_data.size)] = _8896
                                                    require return_data.size >= _8752 + (32 * _8896) + 32
                                                    mem[_8608 + ceil32(return_data.size) + 32 len 32 * _8896] = mem[_8608 + _8752 + 32 len 32 * _8896]
                                                    if 0 >= _8896:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8608 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8608 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8896:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8608 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8609 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8753 = mem[_8609]
                                            require mem[_8609] <= test266151307()
                                            require _8609 + mem[_8609] + 31 < _8609 + return_data.size
                                            _8897 = mem[_8609 + mem[_8609]]
                                            if mem[_8609 + mem[_8609]] > test266151307():
                                                revert with 0, 65
                                            if _8609 + ceil32(return_data.size) + ceil32(32 * mem[_8609 + mem[_8609]]) + 1 > test266151307() or ceil32(32 * mem[_8609 + mem[_8609]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8609 + ceil32(return_data.size) + ceil32(32 * mem[_8609 + mem[_8609]]) + 1
                                            mem[_8609 + ceil32(return_data.size)] = _8897
                                            require return_data.size >= _8753 + (32 * _8897) + 32
                                            mem[_8609 + ceil32(return_data.size) + 32 len 32 * _8897] = mem[_8609 + _8753 + 32 len 32 * _8897]
                                            if 0 >= _8897:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8609 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8609 + ceil32(return_data.size) + 32]
                                            if 1 >= _8897:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8609 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8610 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8754 = mem[_8610]
                                            require mem[_8610] <= test266151307()
                                            require _8610 + mem[_8610] + 31 < _8610 + return_data.size
                                            _8898 = mem[_8610 + mem[_8610]]
                                            if mem[_8610 + mem[_8610]] > test266151307():
                                                revert with 0, 65
                                            if _8610 + ceil32(return_data.size) + ceil32(32 * mem[_8610 + mem[_8610]]) + 1 > test266151307() or ceil32(32 * mem[_8610 + mem[_8610]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8610 + ceil32(return_data.size) + ceil32(32 * mem[_8610 + mem[_8610]]) + 1
                                            mem[_8610 + ceil32(return_data.size)] = _8898
                                            require return_data.size >= _8754 + (32 * _8898) + 32
                                            mem[_8610 + ceil32(return_data.size) + 32 len 32 * _8898] = mem[_8610 + _8754 + 32 len 32 * _8898]
                                            if 0 >= _8898:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8610 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8610 + ceil32(return_data.size) + 32]
                                            if 1 >= _8898:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8610 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5753:
                                                revert with 0, 17
                                            mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                            mem[_5757 + 132] = 0
                                            mem[_5757 + 164] = 160
                                            mem[_5757 + 260] = mem[_5757]
                                            idx = 0
                                            s = _5757 + 292
                                            t = _5757 + 32
                                            while idx < mem[_5757]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5757 + 196] = this.address
                                            mem[_5757 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8611 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8755 = mem[_8611]
                                            require mem[_8611] <= test266151307()
                                            require _8611 + mem[_8611] + 31 < _8611 + return_data.size
                                            _8899 = mem[_8611 + mem[_8611]]
                                            if mem[_8611 + mem[_8611]] > test266151307():
                                                revert with 0, 65
                                            if _8611 + ceil32(return_data.size) + ceil32(32 * mem[_8611 + mem[_8611]]) + 1 > test266151307() or ceil32(32 * mem[_8611 + mem[_8611]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8611 + ceil32(return_data.size) + ceil32(32 * mem[_8611 + mem[_8611]]) + 1
                                            mem[_8611 + ceil32(return_data.size)] = _8899
                                            require return_data.size >= _8755 + (32 * _8899) + 32
                                            mem[_8611 + ceil32(return_data.size) + 32 len 32 * _8899] = mem[_8611 + _8755 + 32 len 32 * _8899]
                                            if 0 >= _8899:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8611 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8611 + ceil32(return_data.size) + 32]
                                            if 1 >= _8899:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8611 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5753:
                                                    revert with 0, 17
                                                mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                                mem[_5757 + 132] = 0
                                                mem[_5757 + 164] = 160
                                                mem[_5757 + 260] = mem[_5757]
                                                idx = 0
                                                s = _5757 + 292
                                                t = _5757 + 32
                                                while idx < mem[_5757]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5757 + 196] = this.address
                                                mem[_5757 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8612 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8756 = mem[_8612]
                                                require mem[_8612] <= test266151307()
                                                require _8612 + mem[_8612] + 31 < _8612 + return_data.size
                                                _8900 = mem[_8612 + mem[_8612]]
                                                if mem[_8612 + mem[_8612]] > test266151307():
                                                    revert with 0, 65
                                                if _8612 + ceil32(return_data.size) + ceil32(32 * mem[_8612 + mem[_8612]]) + 1 > test266151307() or ceil32(32 * mem[_8612 + mem[_8612]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8612 + ceil32(return_data.size) + ceil32(32 * mem[_8612 + mem[_8612]]) + 1
                                                mem[_8612 + ceil32(return_data.size)] = _8900
                                                require return_data.size >= _8756 + (32 * _8900) + 32
                                                mem[_8612 + ceil32(return_data.size) + 32 len 32 * _8900] = mem[_8612 + _8756 + 32 len 32 * _8900]
                                                if 0 >= _8900:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8612 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8612 + ceil32(return_data.size) + 32]
                                                if 1 >= _8900:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8612 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5753:
                                                        revert with 0, 17
                                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5757 + 100] = ext_call.return_data[32] + _5753
                                                    mem[_5757 + 132] = 0
                                                    mem[_5757 + 164] = 160
                                                    mem[_5757 + 260] = mem[_5757]
                                                    idx = 0
                                                    s = _5757 + 292
                                                    t = _5757 + 32
                                                    while idx < mem[_5757]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5757 + 196] = this.address
                                                    mem[_5757 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8613 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8757 = mem[_8613]
                                                    require mem[_8613] <= test266151307()
                                                    require _8613 + mem[_8613] + 31 < _8613 + return_data.size
                                                    _8901 = mem[_8613 + mem[_8613]]
                                                    if mem[_8613 + mem[_8613]] > test266151307():
                                                        revert with 0, 65
                                                    if _8613 + ceil32(return_data.size) + ceil32(32 * mem[_8613 + mem[_8613]]) + 1 > test266151307() or ceil32(32 * mem[_8613 + mem[_8613]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8613 + ceil32(return_data.size) + ceil32(32 * mem[_8613 + mem[_8613]]) + 1
                                                    mem[_8613 + ceil32(return_data.size)] = _8901
                                                    require return_data.size >= _8757 + (32 * _8901) + 32
                                                    mem[_8613 + ceil32(return_data.size) + 32 len 32 * _8901] = mem[_8613 + _8757 + 32 len 32 * _8901]
                                                    if 0 >= _8901:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8613 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8613 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8901:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8613 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5753:
                                                        revert with 0, 17
                                                    mem[_5757 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5757 + 100] = ext_call.return_data[0] + _5753
                                                    mem[_5757 + 132] = 0
                                                    mem[_5757 + 164] = 160
                                                    mem[_5757 + 260] = mem[_5757]
                                                    idx = 0
                                                    s = _5757 + 292
                                                    t = _5757 + 32
                                                    while idx < mem[_5757]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5757 + 196] = this.address
                                                    mem[_5757 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5757 + (32 * mem[_5757]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8614 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8758 = mem[_8614]
                                                    require mem[_8614] <= test266151307()
                                                    require _8614 + mem[_8614] + 31 < _8614 + return_data.size
                                                    _8902 = mem[_8614 + mem[_8614]]
                                                    if mem[_8614 + mem[_8614]] > test266151307():
                                                        revert with 0, 65
                                                    if _8614 + ceil32(return_data.size) + ceil32(32 * mem[_8614 + mem[_8614]]) + 1 > test266151307() or ceil32(32 * mem[_8614 + mem[_8614]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8614 + ceil32(return_data.size) + ceil32(32 * mem[_8614 + mem[_8614]]) + 1
                                                    mem[_8614 + ceil32(return_data.size)] = _8902
                                                    require return_data.size >= _8758 + (32 * _8902) + 32
                                                    mem[_8614 + ceil32(return_data.size) + 32 len 32 * _8902] = mem[_8614 + _8758 + 32 len 32 * _8902]
                                                    if 0 >= _8902:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8614 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8614 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8902:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8614 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2988 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3019 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3019
                    require return_data.size >= _2988 + (32 * _3019) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3019] = mem[(4 * ceil32(return_data.size)) + _2988 + 224 len 32 * _3019]
                    if 1 >= _3019:
                        revert with 0, 50
                    _5754 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5758 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5758]:
                        revert with 0, 50
                    mem[_5758 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5758]:
                        revert with 0, 50
                    mem[_5758 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5754:
                                        revert with 0, 17
                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                    mem[_5758 + 132] = 0
                                    mem[_5758 + 164] = 160
                                    mem[_5758 + 260] = mem[_5758]
                                    idx = 0
                                    s = _5758 + 292
                                    t = _5758 + 32
                                    while idx < mem[_5758]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5758 + 196] = this.address
                                    mem[_5758 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8615 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8759 = mem[_8615]
                                    require mem[_8615] <= test266151307()
                                    require _8615 + mem[_8615] + 31 < _8615 + return_data.size
                                    _8903 = mem[_8615 + mem[_8615]]
                                    if mem[_8615 + mem[_8615]] > test266151307():
                                        revert with 0, 65
                                    if _8615 + ceil32(return_data.size) + ceil32(32 * mem[_8615 + mem[_8615]]) + 1 > test266151307() or ceil32(32 * mem[_8615 + mem[_8615]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8615 + ceil32(return_data.size) + ceil32(32 * mem[_8615 + mem[_8615]]) + 1
                                    mem[_8615 + ceil32(return_data.size)] = _8903
                                    require return_data.size >= _8759 + (32 * _8903) + 32
                                    mem[_8615 + ceil32(return_data.size) + 32 len 32 * _8903] = mem[_8615 + _8759 + 32 len 32 * _8903]
                                    if 0 >= _8903:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8615 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8615 + ceil32(return_data.size) + 32]
                                    if 1 >= _8903:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8615 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5754:
                                        revert with 0, 17
                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                    mem[_5758 + 132] = 0
                                    mem[_5758 + 164] = 160
                                    mem[_5758 + 260] = mem[_5758]
                                    idx = 0
                                    s = _5758 + 292
                                    t = _5758 + 32
                                    while idx < mem[_5758]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5758 + 196] = this.address
                                    mem[_5758 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8616 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8760 = mem[_8616]
                                    require mem[_8616] <= test266151307()
                                    require _8616 + mem[_8616] + 31 < _8616 + return_data.size
                                    _8904 = mem[_8616 + mem[_8616]]
                                    if mem[_8616 + mem[_8616]] > test266151307():
                                        revert with 0, 65
                                    if _8616 + ceil32(return_data.size) + ceil32(32 * mem[_8616 + mem[_8616]]) + 1 > test266151307() or ceil32(32 * mem[_8616 + mem[_8616]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8616 + ceil32(return_data.size) + ceil32(32 * mem[_8616 + mem[_8616]]) + 1
                                    mem[_8616 + ceil32(return_data.size)] = _8904
                                    require return_data.size >= _8760 + (32 * _8904) + 32
                                    mem[_8616 + ceil32(return_data.size) + 32 len 32 * _8904] = mem[_8616 + _8760 + 32 len 32 * _8904]
                                    if 0 >= _8904:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8616 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8616 + ceil32(return_data.size) + 32]
                                    if 1 >= _8904:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8616 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5754:
                                        revert with 0, 17
                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                    mem[_5758 + 132] = 0
                                    mem[_5758 + 164] = 160
                                    mem[_5758 + 260] = mem[_5758]
                                    idx = 0
                                    s = _5758 + 292
                                    t = _5758 + 32
                                    while idx < mem[_5758]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5758 + 196] = this.address
                                    mem[_5758 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8617 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8761 = mem[_8617]
                                    require mem[_8617] <= test266151307()
                                    require _8617 + mem[_8617] + 31 < _8617 + return_data.size
                                    _8905 = mem[_8617 + mem[_8617]]
                                    if mem[_8617 + mem[_8617]] > test266151307():
                                        revert with 0, 65
                                    if _8617 + ceil32(return_data.size) + ceil32(32 * mem[_8617 + mem[_8617]]) + 1 > test266151307() or ceil32(32 * mem[_8617 + mem[_8617]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8617 + ceil32(return_data.size) + ceil32(32 * mem[_8617 + mem[_8617]]) + 1
                                    mem[_8617 + ceil32(return_data.size)] = _8905
                                    require return_data.size >= _8761 + (32 * _8905) + 32
                                    mem[_8617 + ceil32(return_data.size) + 32 len 32 * _8905] = mem[_8617 + _8761 + 32 len 32 * _8905]
                                    if 0 >= _8905:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8617 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8617 + ceil32(return_data.size) + 32]
                                    if 1 >= _8905:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8617 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5754:
                                            revert with 0, 17
                                        mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                        mem[_5758 + 132] = 0
                                        mem[_5758 + 164] = 160
                                        mem[_5758 + 260] = mem[_5758]
                                        idx = 0
                                        s = _5758 + 292
                                        t = _5758 + 32
                                        while idx < mem[_5758]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5758 + 196] = this.address
                                        mem[_5758 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8618 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8762 = mem[_8618]
                                        require mem[_8618] <= test266151307()
                                        require _8618 + mem[_8618] + 31 < _8618 + return_data.size
                                        _8906 = mem[_8618 + mem[_8618]]
                                        if mem[_8618 + mem[_8618]] > test266151307():
                                            revert with 0, 65
                                        if _8618 + ceil32(return_data.size) + ceil32(32 * mem[_8618 + mem[_8618]]) + 1 > test266151307() or ceil32(32 * mem[_8618 + mem[_8618]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8618 + ceil32(return_data.size) + ceil32(32 * mem[_8618 + mem[_8618]]) + 1
                                        mem[_8618 + ceil32(return_data.size)] = _8906
                                        require return_data.size >= _8762 + (32 * _8906) + 32
                                        mem[_8618 + ceil32(return_data.size) + 32 len 32 * _8906] = mem[_8618 + _8762 + 32 len 32 * _8906]
                                        if 0 >= _8906:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8618 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8618 + ceil32(return_data.size) + 32]
                                        if 1 >= _8906:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8618 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8619 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8763 = mem[_8619]
                                            require mem[_8619] <= test266151307()
                                            require _8619 + mem[_8619] + 31 < _8619 + return_data.size
                                            _8907 = mem[_8619 + mem[_8619]]
                                            if mem[_8619 + mem[_8619]] > test266151307():
                                                revert with 0, 65
                                            if _8619 + ceil32(return_data.size) + ceil32(32 * mem[_8619 + mem[_8619]]) + 1 > test266151307() or ceil32(32 * mem[_8619 + mem[_8619]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8619 + ceil32(return_data.size) + ceil32(32 * mem[_8619 + mem[_8619]]) + 1
                                            mem[_8619 + ceil32(return_data.size)] = _8907
                                            require return_data.size >= _8763 + (32 * _8907) + 32
                                            mem[_8619 + ceil32(return_data.size) + 32 len 32 * _8907] = mem[_8619 + _8763 + 32 len 32 * _8907]
                                            if 0 >= _8907:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8619 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8619 + ceil32(return_data.size) + 32]
                                            if 1 >= _8907:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8619 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8620 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8764 = mem[_8620]
                                            require mem[_8620] <= test266151307()
                                            require _8620 + mem[_8620] + 31 < _8620 + return_data.size
                                            _8908 = mem[_8620 + mem[_8620]]
                                            if mem[_8620 + mem[_8620]] > test266151307():
                                                revert with 0, 65
                                            if _8620 + ceil32(return_data.size) + ceil32(32 * mem[_8620 + mem[_8620]]) + 1 > test266151307() or ceil32(32 * mem[_8620 + mem[_8620]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8620 + ceil32(return_data.size) + ceil32(32 * mem[_8620 + mem[_8620]]) + 1
                                            mem[_8620 + ceil32(return_data.size)] = _8908
                                            require return_data.size >= _8764 + (32 * _8908) + 32
                                            mem[_8620 + ceil32(return_data.size) + 32 len 32 * _8908] = mem[_8620 + _8764 + 32 len 32 * _8908]
                                            if 0 >= _8908:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8620 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8620 + ceil32(return_data.size) + 32]
                                            if 1 >= _8908:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8620 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5754:
                                        revert with 0, 17
                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                    mem[_5758 + 132] = 0
                                    mem[_5758 + 164] = 160
                                    mem[_5758 + 260] = mem[_5758]
                                    idx = 0
                                    s = _5758 + 292
                                    t = _5758 + 32
                                    while idx < mem[_5758]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5758 + 196] = this.address
                                    mem[_5758 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8621 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8765 = mem[_8621]
                                    require mem[_8621] <= test266151307()
                                    require _8621 + mem[_8621] + 31 < _8621 + return_data.size
                                    _8909 = mem[_8621 + mem[_8621]]
                                    if mem[_8621 + mem[_8621]] > test266151307():
                                        revert with 0, 65
                                    if _8621 + ceil32(return_data.size) + ceil32(32 * mem[_8621 + mem[_8621]]) + 1 > test266151307() or ceil32(32 * mem[_8621 + mem[_8621]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8621 + ceil32(return_data.size) + ceil32(32 * mem[_8621 + mem[_8621]]) + 1
                                    mem[_8621 + ceil32(return_data.size)] = _8909
                                    require return_data.size >= _8765 + (32 * _8909) + 32
                                    mem[_8621 + ceil32(return_data.size) + 32 len 32 * _8909] = mem[_8621 + _8765 + 32 len 32 * _8909]
                                    if 0 >= _8909:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8621 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8621 + ceil32(return_data.size) + 32]
                                    if 1 >= _8909:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8621 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5754:
                                        revert with 0, 17
                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                    mem[_5758 + 132] = 0
                                    mem[_5758 + 164] = 160
                                    mem[_5758 + 260] = mem[_5758]
                                    idx = 0
                                    s = _5758 + 292
                                    t = _5758 + 32
                                    while idx < mem[_5758]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5758 + 196] = this.address
                                    mem[_5758 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8622 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8766 = mem[_8622]
                                    require mem[_8622] <= test266151307()
                                    require _8622 + mem[_8622] + 31 < _8622 + return_data.size
                                    _8910 = mem[_8622 + mem[_8622]]
                                    if mem[_8622 + mem[_8622]] > test266151307():
                                        revert with 0, 65
                                    if _8622 + ceil32(return_data.size) + ceil32(32 * mem[_8622 + mem[_8622]]) + 1 > test266151307() or ceil32(32 * mem[_8622 + mem[_8622]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8622 + ceil32(return_data.size) + ceil32(32 * mem[_8622 + mem[_8622]]) + 1
                                    mem[_8622 + ceil32(return_data.size)] = _8910
                                    require return_data.size >= _8766 + (32 * _8910) + 32
                                    mem[_8622 + ceil32(return_data.size) + 32 len 32 * _8910] = mem[_8622 + _8766 + 32 len 32 * _8910]
                                    if 0 >= _8910:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8622 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8622 + ceil32(return_data.size) + 32]
                                    if 1 >= _8910:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8622 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5754:
                                        revert with 0, 17
                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                    mem[_5758 + 132] = 0
                                    mem[_5758 + 164] = 160
                                    mem[_5758 + 260] = mem[_5758]
                                    idx = 0
                                    s = _5758 + 292
                                    t = _5758 + 32
                                    while idx < mem[_5758]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5758 + 196] = this.address
                                    mem[_5758 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8623 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8767 = mem[_8623]
                                    require mem[_8623] <= test266151307()
                                    require _8623 + mem[_8623] + 31 < _8623 + return_data.size
                                    _8911 = mem[_8623 + mem[_8623]]
                                    if mem[_8623 + mem[_8623]] > test266151307():
                                        revert with 0, 65
                                    if _8623 + ceil32(return_data.size) + ceil32(32 * mem[_8623 + mem[_8623]]) + 1 > test266151307() or ceil32(32 * mem[_8623 + mem[_8623]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8623 + ceil32(return_data.size) + ceil32(32 * mem[_8623 + mem[_8623]]) + 1
                                    mem[_8623 + ceil32(return_data.size)] = _8911
                                    require return_data.size >= _8767 + (32 * _8911) + 32
                                    mem[_8623 + ceil32(return_data.size) + 32 len 32 * _8911] = mem[_8623 + _8767 + 32 len 32 * _8911]
                                    if 0 >= _8911:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8623 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8623 + ceil32(return_data.size) + 32]
                                    if 1 >= _8911:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8623 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5754:
                                            revert with 0, 17
                                        mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                        mem[_5758 + 132] = 0
                                        mem[_5758 + 164] = 160
                                        mem[_5758 + 260] = mem[_5758]
                                        idx = 0
                                        s = _5758 + 292
                                        t = _5758 + 32
                                        while idx < mem[_5758]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5758 + 196] = this.address
                                        mem[_5758 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8624 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8768 = mem[_8624]
                                        require mem[_8624] <= test266151307()
                                        require _8624 + mem[_8624] + 31 < _8624 + return_data.size
                                        _8912 = mem[_8624 + mem[_8624]]
                                        if mem[_8624 + mem[_8624]] > test266151307():
                                            revert with 0, 65
                                        if _8624 + ceil32(return_data.size) + ceil32(32 * mem[_8624 + mem[_8624]]) + 1 > test266151307() or ceil32(32 * mem[_8624 + mem[_8624]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8624 + ceil32(return_data.size) + ceil32(32 * mem[_8624 + mem[_8624]]) + 1
                                        mem[_8624 + ceil32(return_data.size)] = _8912
                                        require return_data.size >= _8768 + (32 * _8912) + 32
                                        mem[_8624 + ceil32(return_data.size) + 32 len 32 * _8912] = mem[_8624 + _8768 + 32 len 32 * _8912]
                                        if 0 >= _8912:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8624 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8624 + ceil32(return_data.size) + 32]
                                        if 1 >= _8912:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8624 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8625 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8769 = mem[_8625]
                                            require mem[_8625] <= test266151307()
                                            require _8625 + mem[_8625] + 31 < _8625 + return_data.size
                                            _8913 = mem[_8625 + mem[_8625]]
                                            if mem[_8625 + mem[_8625]] > test266151307():
                                                revert with 0, 65
                                            if _8625 + ceil32(return_data.size) + ceil32(32 * mem[_8625 + mem[_8625]]) + 1 > test266151307() or ceil32(32 * mem[_8625 + mem[_8625]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8625 + ceil32(return_data.size) + ceil32(32 * mem[_8625 + mem[_8625]]) + 1
                                            mem[_8625 + ceil32(return_data.size)] = _8913
                                            require return_data.size >= _8769 + (32 * _8913) + 32
                                            mem[_8625 + ceil32(return_data.size) + 32 len 32 * _8913] = mem[_8625 + _8769 + 32 len 32 * _8913]
                                            if 0 >= _8913:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8625 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8625 + ceil32(return_data.size) + 32]
                                            if 1 >= _8913:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8625 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8626 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8770 = mem[_8626]
                                            require mem[_8626] <= test266151307()
                                            require _8626 + mem[_8626] + 31 < _8626 + return_data.size
                                            _8914 = mem[_8626 + mem[_8626]]
                                            if mem[_8626 + mem[_8626]] > test266151307():
                                                revert with 0, 65
                                            if _8626 + ceil32(return_data.size) + ceil32(32 * mem[_8626 + mem[_8626]]) + 1 > test266151307() or ceil32(32 * mem[_8626 + mem[_8626]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8626 + ceil32(return_data.size) + ceil32(32 * mem[_8626 + mem[_8626]]) + 1
                                            mem[_8626 + ceil32(return_data.size)] = _8914
                                            require return_data.size >= _8770 + (32 * _8914) + 32
                                            mem[_8626 + ceil32(return_data.size) + 32 len 32 * _8914] = mem[_8626 + _8770 + 32 len 32 * _8914]
                                            if 0 >= _8914:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8626 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8626 + ceil32(return_data.size) + 32]
                                            if 1 >= _8914:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8626 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5754:
                                        revert with 0, 17
                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                    mem[_5758 + 132] = 0
                                    mem[_5758 + 164] = 160
                                    mem[_5758 + 260] = mem[_5758]
                                    idx = 0
                                    s = _5758 + 292
                                    t = _5758 + 32
                                    while idx < mem[_5758]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5758 + 196] = this.address
                                    mem[_5758 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8627 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8771 = mem[_8627]
                                    require mem[_8627] <= test266151307()
                                    require _8627 + mem[_8627] + 31 < _8627 + return_data.size
                                    _8915 = mem[_8627 + mem[_8627]]
                                    if mem[_8627 + mem[_8627]] > test266151307():
                                        revert with 0, 65
                                    if _8627 + ceil32(return_data.size) + ceil32(32 * mem[_8627 + mem[_8627]]) + 1 > test266151307() or ceil32(32 * mem[_8627 + mem[_8627]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8627 + ceil32(return_data.size) + ceil32(32 * mem[_8627 + mem[_8627]]) + 1
                                    mem[_8627 + ceil32(return_data.size)] = _8915
                                    require return_data.size >= _8771 + (32 * _8915) + 32
                                    mem[_8627 + ceil32(return_data.size) + 32 len 32 * _8915] = mem[_8627 + _8771 + 32 len 32 * _8915]
                                    if 0 >= _8915:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8627 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8627 + ceil32(return_data.size) + 32]
                                    if 1 >= _8915:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8627 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5754:
                                        revert with 0, 17
                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                    mem[_5758 + 132] = 0
                                    mem[_5758 + 164] = 160
                                    mem[_5758 + 260] = mem[_5758]
                                    idx = 0
                                    s = _5758 + 292
                                    t = _5758 + 32
                                    while idx < mem[_5758]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5758 + 196] = this.address
                                    mem[_5758 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8628 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8772 = mem[_8628]
                                    require mem[_8628] <= test266151307()
                                    require _8628 + mem[_8628] + 31 < _8628 + return_data.size
                                    _8916 = mem[_8628 + mem[_8628]]
                                    if mem[_8628 + mem[_8628]] > test266151307():
                                        revert with 0, 65
                                    if _8628 + ceil32(return_data.size) + ceil32(32 * mem[_8628 + mem[_8628]]) + 1 > test266151307() or ceil32(32 * mem[_8628 + mem[_8628]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8628 + ceil32(return_data.size) + ceil32(32 * mem[_8628 + mem[_8628]]) + 1
                                    mem[_8628 + ceil32(return_data.size)] = _8916
                                    require return_data.size >= _8772 + (32 * _8916) + 32
                                    mem[_8628 + ceil32(return_data.size) + 32 len 32 * _8916] = mem[_8628 + _8772 + 32 len 32 * _8916]
                                    if 0 >= _8916:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8628 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8628 + ceil32(return_data.size) + 32]
                                    if 1 >= _8916:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8628 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5754:
                                        revert with 0, 17
                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                    mem[_5758 + 132] = 0
                                    mem[_5758 + 164] = 160
                                    mem[_5758 + 260] = mem[_5758]
                                    idx = 0
                                    s = _5758 + 292
                                    t = _5758 + 32
                                    while idx < mem[_5758]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5758 + 196] = this.address
                                    mem[_5758 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8629 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _8773 = mem[_8629]
                                    require mem[_8629] <= test266151307()
                                    require _8629 + mem[_8629] + 31 < _8629 + return_data.size
                                    _8917 = mem[_8629 + mem[_8629]]
                                    if mem[_8629 + mem[_8629]] > test266151307():
                                        revert with 0, 65
                                    if _8629 + ceil32(return_data.size) + ceil32(32 * mem[_8629 + mem[_8629]]) + 1 > test266151307() or ceil32(32 * mem[_8629 + mem[_8629]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _8629 + ceil32(return_data.size) + ceil32(32 * mem[_8629 + mem[_8629]]) + 1
                                    mem[_8629 + ceil32(return_data.size)] = _8917
                                    require return_data.size >= _8773 + (32 * _8917) + 32
                                    mem[_8629 + ceil32(return_data.size) + 32 len 32 * _8917] = mem[_8629 + _8773 + 32 len 32 * _8917]
                                    if 0 >= _8917:
                                        revert with 0, 50
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8629 + ceil32(return_data.size) + 32]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8629 + ceil32(return_data.size) + 32]
                                    if 1 >= _8917:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_8629 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5754:
                                            revert with 0, 17
                                        mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                        mem[_5758 + 132] = 0
                                        mem[_5758 + 164] = 160
                                        mem[_5758 + 260] = mem[_5758]
                                        idx = 0
                                        s = _5758 + 292
                                        t = _5758 + 32
                                        while idx < mem[_5758]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5758 + 196] = this.address
                                        mem[_5758 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8630 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8774 = mem[_8630]
                                        require mem[_8630] <= test266151307()
                                        require _8630 + mem[_8630] + 31 < _8630 + return_data.size
                                        _8918 = mem[_8630 + mem[_8630]]
                                        if mem[_8630 + mem[_8630]] > test266151307():
                                            revert with 0, 65
                                        if _8630 + ceil32(return_data.size) + ceil32(32 * mem[_8630 + mem[_8630]]) + 1 > test266151307() or ceil32(32 * mem[_8630 + mem[_8630]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8630 + ceil32(return_data.size) + ceil32(32 * mem[_8630 + mem[_8630]]) + 1
                                        mem[_8630 + ceil32(return_data.size)] = _8918
                                        require return_data.size >= _8774 + (32 * _8918) + 32
                                        mem[_8630 + ceil32(return_data.size) + 32 len 32 * _8918] = mem[_8630 + _8774 + 32 len 32 * _8918]
                                        if 0 >= _8918:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8630 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8630 + ceil32(return_data.size) + 32]
                                        if 1 >= _8918:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8630 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8631 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8775 = mem[_8631]
                                            require mem[_8631] <= test266151307()
                                            require _8631 + mem[_8631] + 31 < _8631 + return_data.size
                                            _8919 = mem[_8631 + mem[_8631]]
                                            if mem[_8631 + mem[_8631]] > test266151307():
                                                revert with 0, 65
                                            if _8631 + ceil32(return_data.size) + ceil32(32 * mem[_8631 + mem[_8631]]) + 1 > test266151307() or ceil32(32 * mem[_8631 + mem[_8631]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8631 + ceil32(return_data.size) + ceil32(32 * mem[_8631 + mem[_8631]]) + 1
                                            mem[_8631 + ceil32(return_data.size)] = _8919
                                            require return_data.size >= _8775 + (32 * _8919) + 32
                                            mem[_8631 + ceil32(return_data.size) + 32 len 32 * _8919] = mem[_8631 + _8775 + 32 len 32 * _8919]
                                            if 0 >= _8919:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8631 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8631 + ceil32(return_data.size) + 32]
                                            if 1 >= _8919:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8631 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8632 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8776 = mem[_8632]
                                            require mem[_8632] <= test266151307()
                                            require _8632 + mem[_8632] + 31 < _8632 + return_data.size
                                            _8920 = mem[_8632 + mem[_8632]]
                                            if mem[_8632 + mem[_8632]] > test266151307():
                                                revert with 0, 65
                                            if _8632 + ceil32(return_data.size) + ceil32(32 * mem[_8632 + mem[_8632]]) + 1 > test266151307() or ceil32(32 * mem[_8632 + mem[_8632]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8632 + ceil32(return_data.size) + ceil32(32 * mem[_8632 + mem[_8632]]) + 1
                                            mem[_8632 + ceil32(return_data.size)] = _8920
                                            require return_data.size >= _8776 + (32 * _8920) + 32
                                            mem[_8632 + ceil32(return_data.size) + 32 len 32 * _8920] = mem[_8632 + _8776 + 32 len 32 * _8920]
                                            if 0 >= _8920:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8632 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8632 + ceil32(return_data.size) + 32]
                                            if 1 >= _8920:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8632 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5754:
                                            revert with 0, 17
                                        mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                        mem[_5758 + 132] = 0
                                        mem[_5758 + 164] = 160
                                        mem[_5758 + 260] = mem[_5758]
                                        idx = 0
                                        s = _5758 + 292
                                        t = _5758 + 32
                                        while idx < mem[_5758]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5758 + 196] = this.address
                                        mem[_5758 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8633 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8777 = mem[_8633]
                                        require mem[_8633] <= test266151307()
                                        require _8633 + mem[_8633] + 31 < _8633 + return_data.size
                                        _8921 = mem[_8633 + mem[_8633]]
                                        if mem[_8633 + mem[_8633]] > test266151307():
                                            revert with 0, 65
                                        if _8633 + ceil32(return_data.size) + ceil32(32 * mem[_8633 + mem[_8633]]) + 1 > test266151307() or ceil32(32 * mem[_8633 + mem[_8633]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8633 + ceil32(return_data.size) + ceil32(32 * mem[_8633 + mem[_8633]]) + 1
                                        mem[_8633 + ceil32(return_data.size)] = _8921
                                        require return_data.size >= _8777 + (32 * _8921) + 32
                                        mem[_8633 + ceil32(return_data.size) + 32 len 32 * _8921] = mem[_8633 + _8777 + 32 len 32 * _8921]
                                        if 0 >= _8921:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8633 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8633 + ceil32(return_data.size) + 32]
                                        if 1 >= _8921:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8633 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5754:
                                            revert with 0, 17
                                        mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                        mem[_5758 + 132] = 0
                                        mem[_5758 + 164] = 160
                                        mem[_5758 + 260] = mem[_5758]
                                        idx = 0
                                        s = _5758 + 292
                                        t = _5758 + 32
                                        while idx < mem[_5758]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5758 + 196] = this.address
                                        mem[_5758 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8634 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8778 = mem[_8634]
                                        require mem[_8634] <= test266151307()
                                        require _8634 + mem[_8634] + 31 < _8634 + return_data.size
                                        _8922 = mem[_8634 + mem[_8634]]
                                        if mem[_8634 + mem[_8634]] > test266151307():
                                            revert with 0, 65
                                        if _8634 + ceil32(return_data.size) + ceil32(32 * mem[_8634 + mem[_8634]]) + 1 > test266151307() or ceil32(32 * mem[_8634 + mem[_8634]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8634 + ceil32(return_data.size) + ceil32(32 * mem[_8634 + mem[_8634]]) + 1
                                        mem[_8634 + ceil32(return_data.size)] = _8922
                                        require return_data.size >= _8778 + (32 * _8922) + 32
                                        mem[_8634 + ceil32(return_data.size) + 32 len 32 * _8922] = mem[_8634 + _8778 + 32 len 32 * _8922]
                                        if 0 >= _8922:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8634 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8634 + ceil32(return_data.size) + 32]
                                        if 1 >= _8922:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8634 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5754:
                                            revert with 0, 17
                                        mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                        mem[_5758 + 132] = 0
                                        mem[_5758 + 164] = 160
                                        mem[_5758 + 260] = mem[_5758]
                                        idx = 0
                                        s = _5758 + 292
                                        t = _5758 + 32
                                        while idx < mem[_5758]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5758 + 196] = this.address
                                        mem[_5758 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8635 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _8779 = mem[_8635]
                                        require mem[_8635] <= test266151307()
                                        require _8635 + mem[_8635] + 31 < _8635 + return_data.size
                                        _8923 = mem[_8635 + mem[_8635]]
                                        if mem[_8635 + mem[_8635]] > test266151307():
                                            revert with 0, 65
                                        if _8635 + ceil32(return_data.size) + ceil32(32 * mem[_8635 + mem[_8635]]) + 1 > test266151307() or ceil32(32 * mem[_8635 + mem[_8635]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8635 + ceil32(return_data.size) + ceil32(32 * mem[_8635 + mem[_8635]]) + 1
                                        mem[_8635 + ceil32(return_data.size)] = _8923
                                        require return_data.size >= _8779 + (32 * _8923) + 32
                                        mem[_8635 + ceil32(return_data.size) + 32 len 32 * _8923] = mem[_8635 + _8779 + 32 len 32 * _8923]
                                        if 0 >= _8923:
                                            revert with 0, 50
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8635 + ceil32(return_data.size) + 32]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8635 + ceil32(return_data.size) + 32]
                                        if 1 >= _8923:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_8635 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8636 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8780 = mem[_8636]
                                            require mem[_8636] <= test266151307()
                                            require _8636 + mem[_8636] + 31 < _8636 + return_data.size
                                            _8924 = mem[_8636 + mem[_8636]]
                                            if mem[_8636 + mem[_8636]] > test266151307():
                                                revert with 0, 65
                                            if _8636 + ceil32(return_data.size) + ceil32(32 * mem[_8636 + mem[_8636]]) + 1 > test266151307() or ceil32(32 * mem[_8636 + mem[_8636]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8636 + ceil32(return_data.size) + ceil32(32 * mem[_8636 + mem[_8636]]) + 1
                                            mem[_8636 + ceil32(return_data.size)] = _8924
                                            require return_data.size >= _8780 + (32 * _8924) + 32
                                            mem[_8636 + ceil32(return_data.size) + 32 len 32 * _8924] = mem[_8636 + _8780 + 32 len 32 * _8924]
                                            if 0 >= _8924:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8636 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8636 + ceil32(return_data.size) + 32]
                                            if 1 >= _8924:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8636 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5754:
                                                    revert with 0, 17
                                                mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                                mem[_5758 + 132] = 0
                                                mem[_5758 + 164] = 160
                                                mem[_5758 + 260] = mem[_5758]
                                                idx = 0
                                                s = _5758 + 292
                                                t = _5758 + 32
                                                while idx < mem[_5758]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5758 + 196] = this.address
                                                mem[_5758 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8637 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8781 = mem[_8637]
                                                require mem[_8637] <= test266151307()
                                                require _8637 + mem[_8637] + 31 < _8637 + return_data.size
                                                _8925 = mem[_8637 + mem[_8637]]
                                                if mem[_8637 + mem[_8637]] > test266151307():
                                                    revert with 0, 65
                                                if _8637 + ceil32(return_data.size) + ceil32(32 * mem[_8637 + mem[_8637]]) + 1 > test266151307() or ceil32(32 * mem[_8637 + mem[_8637]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8637 + ceil32(return_data.size) + ceil32(32 * mem[_8637 + mem[_8637]]) + 1
                                                mem[_8637 + ceil32(return_data.size)] = _8925
                                                require return_data.size >= _8781 + (32 * _8925) + 32
                                                mem[_8637 + ceil32(return_data.size) + 32 len 32 * _8925] = mem[_8637 + _8781 + 32 len 32 * _8925]
                                                if 0 >= _8925:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8637 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8637 + ceil32(return_data.size) + 32]
                                                if 1 >= _8925:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8637 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5754:
                                                    revert with 0, 17
                                                mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                                mem[_5758 + 132] = 0
                                                mem[_5758 + 164] = 160
                                                mem[_5758 + 260] = mem[_5758]
                                                idx = 0
                                                s = _5758 + 292
                                                t = _5758 + 32
                                                while idx < mem[_5758]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5758 + 196] = this.address
                                                mem[_5758 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8638 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8782 = mem[_8638]
                                                require mem[_8638] <= test266151307()
                                                require _8638 + mem[_8638] + 31 < _8638 + return_data.size
                                                _8926 = mem[_8638 + mem[_8638]]
                                                if mem[_8638 + mem[_8638]] > test266151307():
                                                    revert with 0, 65
                                                if _8638 + ceil32(return_data.size) + ceil32(32 * mem[_8638 + mem[_8638]]) + 1 > test266151307() or ceil32(32 * mem[_8638 + mem[_8638]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8638 + ceil32(return_data.size) + ceil32(32 * mem[_8638 + mem[_8638]]) + 1
                                                mem[_8638 + ceil32(return_data.size)] = _8926
                                                require return_data.size >= _8782 + (32 * _8926) + 32
                                                mem[_8638 + ceil32(return_data.size) + 32 len 32 * _8926] = mem[_8638 + _8782 + 32 len 32 * _8926]
                                                if 0 >= _8926:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8638 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8638 + ceil32(return_data.size) + 32]
                                                if 1 >= _8926:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8638 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8639 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8783 = mem[_8639]
                                            require mem[_8639] <= test266151307()
                                            require _8639 + mem[_8639] + 31 < _8639 + return_data.size
                                            _8927 = mem[_8639 + mem[_8639]]
                                            if mem[_8639 + mem[_8639]] > test266151307():
                                                revert with 0, 65
                                            if _8639 + ceil32(return_data.size) + ceil32(32 * mem[_8639 + mem[_8639]]) + 1 > test266151307() or ceil32(32 * mem[_8639 + mem[_8639]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8639 + ceil32(return_data.size) + ceil32(32 * mem[_8639 + mem[_8639]]) + 1
                                            mem[_8639 + ceil32(return_data.size)] = _8927
                                            require return_data.size >= _8783 + (32 * _8927) + 32
                                            mem[_8639 + ceil32(return_data.size) + 32 len 32 * _8927] = mem[_8639 + _8783 + 32 len 32 * _8927]
                                            if 0 >= _8927:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8639 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8639 + ceil32(return_data.size) + 32]
                                            if 1 >= _8927:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8639 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8640 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8784 = mem[_8640]
                                            require mem[_8640] <= test266151307()
                                            require _8640 + mem[_8640] + 31 < _8640 + return_data.size
                                            _8928 = mem[_8640 + mem[_8640]]
                                            if mem[_8640 + mem[_8640]] > test266151307():
                                                revert with 0, 65
                                            if _8640 + ceil32(return_data.size) + ceil32(32 * mem[_8640 + mem[_8640]]) + 1 > test266151307() or ceil32(32 * mem[_8640 + mem[_8640]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8640 + ceil32(return_data.size) + ceil32(32 * mem[_8640 + mem[_8640]]) + 1
                                            mem[_8640 + ceil32(return_data.size)] = _8928
                                            require return_data.size >= _8784 + (32 * _8928) + 32
                                            mem[_8640 + ceil32(return_data.size) + 32 len 32 * _8928] = mem[_8640 + _8784 + 32 len 32 * _8928]
                                            if 0 >= _8928:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8640 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8640 + ceil32(return_data.size) + 32]
                                            if 1 >= _8928:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8640 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8641 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8785 = mem[_8641]
                                            require mem[_8641] <= test266151307()
                                            require _8641 + mem[_8641] + 31 < _8641 + return_data.size
                                            _8929 = mem[_8641 + mem[_8641]]
                                            if mem[_8641 + mem[_8641]] > test266151307():
                                                revert with 0, 65
                                            if _8641 + ceil32(return_data.size) + ceil32(32 * mem[_8641 + mem[_8641]]) + 1 > test266151307() or ceil32(32 * mem[_8641 + mem[_8641]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8641 + ceil32(return_data.size) + ceil32(32 * mem[_8641 + mem[_8641]]) + 1
                                            mem[_8641 + ceil32(return_data.size)] = _8929
                                            require return_data.size >= _8785 + (32 * _8929) + 32
                                            mem[_8641 + ceil32(return_data.size) + 32 len 32 * _8929] = mem[_8641 + _8785 + 32 len 32 * _8929]
                                            if 0 >= _8929:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8641 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8641 + ceil32(return_data.size) + 32]
                                            if 1 >= _8929:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8641 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5754:
                                                    revert with 0, 17
                                                mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                                mem[_5758 + 132] = 0
                                                mem[_5758 + 164] = 160
                                                mem[_5758 + 260] = mem[_5758]
                                                idx = 0
                                                s = _5758 + 292
                                                t = _5758 + 32
                                                while idx < mem[_5758]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5758 + 196] = this.address
                                                mem[_5758 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8642 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8786 = mem[_8642]
                                                require mem[_8642] <= test266151307()
                                                require _8642 + mem[_8642] + 31 < _8642 + return_data.size
                                                _8930 = mem[_8642 + mem[_8642]]
                                                if mem[_8642 + mem[_8642]] > test266151307():
                                                    revert with 0, 65
                                                if _8642 + ceil32(return_data.size) + ceil32(32 * mem[_8642 + mem[_8642]]) + 1 > test266151307() or ceil32(32 * mem[_8642 + mem[_8642]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8642 + ceil32(return_data.size) + ceil32(32 * mem[_8642 + mem[_8642]]) + 1
                                                mem[_8642 + ceil32(return_data.size)] = _8930
                                                require return_data.size >= _8786 + (32 * _8930) + 32
                                                mem[_8642 + ceil32(return_data.size) + 32 len 32 * _8930] = mem[_8642 + _8786 + 32 len 32 * _8930]
                                                if 0 >= _8930:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8642 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8642 + ceil32(return_data.size) + 32]
                                                if 1 >= _8930:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8642 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5754:
                                                        revert with 0, 17
                                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                                    mem[_5758 + 132] = 0
                                                    mem[_5758 + 164] = 160
                                                    mem[_5758 + 260] = mem[_5758]
                                                    idx = 0
                                                    s = _5758 + 292
                                                    t = _5758 + 32
                                                    while idx < mem[_5758]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5758 + 196] = this.address
                                                    mem[_5758 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8643 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8787 = mem[_8643]
                                                    require mem[_8643] <= test266151307()
                                                    require _8643 + mem[_8643] + 31 < _8643 + return_data.size
                                                    _8931 = mem[_8643 + mem[_8643]]
                                                    if mem[_8643 + mem[_8643]] > test266151307():
                                                        revert with 0, 65
                                                    if _8643 + ceil32(return_data.size) + ceil32(32 * mem[_8643 + mem[_8643]]) + 1 > test266151307() or ceil32(32 * mem[_8643 + mem[_8643]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8643 + ceil32(return_data.size) + ceil32(32 * mem[_8643 + mem[_8643]]) + 1
                                                    mem[_8643 + ceil32(return_data.size)] = _8931
                                                    require return_data.size >= _8787 + (32 * _8931) + 32
                                                    mem[_8643 + ceil32(return_data.size) + 32 len 32 * _8931] = mem[_8643 + _8787 + 32 len 32 * _8931]
                                                    if 0 >= _8931:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8643 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8643 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8931:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8643 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5754:
                                                        revert with 0, 17
                                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                                    mem[_5758 + 132] = 0
                                                    mem[_5758 + 164] = 160
                                                    mem[_5758 + 260] = mem[_5758]
                                                    idx = 0
                                                    s = _5758 + 292
                                                    t = _5758 + 32
                                                    while idx < mem[_5758]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5758 + 196] = this.address
                                                    mem[_5758 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8644 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8788 = mem[_8644]
                                                    require mem[_8644] <= test266151307()
                                                    require _8644 + mem[_8644] + 31 < _8644 + return_data.size
                                                    _8932 = mem[_8644 + mem[_8644]]
                                                    if mem[_8644 + mem[_8644]] > test266151307():
                                                        revert with 0, 65
                                                    if _8644 + ceil32(return_data.size) + ceil32(32 * mem[_8644 + mem[_8644]]) + 1 > test266151307() or ceil32(32 * mem[_8644 + mem[_8644]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8644 + ceil32(return_data.size) + ceil32(32 * mem[_8644 + mem[_8644]]) + 1
                                                    mem[_8644 + ceil32(return_data.size)] = _8932
                                                    require return_data.size >= _8788 + (32 * _8932) + 32
                                                    mem[_8644 + ceil32(return_data.size) + 32 len 32 * _8932] = mem[_8644 + _8788 + 32 len 32 * _8932]
                                                    if 0 >= _8932:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8644 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8644 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8932:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8644 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8645 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8789 = mem[_8645]
                                            require mem[_8645] <= test266151307()
                                            require _8645 + mem[_8645] + 31 < _8645 + return_data.size
                                            _8933 = mem[_8645 + mem[_8645]]
                                            if mem[_8645 + mem[_8645]] > test266151307():
                                                revert with 0, 65
                                            if _8645 + ceil32(return_data.size) + ceil32(32 * mem[_8645 + mem[_8645]]) + 1 > test266151307() or ceil32(32 * mem[_8645 + mem[_8645]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8645 + ceil32(return_data.size) + ceil32(32 * mem[_8645 + mem[_8645]]) + 1
                                            mem[_8645 + ceil32(return_data.size)] = _8933
                                            require return_data.size >= _8789 + (32 * _8933) + 32
                                            mem[_8645 + ceil32(return_data.size) + 32 len 32 * _8933] = mem[_8645 + _8789 + 32 len 32 * _8933]
                                            if 0 >= _8933:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8645 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8645 + ceil32(return_data.size) + 32]
                                            if 1 >= _8933:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8645 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8646 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8790 = mem[_8646]
                                            require mem[_8646] <= test266151307()
                                            require _8646 + mem[_8646] + 31 < _8646 + return_data.size
                                            _8934 = mem[_8646 + mem[_8646]]
                                            if mem[_8646 + mem[_8646]] > test266151307():
                                                revert with 0, 65
                                            if _8646 + ceil32(return_data.size) + ceil32(32 * mem[_8646 + mem[_8646]]) + 1 > test266151307() or ceil32(32 * mem[_8646 + mem[_8646]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8646 + ceil32(return_data.size) + ceil32(32 * mem[_8646 + mem[_8646]]) + 1
                                            mem[_8646 + ceil32(return_data.size)] = _8934
                                            require return_data.size >= _8790 + (32 * _8934) + 32
                                            mem[_8646 + ceil32(return_data.size) + 32 len 32 * _8934] = mem[_8646 + _8790 + 32 len 32 * _8934]
                                            if 0 >= _8934:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8646 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8646 + ceil32(return_data.size) + 32]
                                            if 1 >= _8934:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8646 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5754:
                                                revert with 0, 17
                                            mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                            mem[_5758 + 132] = 0
                                            mem[_5758 + 164] = 160
                                            mem[_5758 + 260] = mem[_5758]
                                            idx = 0
                                            s = _5758 + 292
                                            t = _5758 + 32
                                            while idx < mem[_5758]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5758 + 196] = this.address
                                            mem[_5758 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8647 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _8791 = mem[_8647]
                                            require mem[_8647] <= test266151307()
                                            require _8647 + mem[_8647] + 31 < _8647 + return_data.size
                                            _8935 = mem[_8647 + mem[_8647]]
                                            if mem[_8647 + mem[_8647]] > test266151307():
                                                revert with 0, 65
                                            if _8647 + ceil32(return_data.size) + ceil32(32 * mem[_8647 + mem[_8647]]) + 1 > test266151307() or ceil32(32 * mem[_8647 + mem[_8647]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _8647 + ceil32(return_data.size) + ceil32(32 * mem[_8647 + mem[_8647]]) + 1
                                            mem[_8647 + ceil32(return_data.size)] = _8935
                                            require return_data.size >= _8791 + (32 * _8935) + 32
                                            mem[_8647 + ceil32(return_data.size) + 32 len 32 * _8935] = mem[_8647 + _8791 + 32 len 32 * _8935]
                                            if 0 >= _8935:
                                                revert with 0, 50
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8647 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8647 + ceil32(return_data.size) + 32]
                                            if 1 >= _8935:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_8647 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5754:
                                                    revert with 0, 17
                                                mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                                mem[_5758 + 132] = 0
                                                mem[_5758 + 164] = 160
                                                mem[_5758 + 260] = mem[_5758]
                                                idx = 0
                                                s = _5758 + 292
                                                t = _5758 + 32
                                                while idx < mem[_5758]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5758 + 196] = this.address
                                                mem[_5758 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _8648 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _8792 = mem[_8648]
                                                require mem[_8648] <= test266151307()
                                                require _8648 + mem[_8648] + 31 < _8648 + return_data.size
                                                _8936 = mem[_8648 + mem[_8648]]
                                                if mem[_8648 + mem[_8648]] > test266151307():
                                                    revert with 0, 65
                                                if _8648 + ceil32(return_data.size) + ceil32(32 * mem[_8648 + mem[_8648]]) + 1 > test266151307() or ceil32(32 * mem[_8648 + mem[_8648]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8648 + ceil32(return_data.size) + ceil32(32 * mem[_8648 + mem[_8648]]) + 1
                                                mem[_8648 + ceil32(return_data.size)] = _8936
                                                require return_data.size >= _8792 + (32 * _8936) + 32
                                                mem[_8648 + ceil32(return_data.size) + 32 len 32 * _8936] = mem[_8648 + _8792 + 32 len 32 * _8936]
                                                if 0 >= _8936:
                                                    revert with 0, 50
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8648 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8648 + ceil32(return_data.size) + 32]
                                                if 1 >= _8936:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_8648 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5754:
                                                        revert with 0, 17
                                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5758 + 100] = ext_call.return_data[32] + _5754
                                                    mem[_5758 + 132] = 0
                                                    mem[_5758 + 164] = 160
                                                    mem[_5758 + 260] = mem[_5758]
                                                    idx = 0
                                                    s = _5758 + 292
                                                    t = _5758 + 32
                                                    while idx < mem[_5758]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5758 + 196] = this.address
                                                    mem[_5758 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8649 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8793 = mem[_8649]
                                                    require mem[_8649] <= test266151307()
                                                    require _8649 + mem[_8649] + 31 < _8649 + return_data.size
                                                    _8937 = mem[_8649 + mem[_8649]]
                                                    if mem[_8649 + mem[_8649]] > test266151307():
                                                        revert with 0, 65
                                                    if _8649 + ceil32(return_data.size) + ceil32(32 * mem[_8649 + mem[_8649]]) + 1 > test266151307() or ceil32(32 * mem[_8649 + mem[_8649]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8649 + ceil32(return_data.size) + ceil32(32 * mem[_8649 + mem[_8649]]) + 1
                                                    mem[_8649 + ceil32(return_data.size)] = _8937
                                                    require return_data.size >= _8793 + (32 * _8937) + 32
                                                    mem[_8649 + ceil32(return_data.size) + 32 len 32 * _8937] = mem[_8649 + _8793 + 32 len 32 * _8937]
                                                    if 0 >= _8937:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8649 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8649 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8937:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8649 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5754:
                                                        revert with 0, 17
                                                    mem[_5758 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5758 + 100] = ext_call.return_data[0] + _5754
                                                    mem[_5758 + 132] = 0
                                                    mem[_5758 + 164] = 160
                                                    mem[_5758 + 260] = mem[_5758]
                                                    idx = 0
                                                    s = _5758 + 292
                                                    t = _5758 + 32
                                                    while idx < mem[_5758]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5758 + 196] = this.address
                                                    mem[_5758 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5758 + (32 * mem[_5758]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8650 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _8794 = mem[_8650]
                                                    require mem[_8650] <= test266151307()
                                                    require _8650 + mem[_8650] + 31 < _8650 + return_data.size
                                                    _8938 = mem[_8650 + mem[_8650]]
                                                    if mem[_8650 + mem[_8650]] > test266151307():
                                                        revert with 0, 65
                                                    if _8650 + ceil32(return_data.size) + ceil32(32 * mem[_8650 + mem[_8650]]) + 1 > test266151307() or ceil32(32 * mem[_8650 + mem[_8650]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8650 + ceil32(return_data.size) + ceil32(32 * mem[_8650 + mem[_8650]]) + 1
                                                    mem[_8650 + ceil32(return_data.size)] = _8938
                                                    require return_data.size >= _8794 + (32 * _8938) + 32
                                                    mem[_8650 + ceil32(return_data.size) + 32 len 32 * _8938] = mem[_8650 + _8794 + 32 len 32 * _8938]
                                                    if 0 >= _8938:
                                                        revert with 0, 50
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < mem[_8650 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= mem[_8650 + ceil32(return_data.size) + 32]
                                                    if 1 >= _8938:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_8650 + ceil32(return_data.size) + 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}



}
